<docs>
<doc name="T:PeterO.ArrayWriter">
<summary>An array of bytes that grows as needed.
    </summary>
</doc>
<doc name="M:PeterO.ArrayWriter.#ctor">
<summary>Initializes a new instance of the
      <see cref='ArrayWriter'/>
       class with a default buffer size.
    </summary>
</doc>
<doc name="M:PeterO.ArrayWriter.#ctor(System.Int32)">
<summary>Initializes a new instance of the
      <see cref='ArrayWriter'/>
       class with the given initial buffer size.
    </summary>
    <param name='initialSize'>The parameter
      <paramref name='initialSize'/>
       is a 32-bit signed integer.
    </param>
</doc>
<doc name="M:PeterO.ArrayWriter.Clear">
<summary>Offers a fast way to reset the length of the array writer's data to 0.
    </summary>
</doc>
<doc name="M:PeterO.ArrayWriter.ToArray">
<summary>Generates an array of all bytes written so far to it.
    </summary>
    <returns>A byte array.
    </returns>
</doc>
<doc name="M:PeterO.ArrayWriter.Write(System.Byte[],System.Int32,System.Int32)">
<summary>Writes a series of bytes to the array.
    </summary>
    <param name='src'>Byte array containing the data to write.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='src'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='src'/>
       (but not more than
      <paramref name='src'/>
       's length).
    </param>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='src'/>
       is null.
    </exception>
    <exception cref='ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='src'/>
       's length, or
      <paramref name='src'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
</doc>
<doc name="M:PeterO.ArrayWriter.WriteByte(System.Int32)">
<summary>Writes an 8-bit byte to the array.
    </summary>
    <param name='byteValue'>An integer containing the byte to write. Only the lower 8 bits of this
      value will be used.
    </param>
</doc>
<doc name="T:PeterO.Cbor.CBORDataUtilities">
<summary>Contains methods useful for reading and writing data, with a focus on
      CBOR.
    </summary>
</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String)">
<summary>Parses a number whose format follows the JSON specification. See
      #ParseJSONNumber(String, integersOnly, parseOnly) for more information.
    </summary>
    <param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param>
    <returns>A CBOR object that represents the parsed number. Returns positive zero if
      the number is a zero that starts with a minus sign (such as "-0" or
      "-0.0"). Returns null if the parsing fails, including if the string is
      null or empty.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean)">
<summary>Parses a number whose format follows the JSON specification (RFC 8259).
      Roughly speaking, a valid number consists of an optional minus sign, one
      or more basic digits (starting with 1 to 9 unless the only digit is 0), an
      optional decimal point (".", full stop) with one or more basic digits, and
      an optional letter E or e with an optional plus or minus sign and one or
      more basic digits (the exponent).
    </summary>
    <param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param>
    <param name='integersOnly'>If true, no decimal points or exponents are allowed in the string.
    </param>
    <param name='positiveOnly'>If true, only positive numbers are allowed (the leading minus is
      disallowed).
    </param>
    <returns>A CBOR object that represents the parsed number. Returns positive zero if
      the number is a zero that starts with a minus sign (such as "-0" or
      "-0.0"). Returns null if the parsing fails, including if the string is
      null or empty.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean,System.Boolean)">
<summary>Parses a number whose format follows the JSON specification (RFC 8259).
      Roughly speaking, a valid number consists of an optional minus sign, one
      or more basic digits (starting with 1 to 9 unless the only digit is 0), an
      optional decimal point (".", full stop) with one or more basic digits, and
      an optional letter E or e with an optional plus or minus sign and one or
      more basic digits (the exponent).
    </summary>
    <param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param>
    <param name='integersOnly'>If true, no decimal points or exponents are allowed in the string.
    </param>
    <param name='positiveOnly'>If true, only positive numbers are allowed (the leading minus is
      disallowed).
    </param>
    <param name='preserveNegativeZero'>If true, returns positive zero if the number is a zero that starts with a
      minus sign (such as "-0" or "-0.0"). Otherwise, returns negative zero in
      this case.
    </param>
    <returns>A CBOR object that represents the parsed number. Returns null if the
      parsing fails, including if the string is null or empty.
    </returns>
</doc>
<doc name="T:PeterO.Cbor.URIUtility">
<summary>Contains auxiliary methods for processing Uniform Resource Identifiers
      (URIs) and Internationalized Resource Identifiers (IRIs) under RFC3986 and
      RFC3987, respectively. In the following documentation, URIs and IRIs
      include URI references and IRI references, for convenience.
    </summary>
</doc>
<doc name="T:PeterO.Cbor.URIUtility.ParseMode">
<summary>Specifies whether certain characters are allowed when parsing IRIs and
      URIs.
    </summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.IRILenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Even with this mode, strings with unpaired surrogate code points are
      considered invalid.
    </summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.IRIStrict">
<summary>The rules follow the syntax for parsing IRIs. In particular, many code
      points outside the Basic Latin range (U+0000 to U+007F) are allowed.
      Strings with unpaired surrogate code points are considered invalid.
    </summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.IRISurrogateLenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Unpaired surrogate code points are treated as though they were replacement
      characters instead for the purposes of these rules, so that strings with
      those code points are not considered invalid strings.
    </summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.URILenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Code points outside the Basic Latin range (U+0000 to U+007F) are not
      allowed.
    </summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.URIStrict">
<summary>The rules follow the syntax for parsing IRIs, except that code points
      outside the Basic Latin range (U+0000 to U+007F) are not allowed.
    </summary>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.PercentDecode(System.String)">
<summary>Decodes percent-encoding (of the form "%XX" where X is a hexadecimal (base-16) digit) in the given string. Successive percent-encoded bytes are assumed
      to form characters in UTF-8.
    </summary>
    <param name='str'>A string that may contain percent encoding. May be null.
    </param>
    <returns>The string in which percent-encoding was decoded. Returns null if "str" is
      null.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.escapeURI(System.String,System.Int32)">
<summary>Escapes characters that can't appear in URIs or IRIs. The function is
      idempotent; that is, calling the function again on the result with the
      same mode doesn't change the result.
    </summary>
    <param name='s'>A string to escape.
    </param>
    <param name='mode'>The parameter
      <paramref name='mode'/>
       is a 32-bit signed integer.
    </param>
    <returns>A string possibly containing escaped characters, or null if s is null.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.hasScheme(System.String)">
<summary>Determines whether the string is a valid IRI with a scheme component. This
      can be used to check for relative IRI references.
      <para>The following cases return true:
      </para>
      <code>xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid IRI with a scheme component; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.hasSchemeForURI(System.String)">
<summary>Determines whether the string is a valid URI with a scheme component. This
      can be used to check for relative URI references. The following cases
      return true:
      <code>http://example/z xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid URI with a scheme component; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)">
<summary>Determines whether the substring is a valid CURIE reference under RDFA
      1.1. (The CURIE reference is the part after the colon.).
    </summary>
    <param name='s'>A string containing a CURIE reference. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The number of elements in the desired portion of "s" (but not more than
      "s" 's length).
    </param>
    <returns><c>true</c> if the substring is a valid CURIE reference under RDFA 1; otherwise, <c>false</c> . Returns false if
      <paramref name='s'/>
       is null.
    </returns>
    <exception cref='ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.relativeResolve(System.String,System.String)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue. Example:
      <c>http://example.com/my/path/dir/file.txt</c> .
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.relativeResolve(System.String,System.String,PeterO.Cbor.URIUtility.ParseMode)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> . Can be null.
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.splitIRI(System.String)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI reference is syntactically valid, splits the string
      into its components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. The
      scheme, authority, query, and fragment components, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.splitIRI(System.String,PeterO.Cbor.URIUtility.ParseMode)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI is syntactically valid, splits the string into its
      components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string representing an IRI. Can be null.
    </param>
    <param name='parseMode'>The parameter
      <paramref name='parseMode'/>
       is a ParseMode object.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. The
      scheme, authority, query, and fragment components, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.splitIRI(System.String,System.Int32,System.Int32,PeterO.Cbor.URIUtility.ParseMode)">
<summary>Parses a substring that represents an Internationalized Resource
      Identifier (IRI) under RFC3987. If the IRI is syntactically valid, splits
      the string into its components and returns an array containing the indices
      into the components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The length of the desired portion of "s" (but not more than "s" 's
      length).
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>If the string is a valid IRI, returns an array of 10 integers. Each of the
      five pairs corresponds to the start and end index of the IRI's scheme,
      authority, path, query, or fragment component, respectively. The scheme,
      authority, query, and fragment components, if present, will each be given
      without the ending colon, the starting "//", the starting "?", and the
      starting "#", respectively. If a component is absent, both indices in that
      pair will be -1 (an index won't be less than 0 in any other case). If the
      string is null or is not a valid IRI, returns null.
    </returns>
    <exception cref='ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
</doc>
<doc name="T:PeterO.DataUtilities">
<summary>Contains methods useful for reading and writing text
            strings. It is designed to have no dependencies other than the
            basic runtime class library.
            <para>Many of these methods work with text encoded in UTF-8, an
            encoding form of the Unicode Standard which uses one byte to encode
            the most basic characters and two to four bytes to encode other
            characters. For example, the <c>GetUtf8</c> method converts a text
            string to an array of bytes in UTF-8.</para>
            <para>In C# and Java, text strings are represented as sequences of
            16-bit values called <c>char</c> s. These sequences are well-formed
            under UTF-16, a 16-bit encoding form of Unicode, except if they
            contain unpaired surrogate code points. (A surrogate code point is
            used to encode supplementary characters, those with code points
            U+10000 or higher, in UTF-16. A surrogate pair is a high surrogate,
            U+D800 to U+DBFF, followed by a low surrogate, U+DC00 to U+DFFF. An
            unpaired surrogate code point is a surrogate not appearing in a
            surrogate pair.) Many of the methods in this class allow setting
            the behavior to follow when unpaired surrogate code points are
            found in text strings, such as throwing an error or treating the
            unpaired surrogate as a replacement character
            (U+FFFD).</para></summary>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32)">
<summary>Gets the Unicode code point at the given index of the
            string.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <returns>The Unicode code point at the given position. Returns -1
            if <paramref name='index'/> is 0 or less, or is greater than the
            string's length. Returns the replacement character (U+FFFD) if the
            code point at that position is an unpaired surrogate code point. If
            the return value is 65536 (0x10000) or greater, the code point
            takes up two UTF-16 code units.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32,System.Int32)">
<summary>Gets the Unicode code point at the given index of the
            string.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <param name='surrogateBehavior'>Specifies what kind of value to
            return if the code point at the given index is an unpaired
            surrogate code point: if 0, return the replacement character (U+FFFD); if 1, return the value of the surrogate code point; if
            neither 0 nor 1, return -1.</param>
            <returns>The Unicode code point at the given position. Returns -1
            if <paramref name='index'/> is 0 or less, or is greater than the
            string's length. Returns a value as specified under <paramref name='surrogateBehavior'/> if the code point at that position is an
            unpaired surrogate code point. If the return value is 65536
            (0x10000) or greater, the code point takes up two UTF-16 code
            units.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
            <example><para>The following example shows how to iterate a text string code
            point by code point, terminating the loop when an unpaired
            surrogate is found.</para>
            <code>for (var i = 0;i&lt;str.Length; ++i) { int codePoint =
            DataUtilities.CodePointAt(str, i, 2); if (codePoint &lt; 0) { break; /*
            Unpaired surrogate */ } Console.WriteLine("codePoint:"+codePoint); if
            (codePoint &gt;= 0x10000) { i++; /* Supplementary code point */ } }</code> .
            </example>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32)">
<summary>Gets the Unicode code point just before the given index of
            the string.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <returns>The Unicode code point at the previous position. Returns
            -1 if <paramref name='index'/> is 0 or less, or is greater than the
            string's length. Returns the replacement character (U+FFFD) if the
            code point at the previous position is an unpaired surrogate code
            point. If the return value is 65536 (0x10000) or greater, the code
            point takes up two UTF-16 code units.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32,System.Int32)">
<summary>Gets the Unicode code point just before the given index of
            the string.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <param name='surrogateBehavior'>Specifies what kind of value to
            return if the previous code point is an unpaired surrogate code
            point: if 0, return the replacement character (U+FFFD); if 1,
            return the value of the surrogate code point; if neither 0 nor 1,
            return -1.</param>
            <returns>The Unicode code point at the previous position. Returns
            -1 if <paramref name='index'/> is 0 or less, or is greater than the
            string's length. Returns a value as specified under <paramref name='surrogateBehavior'/> if the code point at the previous
            position is an unpaired surrogate code point. If the return value
            is 65536 (0x10000) or greater, the code point takes up two UTF-16
            code units.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointCompare(System.String,System.String)">
<summary>Compares two strings in Unicode code point order. Unpaired
            surrogate code points are treated as individual code
            points.</summary>
            <param name='strA'>The first string. Can be null.</param>
            <param name='strB'>The second string. Can be null.</param>
            <returns>A value indicating which string is " less" or " greater" .
            0: Both strings are equal or null. Less than 0: a is null and b
            isn't; or the first code point that's different is less in A than
            in B; or b starts with a and is longer than a. Greater than 0: b is
            null and a isn't; or the first code point that's different is
            greater in A than in B; or a starts with b and is longer than
            b.</returns>
</doc>
<doc name="M:PeterO.DataUtilities.CodePointLength(System.String)">
<summary>Finds the number of Unicode code points in the given text
            string. Unpaired surrogate code points increase this number by 1.
            This is not necessarily the length of the string in "char"
            s.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <returns>The number of Unicode code points in the given
            string.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean)">
<summary><para>Encodes a string in UTF-8 as a byte array. This method does
            not insert a byte-order mark (U+FEFF) at the beginning of the
            encoded byte array.</para>
            <para>REMARK: It is not recommended to use
            <c>Encoding.UTF8.GetBytes</c> in.NET, or the <c>getBytes()</c> method in Java to do this. For instance, <c>getBytes()</c> encodes
            text strings in a default (so not fixed) character encoding, which
            can be undesirable.</para></summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <returns>The string encoded in UTF-8.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
            <exception cref='ArgumentException'>The string contains an unpaired
            surrogate code point and <paramref name='replace'/> is false, or an
            internal error occurred.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean,System.Boolean)">
<summary><para>Encodes a string in UTF-8 as a byte array. This method does
            not insert a byte-order mark (U+FEFF) at the beginning of the
            encoded byte array.</para>
            <para>REMARK: It is not recommended to use
            <c>Encoding.UTF8.GetBytes</c> in.NET, or the <c>getBytes()</c> method in Java to do this. For instance, <c>getBytes()</c> encodes
            text strings in a default (so not fixed) character encoding, which
            can be undesirable.</para></summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <param name='lenientLineBreaks'>If true, replaces carriage return
            (CR) not followed by line feed (LF) and LF not preceded by CR with
            CR-LF pairs.</param>
            <returns>The string encoded in UTF-8.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
            <exception cref='ArgumentException'>The string contains an unpaired
            surrogate code point and <paramref name='replace'/> is false, or an
            internal error occurred.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8Length(System.String,System.Boolean)">
<summary>Calculates the number of bytes needed to encode a string
            in UTF-8.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='replace'>If true, treats unpaired surrogate code
            points as having 3 UTF-8 bytes (the UTF-8 length of the replacement
            character U+FFFD).</param>
            <returns>The number of bytes needed to encode the given string in
            UTF-8, or -1 if the string contains an unpaired surrogate code
            point and <paramref name='replace'/> is false.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Boolean)">
<summary>Generates a text string from a UTF-8 byte array.</summary>
            <param name='bytes'>A byte array containing text encoded in
            UTF-8.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when
            invalid UTF-8 is seen.</param>
            <returns>A string represented by the UTF-8 byte array.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bytes'/> is null.</exception>
            <exception cref='ArgumentException'>The string is not valid UTF-8
            and <paramref name='replace'/> is false.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Int32,System.Int32,System.Boolean)">
<summary>Generates a text string from a portion of a UTF-8 byte
            array.</summary>
            <param name='bytes'>A byte array containing text encoded in
            UTF-8.</param>
            <param name='offset'>Offset into the byte array to start
            reading.</param>
            <param name='bytesCount'>Length, in bytes, of the UTF-8 text
            string.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when
            invalid UTF-8 is seen.</param>
            <returns>A string represented by the UTF-8 byte array.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bytes'/> is null.</exception>
            <exception cref='ArgumentException'>The portion of the byte array
            is not valid UTF-8 and <paramref name='replace'/> is
            false.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='offset'/> is less than 0, <paramref name='bytesCount'/> is
            less than 0, or offset plus bytesCount is greater than the length
            of "data" .</exception>
</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8(System.IO.Stream,System.Int32,System.Text.StringBuilder,System.Boolean)">
<summary>Reads a string in UTF-8 encoding from a data
            stream.</summary>
            <param name='stream'>A readable data stream.</param>
            <param name='bytesCount'>The length, in bytes, of the string. If
            this is less than 0, this function will read until the end of the
            stream.</param>
            <param name='builder'>A string builder object where the resulting
            string will be stored.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when an
            unpaired surrogate code point is seen.</param>
            <returns>0 if the entire string was read without errors, -1 if the
            string is not valid UTF-8 and <paramref name='replace'/> is false,
            or -2 if the end of the stream was reached before the last
            character was read completely (which is only the case if <paramref name='bytesCount'/> is 0 or greater).</returns>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null or <paramref name='builder'/> is
            null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8FromBytes(System.Byte[],System.Int32,System.Int32,System.Text.StringBuilder,System.Boolean)">
<summary>Reads a string in UTF-8 encoding from a byte
            array.</summary>
            <param name='data'>A byte array containing a UTF-8 text
            string.</param>
            <param name='offset'>Offset into the byte array to start
            reading.</param>
            <param name='bytesCount'>Length, in bytes, of the UTF-8 text
            string.</param>
            <param name='builder'>A string builder object where the resulting
            string will be stored.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when
            invalid UTF-8 is seen.</param>
            <returns>0 if the entire string was read without errors, or -1 if
            the string is not valid UTF-8 and <paramref name='replace'/> is
            false.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='data'/> is null or <paramref name='builder'/> is
            null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='offset'/> is less than 0, <paramref name='bytesCount'/> is
            less than 0, or offset plus bytesCount is greater than the length
            of <paramref name='data'/>.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream)">
<summary>Reads a string in UTF-8 encoding from a data stream in
            full and returns that string. Replaces invalid encoding with the
            replacement character (U+FFFD).</summary>
            <param name='stream'>A readable data stream.</param>
            <returns>The string read.</returns>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream,System.Int32,System.Boolean)">
<summary>Reads a string in UTF-8 encoding from a data stream and
            returns that string.</summary>
            <param name='stream'>A readable data stream.</param>
            <param name='bytesCount'>The length, in bytes, of the string. If
            this is less than 0, this function will read until the end of the
            stream.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, throws an error if an
            unpaired surrogate code point is seen.</param>
            <returns>The string read.</returns>
            <exception cref='System.IO.IOException'>An I/O error occurred; or,
            the string is not valid UTF-8 and <paramref name='replace'/> is
            false.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.ToLowerCaseAscii(System.String)">
<summary>Returns a string with the basic uppercase letters A to Z
            (U+0041 to U+005A) converted to lowercase. Other characters remain
            unchanged.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <returns>The converted string, or null if <paramref name='str'/> is
            null.</returns>
</doc>
<doc name="M:PeterO.DataUtilities.ToUpperCaseAscii(System.String)">
<summary>Returns a string with the basic lowercase letters A to Z
            (U+0061 to U+007A) converted to uppercase. Other characters remain
            unchanged.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <returns>The converted string, or null if <paramref name='str'/> is
            null.</returns>
</doc>
<doc name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.IO.Stream,System.Boolean)">
<summary>Writes a string in UTF-8 encoding to a data
            stream.</summary>
            <param name='str'>A string to write.</param>
            <param name='stream'>A writable data stream.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <returns>0 if the entire string was written; or -1 if the string
            contains an unpaired surrogate code point and <paramref name='replace'/> is false.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null or <paramref name='stream'/> is
            null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean)">
<summary>Writes a portion of a string in UTF-8 encoding to a data
            stream.</summary>
            <param name='str'>A string to write.</param>
            <param name='offset'>The Index starting at 0 where the string
            portion to write begins.</param>
            <param name='length'>The length of the string portion to
            write.</param>
            <param name='stream'>A writable data stream.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <returns>0 if the entire string portion was written; or -1 if the
            string portion contains an unpaired surrogate code point and
            <paramref name='replace'/> is false.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null or <paramref name='stream'/> is
            null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='ArgumentException'>Either <paramref name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='str'/> 's length, or <paramref name='str'/> 's length minus <paramref name='offset'/> is less than
            <paramref name='length'/>.</exception>
</doc>
<doc name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean,System.Boolean)">
<summary>Writes a portion of a string in UTF-8 encoding to a data
            stream.</summary>
            <param name='str'>A string to write.</param>
            <param name='offset'>The Index starting at 0 where the string
            portion to write begins.</param>
            <param name='length'>The length of the string portion to
            write.</param>
            <param name='stream'>A writable data stream.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <param name='lenientLineBreaks'>If true, replaces carriage return
            (CR) not followed by line feed (LF) and LF not preceded by CR with
            CR-LF pairs.</param>
            <returns>0 if the entire string portion was written; or -1 if the
            string portion contains an unpaired surrogate code point and
            <paramref name='replace'/> is false.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null or <paramref name='stream'/> is
            null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='offset'/> is less than 0, <paramref name='length'/> is less
            than 0, or <paramref name='offset'/> plus <paramref name='length'/>
            is greater than the string's length.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
</doc>
<doc name="T:PeterO.Mail.Address">

            <summary>Represents an email address.</summary>

</doc>
<doc name="M:PeterO.Mail.Address.#ctor(System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.Address'/> class.</summary>
            <param name='addressValue'>An email address. This parameter must
            contain an at-sign, and may not contain extraneous whitespace, and
            comments enclosed in parentheses are also not allowed.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='addressValue'/> is null.</exception>
            <exception cref='ArgumentException'>AddressValue is empty.; Address
            doesn't contain a '@'sign; Invalid local part; Expected '@'sign
            after local part; Expected domain after '@'; Invalid domain;
            Address too long.</exception>

</doc>
<doc name="P:PeterO.Mail.Address.Domain">

            <summary>Gets the domain of this email address (the part after the
            "@" sign).</summary>
            <value>The domain of this email address (the part after the "@"
            sign).</value>

</doc>
<doc name="M:PeterO.Mail.Address.Equals(System.Object)">

            <summary>Determines whether this object and another object are
            equal.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns><c>true</c> if this object and another object are equal; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Mail.Address.GetHashCode">

            <summary>Returns a hash code for this address object. No
            application or process identifiers are used in the hash code
            calculation.</summary>
            <returns>A hash code for this instance.</returns>

</doc>
<doc name="P:PeterO.Mail.Address.LocalPart">

            <summary>Gets the local part of this email address (the part before
            the "@" sign).</summary>
            <value>The local part of this email address (the part before the
            "@" sign).</value>

</doc>
<doc name="M:PeterO.Mail.Address.ToString">

            <summary>Converts this address object to a text string.</summary>
            <returns>A string representation of this object.</returns>

</doc>
<doc name="T:PeterO.Mail.Base64Encoder">

            <summary>This is an internal class.</summary>

</doc>
<doc name="T:PeterO.Mail.ContentDisposition">

            <summary><para>Specifies how a message body should be displayed or handled
            by a mail user agent. This type is immutable; its contents can't be
            changed after it's created. To create a changeable disposition
            object, use the DispositionBuilder class.</para>
            <para><b>About the "filename" parameter</b></para>
            <para>The "filename" parameter of a content disposition suggests a
            name to use when saving data to a file. For the "filename"
            parameter, the GetParameter method and Parameters property(
            <c>getParameters</c> ) method in Java) do not adapt that
            parameter's value using the ContentDisposition.MakeFilename method.
            Thus, for example, the "filename" parameter, if any, returned by
            this method could have an arbitrary length, be encoded using RFC
            2047 encoded words (which some email and HTTP implementations still
            like to write out in headers, even though that RFC says encoded
            words "MUST NOT appear within a 'quoted-string'"; see
            ContentDisposition.MakeFilename), or not be usable as is as a file
            name.</para>
            <para><b>Example:</b> An example of RFC 2047 encoded words
            is:</para>
            <para><b>=?UTF-8?Q?test?=</b></para>
            <para>Content-Disposition header fields like the following have
            appeared in practice:</para>
            <para><b>Content-Disposition: attachment;
            filename==?UTF-8?Q?example?=</b></para>
            <para><b>Content-Disposition: attachment;
            filename==?UTF-8?Q?test.png?=</b></para>
            <para><b>Content-Disposition: attachment;
            filename="=?UTF-8?Q?test.png?="</b></para>
            <para>In this implementation, the first and second of these are
            syntactically invalid, so they trigger parse errors, while the
            third of these is syntactically valid, but the "filename" parameter
            is treated as "=?UTF-8?Q?test.png?=", not "test.png" or something
            else -- RFC 2047 encoded words are not decoded at the moment a
            content disposition is parsed (using the Parse
            method).</para></summary>

</doc>
<doc name="F:PeterO.Mail.ContentDisposition.Attachment">

            <summary>The content disposition value "attachment" .</summary>

</doc>
<doc name="P:PeterO.Mail.ContentDisposition.DispositionType">

            <summary>Gets a string containing this object's disposition type,
            such as "inline" or "attachment". Note that under RFC 6266 sec. 4.2
            and RFC 2183 sec. 2.8, unrecognized disposition types should be
            treated as "attachment". (There is no default content disposition
            in a message has no Content-Disposition header field.). The
            resulting string will be in lowercase; that is, with its basic
            uppercase letters ("A" to "Z") converted to basic lowercase
            letters ("a" to "z").</summary>
            <value>A string containing this object's disposition type, such as
            "inline" or "attachment".</value>

</doc>
<doc name="M:PeterO.Mail.ContentDisposition.Equals(System.Object)">

            <summary>Determines whether this object and another object are
            equal.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns><c>true</c> if the objects are equal; otherwise, <c>false</c>. In this method, two objects are not equal if they
            don't have the same type or if one is null and the other
            isn't.</returns>

</doc>
<doc name="M:PeterO.Mail.ContentDisposition.GetCreationDate">

            <summary>Gets the date and time extracted from this content
            disposition's "creation-date" parameter, which specifies the date
            of creation of a file (RFC 2183 sec. 2.4). The parameter is parsed
            as though by <c>MailDateTime.ParseDateString</c> with obsolete time
            zones (including "GMT") allowed. See that method's documentation
            for information on the format of this method's return
            value.</summary>
            <returns>The extracted date and time as an 8-element array, or
            <c>null</c> if the "creation-date" parameter doesn't exist, is an
            empty string, or is syntactically invalid, or if the parameter's
            year would overflow a 32-bit signed integer.</returns>

</doc>
<doc name="M:PeterO.Mail.ContentDisposition.GetFilename">

            <summary>Gets an adapted version of the "filename" parameter in
            this content disposition object by using the "MakeFilename"
            method.</summary>
            <returns>The adapted file name in the form of a string. Returns the
            empty string if there is no "filename" parameter or that parameter
            is empty.</returns>

</doc>
<doc name="M:PeterO.Mail.ContentDisposition.GetHashCode">

            <summary>Calculates the hash code of this object. The exact
            algorithm used by this method may change between versions of this
            library, and no application or process IDs are used in the hash
            code calculation.</summary>
            <returns>A 32-bit hash code.</returns>

</doc>
<doc name="M:PeterO.Mail.ContentDisposition.GetModificationDate">

            <summary>Gets the date and time extracted from this content
            disposition's "modification-date" parameter, which specifies the
            date of last modification of a file (RFC 2183 sec. 2.5). The
            parameter is parsed as though by
            <c>MailDateTime.ParseDateString</c> with obsolete time zones
            (including "GMT") allowed. See that method's documentation for
            information on the format of this method's return value.</summary>
            <returns>The extracted date and time as an 8-element array, or
            <c>null</c> if the "modification-date" parameter doesn't exist, is
            an empty string, or is syntactically invalid, or if the parameter's
            year would overflow a 32-bit signed integer.</returns>

</doc>
<doc name="M:PeterO.Mail.ContentDisposition.GetParameter(System.String)">

            <summary>Gets a parameter from this disposition object. For the
            "filename" parameter, the value of that parameter is not adapted
            with the ContentDisposition.MakeFilename method; see the
            documentation for the ContentDisposition class.</summary>
            <param name='name'>The name of the parameter to get. The name will
            be matched using a basic case-insensitive comparison. (Two strings
            are equal in such a comparison, if they match after converting the
            basic uppercase letters A to Z (U+0041 to U+005A) in both strings
            to basic lowercase letters.). Can't be null.</param>
            <returns>The value of the parameter, or null if the parameter does
            not exist.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='name'/> is null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='name'/> is empty.</exception>

</doc>
<doc name="M:PeterO.Mail.ContentDisposition.GetReadDate">

            <summary>Gets the date and time extracted from this content
            disposition's "read-date" parameter, which specifies the date at
            which a file was last read (RFC 2183 sec. 2.6). The parameter is
            parsed as though by <c>MailDateTime.ParseDateString</c> with
            obsolete time zones (including "GMT") allowed. See that method's
            documentation for information on the format of this method's return
            value.</summary>
            <returns>The extracted date and time as an 8-element array, or
            <c>null</c> if the "read-date" parameter doesn't exist, is an empty
            string, or is syntactically invalid, or if the parameter's year
            would overflow a 32-bit signed integer.</returns>

</doc>
<doc name="F:PeterO.Mail.ContentDisposition.Inline">

            <summary>The content disposition value "inline" .</summary>

</doc>
<doc name="P:PeterO.Mail.ContentDisposition.IsAttachment">

            <summary>Gets a value indicating whether the disposition type is
            attachment.</summary>
            <value><c>true</c> If the disposition type is attachment; otherwise, <c>false</c>.</value>

</doc>
<doc name="P:PeterO.Mail.ContentDisposition.IsInline">

            <summary>Gets a value indicating whether the disposition type is
            inline.</summary>
            <value><c>true</c> If the disposition type is inline; otherwise, <c>false</c>.</value>

</doc>
<doc name="M:PeterO.Mail.ContentDisposition.MakeFilename(System.String)">

            <summary>Converts a file name from the Content-disposition header
            field (or another string representing a title and an optional file
            extension) to a suitable name for saving data to a file. This
            method is idempotent; that is, calling the method again on the
            result doesn't change that result. The method avoids characters and
            combinations of characters that are problematic to use in certain
            file systems, and leaves the vast majority of file names seen in
            practice untouched.
            <para>Examples of how this method works follows:</para>
            <para><c>"=?utf-8?q?hello=2Etxt?=" -&gt;"hello.txt"</c> (RFC 2047
            encoding).</para>
            <para><c>"=?utf-8?q?long_filename?=" -&gt;"long filename"</c> (RFC
            2047 encoding).</para>
            <para><c>"utf-8'en'hello%2Etxt" -&gt;"hello.txt"</c> (RFC 2231
            encoding).</para>
            <para><c>"nul.txt" -&gt;"_nul.txt"</c> (Reserved name).</para>
            <para><c>"dir1/dir2/file" -&gt;"dir1_dir2_file"</c> (Directory
            separators).</para></summary>
            <param name='str'>A string representing a file name. Can be
            null.</param>
            <returns>A string with the converted version of the file name.
            Among other things, encoded words under RFC 2047 are decoded (since
            they occur so frequently in Content-Disposition filenames); the
            value is decoded under RFC 2231 if possible; characters unsuitable
            for use in a filename (including the directory separators slash and
            backslash) are replaced with underscores; spaces and tabs are
            collapsed to a single space; leading and trailing spaces and tabs
            are removed; and the filename is truncated if it would otherwise be
            too long. Also, for reasons stated in the remarks, a character that
            is the combined form of a base character and a combining slash is
            replaced with "!" followed by the base character. The returned
            string will be in normalization form C. Returns the empty string if
            <paramref name='str'/> is null or empty.</returns>
            <remarks>
            <para><b>Remarks:</b></para>
            <list>
            <item>This method should be used only to prepare a file name for
            the purpose of suggesting a name by which to save data. It should
            not be used to prepare file names of existing files for the purpose
            of reading them, since this method may replace certain characters
            with other characters in some cases, such that two different inputs
            may map to the same output.</item>
            <item><b>File Name Support.</b> For recommendations on file name
            support, see "
            <a href='https://peteroupc.github.io/filenames.html'>File Name
            Support in Applications</a> ".</item>
            <item><b>Guarantees.</b> The exact file name conversion used by
            this method is not guaranteed to remain the same between versions
            of this library, with the exception that the return value will be
            in normalization form C, will not contain base + slash code points,
            will not be null, and will be an empty string only if <paramref name='str'/> is null or empty.</item>
            <item><para><b>'Name' and 'Filename' Parameters.</b> Email and HTTP
            headers may specify suggested filenames using the
            Content-Disposition header field's <c>filename</c> parameter or, in
            practice, the Content-Type header field's <c>name</c> parameter.</para>
            <para>Although RFC 2047 encoded words appearing in both parameters
            are written out by some implementations, this practice is often
            discouraged (especially since the RFC itself says that encoded
            words "MUST NOT appear within a 'quoted-string'"). Nevertheless,
            the MakeFilename method has a basis in the RFCs to decode RFC 2047
            encoded words (and RFC 2231 encoding) in file names passed to this
            method.</para>
            <para>RFC 2046 sec. 4.5.1 ( <c>application/octet-stream</c> subtype
            in Content-Type header field) cites an earlier RFC 1341, which
            "defined the use of a 'NAME' parameter which gave a
            <i>suggested</i> file name to be used if the data were written to a
            file". Also, RFC 2183 sec. 2.3 ( <c>filename</c> parameter in
            Content-Disposition) confirms that the "
            <i>suggested</i> filename" in the <c>filename</c> parameter "should
            be
            <i>used as a basis</i> for the actual filename, where possible",
            and that that file name should "not [be] blindly use[d]". See also
            RFC 6266, section 4.3, which discusses the use of that parameter in
            Hypertext Transfer Protocol (HTTP).</para>
            <para>To the extent that the "name" parameter is not allowed in
            message bodies other than those with the media type
            "application/octet-stream" or treated as that media-type, this is a
            deviation of RFC 2045 and 2046 (see also RFC 2045 sec. 5, which
            says that "[t]here are NO globally meaningful parameters that apply
            to all media types"). (Some email implementations may still write
            out the "name" parameter, even for media types other than
            <c>application/octet-stream</c> and even though RFC 2046 has
            deprecated that parameter.)</para></item></list>.</remarks>

</doc>
<doc name="P:PeterO.Mail.ContentDisposition.Parameters">

            <summary>Gets a list of parameter names associated with this object
            and their values. Each parameter name will be in lowercase; that
            is, with its basic uppercase letters ("A" to "Z") converted to
            basic lowercase letters ("a" to "z").
            <para>For the "filename" parameter, the value of that parameter is
            not adapted with the ContentDisposition.MakeFilename method; see
            the documentation for the ContentDisposition
            class.</para></summary>
            <value>A read-only list of parameter names associated with this
            object and their values. NOTE: Previous versions erroneously stated
            that the list will be sorted by name. In fact, the names will not
            be guaranteed to appear in any particular order; this is at least
            the case in version 0.10.0.</value>

</doc>
<doc name="M:PeterO.Mail.ContentDisposition.Parse(System.String)">

            <summary>Creates a new content disposition object from the value of
            a Content-Disposition header field.</summary>
            <param name='dispoValue'>The parameter <paramref name='dispoValue'/> is a text string.</param>
            <returns>A content disposition object, or
            ContentDisposition.Attachment" if <paramref name='dispoValue'/> is
            empty or syntactically invalid.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='dispoValue'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.ContentDisposition.Parse(System.String,PeterO.Mail.ContentDisposition)">

            <summary>Parses a content disposition string and returns a content
            disposition object, or the default value if the string is invalid.
            This method checks the syntactic validity of the string, but not
            whether it has all parameters it's required to have or whether the
            parameters themselves are set to valid values for the parameter.
            <para>This method assumes the given content disposition string was
            directly extracted from the Content-Disposition header field (as
            defined for email messages) and follows the syntax given in RFC
            2183. Accordingly, among other things, the content disposition
            string can contain comments (delimited by parentheses).</para>
            <para>RFC 2231 extensions allow each content disposition parameter
            to be associated with a character encoding and/or language, and
            support parameter values that span two or more key-value pairs.
            Parameters making use of RFC 2231 extensions have names with an
            asterisk ("*"). Such a parameter will be ignored if it is
            ill-formed because of RFC 2231's rules (except for illegal
            percent-decoding or undecodable sequences for the given character
            encoding). Examples of RFC 2231 extensions follow (both examples
            encode the same "filename" parameter):</para>
            <para><b>inline; filename*=utf-8'en'filename.txt</b></para>
            <para><b>inline; filename*0*=utf-8'en'file;
            filename*1*=name%2Etxt</b></para>
            <para>This implementation ignores keys (in parameter key-value
            pairs) that appear more than once in the content disposition.
            Nothing in RFCs 2045, 2183, 2231, 6266, or 7231 explicitly
            disallows such keys, or otherwise specifies error-handling behavior
            for such keys.</para></summary>
            <param name='dispositionValue'>A text string that should be the
            value of a Content-Disposition header field.</param>
            <param name='defaultValue'>The value to return in case the
            disposition value is syntactically invalid. Can be null.</param>
            <returns>A ContentDisposition object.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='dispositionValue'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.ContentDisposition.ToSingleLineString">

            <summary>Converts this content disposition to a text string form
            suitable for inserting in HTTP headers. Notably, the string
            contains the value of a Content-Disposition header field (without
            the text necessarily starting with "Content-Disposition" followed
            by a space), and consists of a single line.</summary>
            <returns>A text string form of this content disposition.</returns>

</doc>
<doc name="M:PeterO.Mail.ContentDisposition.ToString">

            <summary>Converts this content disposition to a text string form
            suitable for inserting in email headers. Notably, the string
            contains the value of a Content-Disposition header field (without
            the text necessarily starting with "Content-Disposition" followed
            by a space), and consists of one or more lines.</summary>
            <returns>A text string form of this content disposition.</returns>

</doc>
<doc name="T:PeterO.Mail.DataUris">

            <summary>Contains methods for parsing and generating Data URIs
            (uniform resource identifiers). Data URIs are described
            in RFC 2397. Examples for Data URIs follow.
            <code>data:, hello%20world</code> <code>data:text/markdown, hello%20world</code> <code>data:application/octet-stream;base64, AAAAAA==</code> .
            </summary>

</doc>
<doc name="M:PeterO.Mail.DataUris.DataUriBytes(System.String)">

            <summary>Extracts the data from a Data URI (uniform resource
            identifier) in the form of a byte array.</summary>
            <param name='uri'>The parameter <paramref name='uri'/> is a text
            string.</param>
            <returns>The data as a byte array. Returns null if <paramref name='uri'/> is null, is syntactically invalid, or is not a data
            URI.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='uri'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.DataUris.DataUriBytes(System.Uri)">

            <summary>Extracts the data from a Data URI (uniform resource
            identifier) in the form of a byte array, where the Data URI is
            given as a URI object.</summary>
            <param name='uri'>The Data URI in the form of a URI object.</param>
            <returns>The data as a byte array. Returns null if <paramref name='uri'/> is null, is syntactically invalid, or is not a data
            URI.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='uri'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.DataUris.DataUriMediaType(System.String)">

            <summary>Extracts the media type from a Data URI (uniform resource
            identifier) in the form of a text string.</summary>
            <param name='uri'>A data URI in the form of a text string.</param>
            <returns>The media type. Returns null if <paramref name='uri'/> is
            null, is syntactically invalid, or is not a Data URI.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='uri'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.DataUris.DataUriMediaType(System.Uri)">

            <summary>Extracts the media type from a Data URI (uniform resource
            identifier) in the form of a URI object.</summary>
            <param name='uri'>A data URI in the form of a URI object.</param>
            <returns>The media type. Returns null if <paramref name='uri'/> is
            null, is syntactically invalid, or is not a Data URI.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='uri'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.DataUris.MakeDataUri(System.Byte[],PeterO.Mail.MediaType)">

            <summary>Encodes data with the given media type in a Data URI
            (uniform resource identifier).</summary>
            <param name='bytes'>A byte array containing the data to encode in a
            Data URI.</param>
            <param name='mediaType'>A media type to assign to the data.</param>
            <returns>A Data URI that encodes the given data and media
            type.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bytes'/> or <paramref name='mediaType'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.DataUris.MakeDataUri(System.String)">

            <summary>Encodes text as a Data URI (uniform resource
            identifier).</summary>
            <param name='textString'>A text string to encode as a data
            URI.</param>
            <returns>A Data URI that encodes the given text.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='textString'/> is null.</exception>

</doc>
<doc name="T:PeterO.Mail.DataUrls">

            <summary>Contains methods for parsing and generating Data URIs
            (uniform resource identifiers). Data URIs are described
            in RFC 2397. Examples for Data URIs follow.
            <code>data:, hello%20world</code> <code>data:text/markdown, hello%20world</code> <code>data:application/octet-stream;base64, AAAAAA==</code> .
            </summary>

</doc>
<doc name="M:PeterO.Mail.DataUrls.DataUrlBytes(System.String)">

            <summary>Extracts the data from a Data URI (uniform resource
            identifier) in the form of a byte array.</summary>
            <param name='url'>A data URI.</param>
            <returns>The data as a byte array. Returns null if <paramref name='url'/> is null, is syntactically invalid, or is not a data
            URI.</returns>

</doc>
<doc name="M:PeterO.Mail.DataUrls.DataUrlMediaType(System.String)">

            <summary>Extracts the media type from a Data URI (uniform resource
            identifier).</summary>
            <param name='url'>A data URI.</param>
            <returns>The media type. Returns null if <paramref name='url'/> is
            null, is syntactically invalid, or is not a Data URI.</returns>

</doc>
<doc name="M:PeterO.Mail.DataUrls.MakeDataUrl(System.Byte[],PeterO.Mail.MediaType)">

            <summary>Encodes data with the given media type in a Data URI
            (uniform resource identifier).</summary>
            <param name='bytes'>A byte array containing the data to encode in a
            Data URI.</param>
            <param name='mediaType'>A media type to assign to the data.</param>
            <returns>A Data URI that encodes the given data and media
            type.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bytes'/> or <paramref name='mediaType'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.DataUrls.MakeDataUrl(System.String)">

            <summary>Encodes text as a Data URI (uniform resource
            identifier).</summary>
            <param name='textString'>A text string to encode as a data
            URI.</param>
            <returns>A Data URI that encodes the given text.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='textString'/> is null.</exception>

</doc>
<doc name="T:PeterO.Mail.DispositionBuilder">

            <summary>A mutable data type that allows a content disposition to
            be built.</summary>

</doc>
<doc name="M:PeterO.Mail.DispositionBuilder.#ctor">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.DispositionBuilder'/> class using the
            disposition type "attachment" .</summary>

</doc>
<doc name="M:PeterO.Mail.DispositionBuilder.#ctor(PeterO.Mail.ContentDisposition)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.DispositionBuilder'/> class using the data
            from the given content disposition.</summary>
            <param name='mt'>The parameter <paramref name='mt'/> is a
            ContentDisposition object.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='mt'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.DispositionBuilder.#ctor(System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.DispositionBuilder'/> class using the given
            disposition type.</summary>
            <param name='type'>The parameter <paramref name='type'/> is a text
            string.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='type'/> is null.</exception>
            <exception cref='ArgumentException'>Type is empty.</exception>

</doc>
<doc name="P:PeterO.Mail.DispositionBuilder.DispositionType">

            <summary>Gets or sets this value's disposition type, such as
            "inline" or "attachment".</summary>
            <value>This value's disposition type, such as "inline" or
            "attachment" .</value>
            <exception cref='ArgumentNullException'>The property is being set
            and the value is null.</exception>
            <exception cref='ArgumentException'>The property is being set and
            the value is an empty string.</exception>

</doc>
<doc name="P:PeterO.Mail.DispositionBuilder.IsMultipart">

            <summary>Gets a value indicating whether this is a multipart media
            type.</summary>
            <value><c>true</c> If this is a multipart media type; otherwise, <c>false</c>.</value>

</doc>
<doc name="P:PeterO.Mail.DispositionBuilder.IsText">

            <summary>Gets a value indicating whether this is a text media
            type.</summary>
            <value><c>true</c> If this is a text media type; otherwise, <c>false</c>.</value>

</doc>
<doc name="M:PeterO.Mail.DispositionBuilder.RemoveParameter(System.String)">

            <summary>Removes a parameter from this content disposition. Does
            nothing if the parameter's name doesn't exist.</summary>
            <param name='name'>The parameter to remove. The name is compared
            using a basic case-insensitive comparison. (Two strings are equal
            in such a comparison, if they match after converting the basic
            uppercase letters A to Z (U+0041 to U+005A) in both strings to
            basic lowercase letters.).</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='name'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.DispositionBuilder.SetDispositionType(System.String)">

            <summary>Sets the disposition type, such as "inline". This method
            enables the pattern of method chaining (for example, <c>new
            ...().Set...().Set...()</c> ) unlike with the DispositionType
            property in .NET or the setDispositionType method (with small s) in
            Java.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
            <exception cref='ArgumentException'>Str is empty.</exception>

</doc>
<doc name="M:PeterO.Mail.DispositionBuilder.SetParameter(System.String,System.String)">

            <summary>Sets a parameter of this content disposition.</summary>
            <param name='name'>Name of the parameter to set. If this name
            already exists (compared using a basic case-insensitive
            comparison), it will be overwritten. (Two strings are equal in a
            basic case-insensitive comparison, if they match after converting
            the basic uppercase letters A to Z (U+0041 to U+005A) in both
            strings to basic lowercase letters.).</param>
            <param name='value'>Value of the parameter to set.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentNullException'>Either <paramref name='value'/> or <paramref name='name'/> is null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='name'/> is empty, or it isn't a well-formed parameter
            name.</exception>

</doc>
<doc name="M:PeterO.Mail.DispositionBuilder.ToDisposition">

            <summary>Converts this object to an immutable ContentDisposition
            object.</summary>
            <returns>A MediaType object.</returns>

</doc>
<doc name="M:PeterO.Mail.DispositionBuilder.ToString">

            <summary>Converts this object to a text string.</summary>
            <returns>A string representation of this object.</returns>

</doc>
<doc name="T:PeterO.Mail.EncodedWordContext">

            <summary>Specifies the context where an encoded word under RFC 2047
            can appear.</summary>

</doc>
<doc name="F:PeterO.Mail.EncodedWordContext.Comment">

            <summary>Contains methods for parsing and matching language
            tags.</summary>

</doc>
<doc name="F:PeterO.Mail.EncodedWordContext.Phrase">

            <summary>In a "word" element within a "phrase" of a structured
            header field.</summary>

</doc>
<doc name="F:PeterO.Mail.EncodedWordContext.Unstructured">

            <summary>In an unstructured header field's value.</summary>

</doc>
<doc name="T:PeterO.Mail.EnrichedText">

            <summary>This is an internal API.</summary>

</doc>
<doc name="T:PeterO.Mail.IdentityEncoder">

            <summary>This is an internal API.</summary>

</doc>
<doc name="T:PeterO.Mail.LanguageTags">

            <summary>Contains methods for parsing and matching language
            tags.</summary>

</doc>
<doc name="M:PeterO.Mail.LanguageTags.GetLanguageList(System.String)">

            <summary>Parses a language list from a Content-Language header
            field.</summary>
            <param name='str'>A string following the syntax of a
            Content-Language header field (see RFC 3282). This is a
            comma-separated list of language tags. RFC 5322 comments (in
            parentheses) can appear. This parameter can be null.</param>
            <returns>A list of language tags. Returns an empty list if
            <paramref name='str'/> is null or the empty string, or null if
            <paramref name='str'/> syntactically invalid.</returns>

</doc>
<doc name="M:PeterO.Mail.LanguageTags.GetRangeListWithQuality(System.String)">

            <summary>Parses a language range list from an Accept-Language
            header field.</summary>
            <param name='str'>A string following the syntax of an
            Accept-Language header field (see RFC 3282). This is a
            comma-separated list of language ranges, with an optional "quality"
            after the language tag (examples include "en; q=0.5" or "de-DE").
            RFC 5322 comments (in parentheses) can appear. This parameter can
            be null.</param>
            <returns>A list of language ranges with their associated qualities.
            The list will be sorted in descending order by quality; if two or
            more language ranges have the same quality, they will be sorted in
            the order in which they appeared in the given string. Returns null
            if <paramref name='str'/> is null or syntactically
            invalid.</returns>

</doc>
<doc name="M:PeterO.Mail.LanguageTags.IsLanguageRange(System.String)">

            <summary>Returns whether the given string is a basic language range
            under RFC 4647. Examples include "*", "en-us", and "fr".</summary>
            <param name='str'>The string to check. Can be null.</param>
            <returns><c>true</c> if the given string is a basic language range; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Mail.LanguageTags.IsLanguageRange(System.String,System.Boolean)">

            <summary>Returns whether the given string is a basic or extended
            language range under RFC 4647. Examples of basic (and extended)
            language ranges include "*", "en-us", and "fr". Examples of
            extended language ranges include "*-de" and "it-*".</summary>
            <param name='str'>The string to check. Can be null.</param>
            <param name='extended'>Check whether the string is a basic language
            range if "false", or an extended language range if "true".</param>
            <returns><c>true</c> if the given string is a basic language range
            (depending on the <paramref name='extended'/> parameter); otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Mail.LanguageTags.IsPotentiallyValidLanguageTag(System.String)">

            <summary>Returns true if (1) the given string is a well-formed
            language tag under RFC 5646 (that is, the string follows the syntax
            given in section 2.1 of that RFC), and (2) the language tag
            contains at most one extended language subtag, no variant subtags
            with the same value, and no extension singleton subtags with the
            same value.</summary>
            <param name='str'>The string to check.</param>
            <returns><c>true</c>, if the string meets the conditions given in
            the summary, <c>false</c> otherwise.</returns>

</doc>
<doc name="M:PeterO.Mail.LanguageTags.LanguageTagCase(System.String)">

            <summary>Sets the given language tag to the case combination
            recommended by RFC 5646. For example, "en-us" becomes "en-US", and
            "zh-hant" becomes "zh-Hant".</summary>
            <param name='str'>A string of a language tag. Can be null.</param>
            <returns>A text string in the recommended case combination, or null
            if <paramref name='str'/> is null.</returns>

</doc>
<doc name="M:PeterO.Mail.LanguageTags.LanguageTagFilter(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String})">

            <summary>Finds the language tags that match a priority list of
            basic language ranges.</summary>
            <param name='ranges'>A list of basic language ranges (see
            documentation for the "IsLanguageRange" method), which should be
            given in order of descending preference.</param>
            <param name='languages'>A list of language tags, which should be
            given in order of descending preference.</param>
            <returns>A list of language tags that match the given range, in
            descending order of preference.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='languages'/> or <paramref name='ranges'/> is
            null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='ranges'/> contains a value that is not a basic language
            range, or <paramref name='languages'/> contains a value that is not
            a potentially valid language tag.</exception>

</doc>
<doc name="M:PeterO.Mail.LanguageTags.LanguageTagFilter(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.Boolean,System.Boolean)">

            <summary>Finds the language tags that match a priority list of
            language ranges.</summary>
            <param name='ranges'>A list of language ranges (see documentation
            for the "IsLanguageRange" method), which should be given in order
            of descending preference.</param>
            <param name='languages'>A list of language tags, which should be
            given in order of descending preference.</param>
            <param name='extended'>If true, the ranges in "ranges" are extended
            language ranges; otherwise, they are basic language ranges.</param>
            <param name='matchStarAtEnd'>If true, treats any range equaling "*"
            as appearing at the end of the language priority list, no matter
            where it appears on that list.</param>
            <returns>A list of language tags that match the given range, in
            descending order of preference.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='languages'/> or <paramref name='ranges'/> is
            null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='ranges'/> contains a value that is not a basic or extended
            language range, or <paramref name='languages'/> contains a value
            that is not a potentially valid language tag.</exception>

</doc>
<doc name="M:PeterO.Mail.LanguageTags.LanguageTagLookup(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.String)">

            <summary>Does a language tag lookup (under RFC 4647) for a matching
            language tag.</summary>
            <param name='ranges'>A list of basic language ranges (see
            documentation for the "IsLanguageRange" method), which should be
            given in order of descending preference.</param>
            <param name='languages'>A list of language tags, which should be
            given in order of descending preference.</param>
            <param name='defaultValue'>The value to return if no matching
            language tag was found.</param>
            <returns>The matching language tag, or the parameter <paramref name='defaultValue'/> if there is no matching language
            tag.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='languages'/> or <paramref name='ranges'/> is
            null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='ranges'/> contains a value that is not a basic language
            range, or <paramref name='languages'/> contains a value that is not
            a potentially valid language tag.</exception>

</doc>
<doc name="M:PeterO.Mail.LanguageTags.LanguageTagLookup(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.String,System.Boolean)">

            <summary>Does a language tag lookup (under RFC 4647) for a matching
            language tag.</summary>
            <param name='ranges'>A list of language ranges (see documentation
            for the "IsLanguageRange" method), which should be given in order
            of descending preference.</param>
            <param name='languages'>A list of language tags, which should be
            given in order of descending preference.</param>
            <param name='defaultValue'>The value to return if no matching
            language tag was found.</param>
            <param name='extended'>If true, the ranges in "ranges" are extended
            language ranges; otherwise, they are basic language ranges.</param>
            <returns>The matching language tag, or the parameter <paramref name='defaultValue'/> if there is no matching language
            tag.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='languages'/> or <paramref name='ranges'/> is
            null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='ranges'/> contains a value that is not a basic or extended
            language range, or <paramref name='languages'/> contains a value
            that is not a potentially valid language tag.</exception>

</doc>
<doc name="M:PeterO.Mail.LanguageTags.LanguageTagLookup(System.String,System.Collections.Generic.IList{System.String},System.String)">

            <summary>Does a language tag lookup (under RFC 4647) for a matching
            language tag.</summary>
            <param name='range'>A basic language range (see the documentation
            for "IsLanguageRange").</param>
            <param name='languages'>A list of language tags, which should be
            given in order of descending preference.</param>
            <param name='defaultValue'>The value to return if no matching
            language tag was found.</param>
            <returns>The matching language tag, or the parameter <paramref name='defaultValue'/> if there is no matching language
            tag.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='languages'/> is null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='range'/> is not a basic language range, or <paramref name='languages'/> contains a value that is not a potentially valid
            language tag.</exception>

</doc>
<doc name="M:PeterO.Mail.LanguageTags.LanguageTagLookup(System.String,System.Collections.Generic.IList{System.String},System.String,System.Boolean)">

            <summary>Does a language tag lookup (under RFC 4647) for a matching
            language tag.</summary>
            <param name='range'>A language range (see the documentation for
            "IsLanguageRange").</param>
            <param name='languages'>A list of language tags, which should be
            given in order of descending preference.</param>
            <param name='defaultValue'>The value to return if no matching
            language tag was found.</param>
            <param name='extended'>If true, "range" is an extended language
            range; otherwise, it's a are basic language range.</param>
            <returns>The matching language tag, or the parameter <paramref name='defaultValue'/> if there is no matching language
            tag.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='languages'/> is null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='range'/> is not a basic or extended language range, or
            <paramref name='languages'/> contains a value that is not a
            potentially valid language tag.</exception>

</doc>
<doc name="M:PeterO.Mail.LanguageTags.MatchesLanguageTag(System.String,System.String)">

            <summary>Determines whether the given language tag matches the
            given language range.</summary>
            <param name='range'>A basic language range (see the documentation
            for "IsLanguageRange").</param>
            <param name='tag'>A language tag.</param>
            <returns><c>true</c> if the language tag matches the language range
            by the filtering method under RFC 4647; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='range'/> is not a basic language range, or <paramref name='tag'/> is not a potentially valid language tag.</exception>

</doc>
<doc name="T:PeterO.Mail.MailDateTime">

            <summary>Contains methods for parsing and generating date-time
            strings following the Internet Message Format (RFC 5322).</summary>

</doc>
<doc name="M:PeterO.Mail.MailDateTime.GenerateDateString(System.Int32[])">

            <summary>Generates a date-time string following the Internet
            Message Format (RFC 5322) from an 8-element array.</summary>
            <param name='dateTime'>The date and time in the form of an
            8-element array. See <c>ParseDateString(string, bool)</c> for
            information on the format of this parameter.</param>
            <returns>A date-time string.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='dateTime'/> is null or invalid (see
            <c>ParseDateString(string, bool)</c> ).</exception>

</doc>
<doc name="M:PeterO.Mail.MailDateTime.GenerateDateString(System.Int32[],System.Boolean)">

            <summary>Generates a date-time string following the Internet
            Message Format (RFC 5322) from an 8-element array.</summary>
            <param name='dateTime'>The date and time in the form of an
            8-element array. See <c>ParseDateString(string, bool)</c> for
            information on the format of this parameter.</param>
            <param name='gmt'>If true, uses the string "GMT" as the time zone
            offset.</param>
            <returns>A date-time string.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='dateTime'/> is null or invalid (see
            <c>ParseDateString(string, bool)</c> ).</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='dateTime'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.MailDateTime.ParseDateString(System.String)">

            <summary>Gets the date and time extracted from a date-time string
            following the Internet Message Format (RFC 5322). Obsolete time
            zone strings are not allowed to appear in the date-time string. See
            <c>ParseDateString(string, bool)</c> for information on this
            method's return value.</summary>
            <param name='str'>A date-time string.</param>
            <returns>An 8-element array containing the date and time, or
            <c>null</c> if <paramref name='str'/> is null, empty, or
            syntactically invalid, or if the string's year would overflow the
            range of a 32-bit signed integer.</returns>

</doc>
<doc name="M:PeterO.Mail.MailDateTime.ParseDateString(System.String,System.Boolean)">

            <summary>Gets the date and time extracted from a date-time string
            following the Internet Message Format (RFC 5322), with an option to
            allow obsolete time zone strings to appear in the date-time string.
            If an array is returned, the elements of that array (starting from
            0) are as follows:
            <list>
            <item>0 - The year. For example, the value 2000 means 2000 C.E.
            This value cannot be less than 1900 (a restriction specified by RFC
            5322).</item>
            <item>1 - Month of the year, from 1 (January) through 12
            (December).</item>
            <item>2 - Day of the month, from 1 through 31.</item>
            <item>3 - Hour of the day, from 0 through 23.</item>
            <item>4 - Minute of the hour, from 0 through 59.</item>
            <item>5 - Second of the minute, from 0 through 59, except this
            value can be 60 if the hour of the day is 23 and the minute of the
            hour is 59, to accommodate leap seconds. (Leap seconds are
            additional seconds added to adjust international atomic time, or
            TAI, to an approximation of astronomical time known as coordinated
            universal time, or UTC.)</item>
            <item>6 - Fractional seconds. The return value will always have
            this value set to 0, since fractional seconds cannot be expressed
            in the date-time format specified by RFC 5322. This value cannot be
            less than 0.</item>
            <item>7 - Number of minutes to subtract from this date and time to
            get global time. This number can be positive or negative, but
            cannot be less than -1439 or greater than 1439.</item></list>
            <para>If a method or property uses an array of this format and
            refers to this method's documentation, that array may have any
            number of elements 8 or greater.</para></summary>
            <param name='str'>A date-time string.</param>
            <param name='parseObsoleteZones'>If set to <c>true</c>, this
            method allows obsolete time zones (single-letter time zones, "GMT",
            "UT", and certain three-letter combinations) to appear in the
            date-time string.</param>
            <returns>An 8-element array containing the date and time, or
            <c>null</c> if <paramref name='str'/> is null, empty, or
            syntactically invalid, or if the string's year would overflow the
            range of a 32-bit signed integer.</returns>

</doc>
<doc name="M:PeterO.Mail.MailDateTime.ParseDateStringHttp(System.String)">

            <summary>Parses a date string in one of the three formats allowed
            by HTTP/1.1 (RFC 7231).</summary>
            <param name='v'>A date-time string.</param>
            <returns>An array of 8 elements as specified in the
            <c>ParseDateString(string, bool)</c> method.</returns>

</doc>
<doc name="T:PeterO.Mail.MediaType">

            <summary><para>Specifies what kind of data a message body is.</para>
            <para>A media type consists of a top-level type (the general
            category of the data), a subtype (the specific type), and an
            optional list of parameters. For example, the media type
            <c>text/plain;charset=utf-8</c> is a text media type ("text"),
            namely, a plain text type ("plain"), and the parameters say that
            the data uses UTF-8, a Unicode character encoding ("charset =
            utf-8"). Other top-level types include "audio", "video", and
            "application".</para>
            <para>A media type is sometimes known as a "MIME type", for
            Multipurpose Internet Mail Extensions, the standard that introduced
            media types.</para>
            <para>This type is immutable, meaning its values can't be changed
            once it's created. To create a changeable media type object, use
            the MediaTypeBuilder class.</para>
            <para><b>Note:</b> According to RFC 2049, unrecognized subtypes of
            the top-level type <c>multipart</c> must be treated as
            <c>multipart/mixed</c> and unrecognized media types as the media
            type <c>application/octet-stream</c>.</para></summary>

</doc>
<doc name="F:PeterO.Mail.MediaType.ApplicationOctetStream">

            <summary>Specifies the media type "application/octet-stream", used
            for arbitrary binary data.</summary>

</doc>
<doc name="M:PeterO.Mail.MediaType.Equals(System.Object)">

            <summary>Determines whether this object and another object are
            equal.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns><c>true</c> if this object and the other object are equal; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Mail.MediaType.GetCharset">

            <summary>Gets this media type's "charset" parameter, naming a
            character encoding used to represent text in the data that uses
            this media type.</summary>
            <returns>If the "charset" parameter is present and nonempty,
            returns the result of the Encodings.ResolveAliasForEmail method for
            that parameter, except that the result's basic uppercase letters A
            to Z (U+0041 to U+005A) are converted to lowercase. If the
            "charset" parameter is empty, returns the empty string. If the
            "charset" parameter is absent, returns the default value, if any,
            for that parameter given the media type (for example, "us-ascii" if the
            media type is "text/plain"; see RFC2046), or the empty string if
            there is none.</returns>

</doc>
<doc name="M:PeterO.Mail.MediaType.GetHashCode">

            <summary>Calculates the hash code of this object. The exact
            algorithm used by this method may change between versions of this
            library, and no application or process IDs are used in the hash
            code calculation.</summary>
            <returns>A 32-bit signed integer.</returns>

</doc>
<doc name="M:PeterO.Mail.MediaType.GetParameter(System.String)">

            <summary>Gets the value of a parameter in this media type, such as
            "charset" or "format".</summary>
            <param name='name'>Name of the parameter to get. The name is
            compared using a basic case-insensitive comparison. (Two strings
            are equal in such a comparison, if they match after converting the
            basic uppercase letters A to Z (U+0041 to U+005A) in both strings
            to basic lowercase letters.).</param>
            <returns>The value of the parameter as a string, or null if the
            parameter doesn't exist.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='name'/> is null.</exception>
            <exception cref='ArgumentException'>Name is empty.</exception>

</doc>
<doc name="M:PeterO.Mail.MediaType.HasStructuredSuffix(System.String)">

            <summary>Returns whether this media type's subtype has the given
            structured syntax suffix.</summary>
            <param name='suffix'>A text string identifying a structured syntax
            suffix without the starting "+". Examples include "xml" and "json".
            The suffix is compared to the end of the media type's subtype using
            a basic case-insensitive comparison. (Two strings are equal in such
            a comparison, if they match after converting the basic uppercase
            letters A to Z (U+0041 to U+005A) in both strings to basic
            lowercase letters.).</param>
            <returns><c>true</c> if the media type's subtype ends with, but does not
            consist of, "+" followed by the <paramref name='suffix'/> parameter
            (using a basic case-insensitive comparison); otherwise, <c>false</c>. For example, returns false if <paramref name='suffix'/> is "xml" and the subtype is "+xml", but returns
            true if <paramref name='suffix'/> is "xml" and the subtype is
            "example+xml". Returns false if <paramref name='suffix'/> is null
            or an empty string.</returns>

</doc>
<doc name="P:PeterO.Mail.MediaType.IsMultipart">

            <summary>Gets a value indicating whether this is a multipart media
            type.</summary>
            <value><c>true</c> If this is a multipart media type; otherwise, <c>false</c>.</value>

</doc>
<doc name="P:PeterO.Mail.MediaType.IsText">

            <summary>Gets a value indicating whether this is a text media type
            ("text/*").</summary>
            <value><c>true</c> If this is a text media type; otherwise, <c>false</c>.</value>

</doc>
<doc name="F:PeterO.Mail.MediaType.MessageRfc822">

            <summary>Specifies the media type "message/rfc822", used for
            Internet mail messages.</summary>

</doc>
<doc name="P:PeterO.Mail.MediaType.Parameters">

            <summary>Gets a list of the parameter names contained in this media
            type object and their values. Each parameter name will be in lowercase; that is, with its basic uppercase letters ("A" to "Z")
            converted to basic lowercase letters ("a" to "z").</summary>
            <value>A list of the parameters contained in this media type
            object; the names of each parameter appear in an undefined order.
            NOTE: Previous versions erroneously stated that the list will be
            sorted by name. In fact, the names will not be guaranteed to appear
            in any particular order; this is at least the case in version
            0.10.0.</value>

</doc>
<doc name="M:PeterO.Mail.MediaType.Parse(System.String)">

            <summary>Parses a media type string and returns a media type
            object. For further information, see the overload taking a
            MediaType parameter.</summary>
            <param name='mediaTypeValue'>A text string representing a media
            type. This media type can include parameters.</param>
            <returns>A media type object, or MediaType.TextPlainAscii if
            <paramref name='mediaTypeValue'/> is empty or syntactically
            invalid.</returns>

</doc>
<doc name="M:PeterO.Mail.MediaType.Parse(System.String,PeterO.Mail.MediaType)">

            <summary>Parses a media type string and returns a media type
            object, or the default value if the string is invalid. This method
            checks the syntactic validity of the string, but not whether it has
            all parameters it's required to have or whether the parameters
            themselves are set to valid values for the parameter.
            <para>This method assumes the given media type string was directly
            extracted from the Content-Type header field (as defined for email
            messages) and follows the syntax given in RFC 2045. Accordingly,
            among other things, the media type string can contain comments
            (delimited by parentheses).</para>
            <para>RFC 2231 extensions allow each media type parameter to be
            associated with a character encoding and/or language, and support
            parameter values that span two or more key-value pairs. Parameters
            making use of RFC 2231 extensions have names with an asterisk
            ("*"). Such a parameter will be ignored if it is ill-formed because
            of RFC 2231's rules (except for illegal percent-decoding or
            undecodable sequences for the given character encoding). Examples
            of RFC 2231 extensions follow (both examples encode the same
            "filename" parameter):</para>
            <para><b>text/example; filename*=utf-8'en'filename.txt</b></para>
            <para><b>text/example; filename*0*=utf-8'en'file;
            filename*1*=name%2Etxt</b></para>
            <para>This implementation ignores keys (in parameter key-value
            pairs) that appear more than once in the media type. Nothing in
            RFCs 2045, 2183, 2231, 6266, or 7231 explicitly disallows such
            keys, or otherwise specifies error-handling behavior for such
            keys.</para></summary>
            <param name='str'>A text string representing a media type. This
            media type can include parameters.</param>
            <param name='defaultValue'>The media type to return if the string
            is syntactically invalid. Can be null.</param>
            <returns>A MediaType object.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="F:PeterO.Mail.MediaType.QuotedStringRule.Http">

            <summary>Use HTTP rules for quoted strings.</summary>

</doc>
<doc name="F:PeterO.Mail.MediaType.QuotedStringRule.Rfc5322">

            <summary>Use Internet Message Format rules for quoted
            strings.</summary>

</doc>
<doc name="P:PeterO.Mail.MediaType.SubType">

            <summary>Gets this media type's subtype (for example, "plain" in
            "text/plain"). The resulting string will be in lowercase; that is,
            with its basic uppercase letters ("A" to "Z") converted to basic
            lowercase letters ("a" to "z").</summary>
            <value>This media type's subtype.</value>

</doc>
<doc name="F:PeterO.Mail.MediaType.TextPlainAscii">

            <summary>Specifies the media type "text/plain" and the "charset"
            parameter "US-ASCII", used for plain text data that contains only
            characters within the basic Latin range (U+0000 to
            U+007F).</summary>

</doc>
<doc name="F:PeterO.Mail.MediaType.TextPlainUtf8">

            <summary>Specifies the media type "text/plain" and the "charset"
            parameter "utf-8", used for plain text data that may contain
            characters outside the basic Latin range (U+0000 to
            U+007F).</summary>

</doc>
<doc name="M:PeterO.Mail.MediaType.ToSingleLineString">

            <summary>Converts this media type to a text string form suitable
            for inserting in HTTP headers. Notably, the string contains the
            value of a Content-Type header field (without the text necessarily
            starting with "Content-Type" followed by a space), and consists of
            a single line.</summary>
            <returns>A text string form of this media type.</returns>

</doc>
<doc name="M:PeterO.Mail.MediaType.ToString">

            <summary>Converts this media type to a text string form suitable
            for inserting in email headers. Notably, the string contains the
            value of a Content-Type header field (without the text necessarily
            starting with "Content-Type" followed by a space), and consists of
            one or more lines.</summary>
            <returns>A text string form of this media type.</returns>

</doc>
<doc name="M:PeterO.Mail.MediaType.ToUriSafeString">

            <summary>Converts this media type to a text string form suitable
            for data URIs. Notably, the string contains the value of a
            Content-Type header field (without the text necessarily starting
            with "Content-Type" followed by a space), consists of a single
            line, and uses percent-encoding as necessary or convenient so that
            the resulting string can validly appear in a URI path.</summary>
            <returns>A text string form of this media type.</returns>

</doc>
<doc name="P:PeterO.Mail.MediaType.TopLevelType">

            <summary>Gets the name of this media type's top-level type (such as
            "text" in "text/plain", or "audio" in "audio/basic"). The resulting
            string will be in lowercase; that is, with its basic uppercase
            letters ("A" to "Z") converted to basic lowercase letters ("a" to
            "z").</summary>
            <value>The name of this media type's top-level type (such as "text"
            or "audio" .</value>

</doc>
<doc name="P:PeterO.Mail.MediaType.TypeAndSubType">

            <summary>Gets the top level type and subtype of this media type,
            separated by a slash; for example, "text/plain". The resulting
            string will be in lowercase letters.</summary>
            <value>The top level type and subtype of this media type, separated
            by a slash; for example, "text/plain".</value>

</doc>
<doc name="T:PeterO.Mail.MediaTypeBuilder">

            <summary>A mutable media type object.</summary>

</doc>
<doc name="M:PeterO.Mail.MediaTypeBuilder.#ctor">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.MediaTypeBuilder'/> class, using the type
            "application/octet-stream" .</summary>

</doc>
<doc name="M:PeterO.Mail.MediaTypeBuilder.#ctor(PeterO.Mail.MediaType)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.MediaTypeBuilder'/> class using the data
            from another media type.</summary>
            <param name='mt'>The parameter <paramref name='mt'/> is a MediaType
            object.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='mt'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.MediaTypeBuilder.#ctor(System.String,System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.MediaTypeBuilder'/> class.</summary>
            <param name='type'>The media type's top-level type.</param>
            <param name='subtype'>The media type's subtype.</param>

</doc>
<doc name="P:PeterO.Mail.MediaTypeBuilder.IsMultipart">

            <summary>Gets a value indicating whether this is a multipart media
            type.</summary>
            <value><c>true</c> If this is a multipart media type; otherwise, <c>false</c>.</value>

</doc>
<doc name="P:PeterO.Mail.MediaTypeBuilder.IsText">

            <summary>Gets a value indicating whether this is a text media
            type.</summary>
            <value><c>true</c> If this is a text media type; otherwise, <c>false</c>.</value>

</doc>
<doc name="M:PeterO.Mail.MediaTypeBuilder.RemoveParameter(System.String)">

            <summary>Removes a parameter from this builder object. Does nothing
            if the parameter's name doesn't exist.</summary>
            <param name='name'>Name of the parameter to remove. The name is
            compared using a basic case-insensitive comparison. (Two strings
            are equal in such a comparison, if they match after converting the
            basic uppercase letters A to Z (U+0041 to U+005A) in both strings
            to basic lowercase letters.).</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='name'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.MediaTypeBuilder.SetParameter(System.String,System.String)">

            <summary>Sets a parameter's name and value for this media
            type.</summary>
            <param name='name'>Name of the parameter to set, such as "charset"
            . The name is compared using a basic case-insensitive comparison.
            (Two strings are equal in such a comparison, if they match after
            converting the basic uppercase letters A to Z (U+0041 to U+005A)
            in both strings to basic lowercase letters.).</param>
            <param name='value'>A text string giving the parameter's
            value.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='value'/> or <paramref name='name'/> is null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='name'/> is empty or syntactically invalid.</exception>

</doc>
<doc name="M:PeterO.Mail.MediaTypeBuilder.SetSubType(System.String)">

            <summary>Sets this media type's subtype, such as "plain" or "xml" .
            This method enables the pattern of method chaining (for example,
            <c>new...().Set...().Set...()</c> ) unlike with the SubType
            property in.NET or the setSubType method (with small s) in
            Java.</summary>
            <param name='str'>A text string naming a media subtype.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='str'/> is empty or syntactically invalid.</exception>

</doc>
<doc name="M:PeterO.Mail.MediaTypeBuilder.SetTopLevelType(System.String)">

            <summary>Sets this media type's top-level type. This method enables
            the pattern of method chaining (for example,
            <c>new...().Set...().Set...()</c> ) unlike with the TopLevelType
            property in.NET or the setTopLevelType method (with small s) in
            Java.</summary>
            <param name='str'>A text string naming a top-level type, such as
            "text" or "audio" .</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='str'/> is syntactically invalid for a top-level
            type.</exception>

</doc>
<doc name="P:PeterO.Mail.MediaTypeBuilder.SubType">

            <summary>Gets or sets this value's subtype.</summary>
            <value>A text string naming this object's subtype, such as "plain"
            or "xml".</value>
            <exception cref='ArgumentNullException'>The property is being set
            and the value is null.</exception>
            <exception cref='ArgumentException'>The property is being set and
            the value is syntactically invalid for a subtype.</exception>

</doc>
<doc name="M:PeterO.Mail.MediaTypeBuilder.ToMediaType">

            <summary>Converts this builder to an immutable media type
            object.</summary>
            <returns>A MediaType object.</returns>

</doc>
<doc name="M:PeterO.Mail.MediaTypeBuilder.ToString">

            <summary>Converts this object to a text string of the media type it
            represents, in the same form as <c>MediaType.ToString</c>.</summary>
            <returns>A string representation of this object.</returns>

</doc>
<doc name="P:PeterO.Mail.MediaTypeBuilder.TopLevelType">

            <summary>Gets or sets this value's top-level type.</summary>
            <value>A text string naming this object's top-level type, such as
            "text" or "audio" .</value>
            <exception cref='ArgumentNullException'>The property is being set
            and the value is null.</exception>
            <exception cref='ArgumentException'>The property is being set and
            the value is syntactically invalid for a top-level
            type.</exception>

</doc>
<doc name="T:PeterO.Mail.Message">

            <summary>Represents an email message, and contains methods and
            properties for accessing and modifying email message data. This
            class implements the Internet Message Format (RFC 5322) and
            Multipurpose Internet Mail Extensions (MIME; RFC 2045-2047, RFC
            2049).</summary>
            <remarks>
            <para><b>Thread safety:</b> This class is mutable; its properties
            can be changed. None of its instance methods are designed to be
            thread safe. Therefore, access to objects from this class must be
            synchronized if multiple threads can access them at the same
            time.</para>
            <para>The following lists known deviations from the mail
            specifications (Internet Message Format and MIME):</para>
            <list type=''>
            <item>If a message has two or more Content-Type header fields, it
            is treated as having a content type of "application/octet-stream",
            unless one or more of the header fields is syntactically
            invalid.</item>
            <item>Illegal UTF-8 byte sequences appearing in header field values
            are replaced with replacement characters. Moreover, UTF-8 is parsed
            everywhere in header field values, even in those parts of some
            structured header fields where this appears not to be allowed.
            (UTF-8 is a character encoding for the Unicode character
            set.)</item>
            <item>This implementation can parse a message even if that message
            is without a From header field, without a Date header field, or
            without both.</item>
            <item>The To and Cc header fields are allowed to contain only
            comments and whitespace, but these "empty" header fields will be
            omitted when generating.</item>
            <item>There is no line length limit imposed when parsing header
            fields, except header field names.</item>
            <item>There is no line length limit imposed when parsing
            quoted-printable or base64 encoded bodies.</item>
            <item>If the transfer encoding is absent and the content type is
            "message/rfc822", bytes with values greater than 127 are still
            allowed, despite the default value of "7bit" for
            "Content-Transfer-Encoding".</item>
            <item>In the following cases, if the transfer encoding is absent,
            declared as 7bit, or treated as 7bit, bytes greater than 127 are
            still allowed:</item>
            <item>(a) The preamble and epilogue of multipart messages, which
            will be ignored.</item>
            <item>(b) If the charset is declared to be <c>utf-8</c>.</item>
            <item>(c) If the content type is "text/html" and the charset is
            declared to be <c>us-ascii</c>, "windows-1252", "windows-1251", or
            "iso-8859-*" (all single byte encodings).</item>
            <item>(d) In text/plain message bodies. Any bytes greater than 127
            are replaced with the substitute character byte (0x1a).</item>
            <item>(e) In MIME message bodies (this is not a deviation from
            MIME, though). Any bytes greater than 127 are replaced with the
            substitute character byte (0x1a).</item>
            <item>If the message starts with the word "From" (and no other case
            variations of that word) followed by one or more space (U+0020) not
            followed by colon, that text and the rest of the text is skipped up
            to and including a line feed (U+000A). (See also RFC 4155, which
            describes the so-called "mbox" convention with "From" lines of this
            kind.)</item>
            <item>The name <c>ascii</c> is treated as a synonym for
            <c>us-ascii</c>, despite being a reserved name under RFC 2046. The
            names <c>cp1252</c> and <c>utf8</c> are treated as synonyms for
            <c>windows-1252</c> and <c>utf-8</c>, respectively, even though
            they are not IANA registered aliases.</item>
            <item>The following deviations involve encoded words under RFC
            2047:</item>
            <item>(a) If a sequence of encoded words decodes to a string with a
            CTL character (U+007F, or a character less than U+0020 and not TAB)
            after being converted to Unicode, the encoded words are left
            un-decoded.</item>
            <item>(b) This implementation can decode encoded words regardless
            of the character length of the line in which they appear. This
            implementation can generate a header field line with one or more
            encoded words even if that line is more than 76 characters long.
            (This implementation follows the recommendation in RFC 5322 to
            limit header field lines to no more than 78 characters, where
            possible; see also RFC 6532.)</item></list>
            <para>It would be appreciated if users of this library contact the
            author if they find other ways in which this implementation
            deviates from the mail specifications or other applicable
            specifications.</para>
            <para>This class currently doesn't support the "padding" parameter
            for message bodies with the media type "application/octet-stream"
            or treated as that media type (see RFC 2046 sec. 4.5.1).</para>
            <para>In this implementation, if the content-transfer-encoding
            "quoted-printable" or "base64" occurs in a message or body part
            with content type "multipart/*" or "message/*" (other than
            "message/global", "message/global-headers",
            "message/global-disposition-notification", or
            "message/global-delivery-status"), that encoding is treated as
            unrecognized for the purpose of treating that message or body part
            as having a content type of "application/octet-stream" rather than
            the declared content type. This is a clarification to RFCs 2045 and
            2049. (This may result in "misdecoded" messages because in
            practice, most if not all messages of this kind don't use
            quoted-printable or base64 encodings for the whole body, but may do
            so in the body parts they contain.)</para>
            <para>This implementation can decode an RFC 2047 encoded word that
            uses ISO-2022-JP or ISO-2022-JP-2 (encodings that use code
            switching) even if the encoded word's payload ends in a different
            mode from "ASCII mode". (Each encoded word still starts in "ASCII
            mode", though.) This, however, is not a deviation to RFC 2047
            because the relevant rule only concerns bringing the output device
            back to "ASCII mode" after the decoded text is displayed (see last
            paragraph of sec. 6.2) -- since the decoded text is converted to
            Unicode rather than kept as ISO-2022-JP or ISO-2022-JP-2, this is
            not applicable since there is no such thing as "ASCII mode" in the
            Unicode Standard.</para>
            <para>Note that this library (the MailLib library) has no
            facilities for sending and receiving email messages, since that's
            outside this library's scope.</para></remarks>

</doc>
<doc name="M:PeterO.Mail.Message.#ctor">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.Message'/> class. The message will be plain
            text and have an artificial From address.</summary>

</doc>
<doc name="M:PeterO.Mail.Message.#ctor(System.Byte[])">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.Message'/> class. Reads from the given byte
            array to initialize the email message.</summary>
            <param name='bytes'>A readable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bytes'/> is null.</exception>
            <exception cref='PeterO.Mail.MessageDataException'>The message is
            malformed. See the remarks.</exception>
            <remarks><b>Remarks:</b> <para>This constructor parses an email message, and extracts its
            header fields and body, and throws a MessageDataException if the
            message is malformed. However, even if a MessageDataException is
            thrown, it can still be possible to display the message, especially
            because most email malformations seen in practice are benign in
            nature (such as the use of very long lines in the message). One way
            an application can handle the exception is to display the message,
            or part of it, as raw text (using
            <c>DataUtilities.GetUtf8String(bytes, true)</c> ), and to
            optionally extract important header fields, such as From, To, Date,
            and Subject, from the message's text using the <c>ExtractHeader</c> method. Even so, though, any message for which this constructor
            throws a MessageDataException ought to be treated with
            suspicion.</para></remarks>

</doc>
<doc name="M:PeterO.Mail.Message.#ctor(System.IO.Stream)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.Message'/> class. Reads from the given
            Stream object to initialize the email message.</summary>
            <param name='stream'>A readable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='PeterO.Mail.MessageDataException'>The message is
            malformed. See the remarks.</exception>
            <remarks><b>Remarks:</b> <para>This constructor parses an email message, and extracts its
            header fields and body, and throws a MessageDataException if the
            message is malformed. However, even if a MessageDataException is
            thrown, it can still be possible to display the message, especially
            because most email malformations seen in practice are benign in
            nature (such as the use of very long lines in the message). One way
            an application can handle the exception is to read all the bytes
            from the stream, to display the message, or part of it, as raw text
            (using <c>DataUtilities.GetUtf8String(bytes, true)</c> ), and to
            optionally extract important header fields, such as From, To, Date,
            and Subject, from the message's text using the <c>ExtractHeader</c> method. Even so, though, any message for which this constructor
            throws a MessageDataException ought to be treated with
            suspicion.</para></remarks>

</doc>
<doc name="M:PeterO.Mail.Message.AddAttachment(PeterO.Mail.MediaType)">

            <summary>Adds an attachment with an empty body and with the given
            media type to this message. Before the new attachment is added, if
            this message isn't already a multipart message, it becomes a
            "multipart/mixed" message with the current body converted to an
            inline body part.</summary>
            <param name='mediaType'>A media type to assign to the
            attachment.</param>
            <returns>A Message object for the generated attachment.</returns>

</doc>
<doc name="M:PeterO.Mail.Message.AddAttachment(System.IO.Stream,PeterO.Mail.MediaType)">

            <summary>Adds an attachment to this message in the form of data
            from the given readable stream, and with the given media type.
            Before the new attachment is added, if this message isn't already a
            multipart message, it becomes a "multipart/mixed" message with the
            current body converted to an inline body part.</summary>
            <param name='inputStream'>A readable data stream.</param>
            <param name='mediaType'>A media type to assign to the
            attachment.</param>
            <returns>A Message object for the generated attachment.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='inputStream'/> or <paramref name='mediaType'/> is
            null.</exception>
            <exception cref='PeterO.Mail.MessageDataException'>An I/O error
            occurred.</exception>
            <example>The following example (written in C# for the.NET
            version) is an extension method that adds an attachment
            from a byte array to a message.
            <code>public static Message AddAttachmentFromBytes(this Message msg, byte[]
            bytes, MediaType mediaType) { using (var fs = new MemoryStream(bytes)) {
            return msg.AddAttachment(fs, mediaType); } }</code> .
            </example>

</doc>
<doc name="M:PeterO.Mail.Message.AddAttachment(System.IO.Stream,PeterO.Mail.MediaType,System.String)">

            <summary>Adds an attachment to this message in the form of data
            from the given readable stream, and with the given media type and
            file name. Before the new attachment is added, if this message
            isn't already a multipart message, it becomes a "multipart/mixed"
            message with the current body converted to an inline body
            part.</summary>
            <param name='inputStream'>A readable data stream.</param>
            <param name='mediaType'>A media type to assign to the
            attachment.</param>
            <param name='filename'>A file name to assign to the attachment. Can
            be null or empty, in which case no file name is assigned. Only the
            file name portion of this parameter is used, which in this case
            means the portion of the string after the last "/" or "\", if
            either character exists, or the entire string otherwise.</param>
            <returns>A Message object for the generated attachment.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='inputStream'/> or <paramref name='mediaType'/> is
            null.</exception>
            <exception cref='PeterO.Mail.MessageDataException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.AddAttachment(System.IO.Stream,System.String)">

            <summary>Adds an attachment to this message in the form of data
            from the given readable stream, and with the given file name.
            Before the new attachment is added, if this message isn't already a
            multipart message, it becomes a "multipart/mixed" message with the
            current body converted to an inline body part.</summary>
            <param name='inputStream'>A readable data stream.</param>
            <param name='filename'>A file name to assign to the attachment. Can
            be null or empty, in which case no file name is assigned. Only the
            file name portion of this parameter is used, which in this case
            means the portion of the string after the last "/" or "\", if
            either character exists, or the entire string otherwise An
            appropriate media type (or "application/octet-stream") will be
            assigned to the attachment based on this file name's extension. If
            the file name has an extension .txt, .text, .htm, .html, .shtml,
            .asc, .brf, .pot, .rst, .md, .markdown, or .srt, the media type
            will have a "charset" of "utf-8".</param>
            <returns>A Message object for the generated attachment.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='inputStream'/> is null.</exception>
            <exception cref='PeterO.Mail.MessageDataException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.AddHeader(System.Collections.Generic.KeyValuePair{System.String,System.String})">

            <summary>Adds a header field to the end of the message's header.
            <para>This method updates the ContentType and ContentDisposition
            properties if those header fields have been modified by this
            method.</para></summary>
            <param name='header'>A key/value pair. The key is the name of the
            header field, such as "From" or "Content-ID". The value is the
            header field's value.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentNullException'>The key or value of
            <paramref name='header'/> is null.</exception>
            <exception cref='ArgumentException'>The header field name is too
            long or contains an invalid character, or the header field's value
            is syntactically invalid.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.AddHeader(System.String,System.String)">

            <summary>Adds a header field to the end of the message's header.
            <para>This method updates the ContentType and ContentDisposition
            properties if those header fields have been modified by this
            method.</para></summary>
            <param name='name'>Name of a header field, such as "From" or
            "Content-ID" .</param>
            <param name='value'>Value of the header field.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='name'/> or <paramref name='value'/> is null.</exception>
            <exception cref='ArgumentException'>The header field name is too
            long or contains an invalid character, or the header field's value
            is syntactically invalid.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.AddInline(PeterO.Mail.MediaType)">

            <summary>Adds an inline body part with an empty body and with the
            given media type to this message. Before the new body part is
            added, if this message isn't already a multipart message, it
            becomes a "multipart/mixed" message with the current body converted
            to an inline body part.</summary>
            <param name='mediaType'>A media type to assign to the body
            part.</param>
            <returns>A Message object for the generated body part.</returns>

</doc>
<doc name="M:PeterO.Mail.Message.AddInline(System.IO.Stream,PeterO.Mail.MediaType)">

            <summary>Adds an inline body part to this message in the form of
            data from the given readable stream, and with the given media type.
            Before the new body part is added, if this message isn't already a
            multipart message, it becomes a "multipart/mixed" message with the
            current body converted to an inline body part.</summary>
            <param name='inputStream'>A readable data stream.</param>
            <param name='mediaType'>A media type to assign to the body
            part.</param>
            <returns>A Message object for the generated body part.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='inputStream'/> or <paramref name='mediaType'/> is
            null.</exception>
            <exception cref='PeterO.Mail.MessageDataException'>An I/O error
            occurred.</exception>
            <example>The following example (written in C# for the.NET
            version) is an extension method that adds an inline
            body part from a byte array to a message.
            <code>public static Message AddInlineFromBytes(this Message msg, byte[]
            bytes,
            MediaType mediaType) { using (MemoryStream fs = new MemoryStream(bytes))
            { return msg.AddInline(fs, mediaType); } }</code> .
            </example>

</doc>
<doc name="M:PeterO.Mail.Message.AddInline(System.IO.Stream,PeterO.Mail.MediaType,System.String)">

            <summary>Adds an inline body part to this message in the form of
            data from the given readable stream, and with the given media type
            and file name. Before the new body part is added, if this message
            isn't already a multipart message, it becomes a "multipart/mixed"
            message with the current body converted to an inline body
            part.</summary>
            <param name='inputStream'>A readable data stream.</param>
            <param name='mediaType'>A media type to assign to the body
            part.</param>
            <param name='filename'>A file name to assign to the body
            part.</param>
            <returns>A Message object for the generated body part.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='inputStream'/> or <paramref name='mediaType'/> is
            null.</exception>
            <exception cref='PeterO.Mail.MessageDataException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.AddInline(System.IO.Stream,System.String)">

            <summary>Adds an inline body part to this message in the form of
            data from the given readable stream, and with the given file name.
            Before the new body part is added, if this message isn't already a
            multipart message, it becomes a "multipart/mixed" message with the
            current body converted to an inline body part.</summary>
            <param name='inputStream'>A readable data stream.</param>
            <param name='filename'>A file name to assign to the inline body
            part. Can be null or empty, in which case no file name is assigned.
            Only the file name portion of this parameter is used, which in this
            case means the portion of the string after the last "/" or "\", if
            either character exists, or the entire string otherwise An
            appropriate media type (or "application/octet-stream") will be
            assigned to the body part based on this file name's extension. If
            the file name has an extension .txt, .text, .htm, .html, .shtml,
            .asc, .brf, .pot, .rst, .md, .markdown, or .srt, the media type
            will have a "charset" of "utf-8".</param>
            <returns>A Message object for the generated body part.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='inputStream'/> or "mediaType" is null.</exception>
            <exception cref='PeterO.Mail.MessageDataException'>An I/O error
            occurred.</exception>

</doc>
<doc name="P:PeterO.Mail.Message.BccAddresses">

            <summary>Gets a list of addresses found in the BCC header field or
            fields.</summary>
            <value>A list of addresses found in the BCC header field or
            fields.</value>

</doc>
<doc name="P:PeterO.Mail.Message.BodyString">

            <summary>Gets the body of this message as a text string. See the
            <c>GetBodyString()</c> method.</summary>
            <value>The body of this message as a text string.</value>
            <exception cref='NotSupportedException'>See the
            <c>GetBodyString()</c> method.</exception>

</doc>
<doc name="P:PeterO.Mail.Message.CCAddresses">

            <summary>Gets a list of addresses found in the CC header field or
            fields.</summary>
            <value>A list of addresses found in the CC header field or
            fields.</value>

</doc>
<doc name="M:PeterO.Mail.Message.ClearHeaders">

            <summary>Deletes all header fields in this message. Also clears
            this message's content disposition and resets its content type to
            MediaType.TextPlainAscii.</summary>
            <returns>This object.</returns>

</doc>
<doc name="P:PeterO.Mail.Message.ContentDisposition">

            <summary>Gets or sets this message's content disposition. The
            content disposition specifies how a user agent should display or
            otherwise handle this message. Can be set to null. If set to a
            disposition or to null, updates the Content-Disposition header
            field as appropriate. (There is no default content disposition if
            this value is null, and disposition types unrecognized by the
            application should be treated as "attachment"; see RFC 2183 sec.
            2.8.).</summary>
            <value>This message's content disposition, or null if none is
            specified.</value>

</doc>
<doc name="P:PeterO.Mail.Message.ContentType">

            <summary>Gets or sets this message's media type. When getting, the
            media type may differ in certain cases from the value of the
            Content-Type header field, if any, and may have a value even if the
            Content-Type header field is absent from this message. If set to a
            media type, updates the Content-Type header field as appropriate.
            Cannot be set to null.</summary>
            <value>This message's media type.</value>
            <exception cref='ArgumentNullException'>This value is being set and
            "value" is null.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.DecodeHeaderValue(System.String,System.String)">

            <summary>Decodes RFC 2047 encoded words from the given header field
            value and returns a string with those words decoded. For an example
            of encoded words, see the constructor for
            PeterO.Mail.NamedAddress.</summary>
            <param name='name'>Name of the header field. This determines the
            syntax of the "value" parameter and is necessary to help this
            method interpret encoded words properly.</param>
            <param name='value'>A header field value that could contain encoded
            words. For example, if the name parameter is "From", this parameter
            could be "=?utf-8?q?me?= &lt;me@example.com&gt;".</param>
            <returns>The header field value with valid encoded words
            decoded.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='name'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.ExtractField(System.Byte[],System.String)">
<summary>Extracts the value of a header field from a byte array representing an
      email message. The return value is intended for display purposes, not for
      further processing, and this method is intended to be used as an error
      handling tool for email messages that are slightly malformed. (Note that
      malformed email messages ought to be treated with greater suspicion than
      well-formed email messages.)
    </summary>
    <param name='bytes'>A byte array representing an email message.
    </param>
    <param name='headerField'>The name of a header field, such as "From", "To", or "Subject".
    </param>
    <returns>The value of the first instance of the header field with the given name.
      Returns null if "bytes" is null, if "headerFieldName" is null, is more
      than 997 characters long, or has a character less than U+0021 or greater
      than U+007E in the Unicode Standard, if a header field with that name does
      not exist, or if a body (even an empty one) does not follow the header
      fields.
    </returns>
</doc>
<doc name="M:PeterO.Mail.Message.ExtractHeader(System.Byte[],System.String)">

            <summary>Extracts the value of a header field from a byte array
            representing an email message. The return value is intended for
            display purposes, not for further processing, and this method is
            intended to be used as an error handling tool for email messages
            that are slightly malformed. (Note that malformed email messages
            ought to be treated with greater suspicion than well-formed email
            messages.).</summary>
            <param name='bytes'>A byte array representing an email
            message.</param>
            <param name='headerFieldName'>The name of the header field to
            extract. This name will be compared with the names of header fields
            in the given message using a basic case-insensitive comparison.
            (Two strings are equal in such a comparison, if they match after
            converting the basic uppercase letters A to Z (U+0041 to U+005A)
            in both strings to basic lowercase letters.).</param>
            <returns>The value of the first instance of the header field with
            the given name. Leading space and/or tab bytes (0x20 and/or 0x09)
            and CR/LF (0x0d/0x0a) pairs will be removed from the header field
            value, and the value is treated as encoded in UTF-8 (an 8-bit
            encoding form of the Unicode Standard) where illegally encoded
            UTF-8 is replaced as appropriate with replacement characters
            (U+FFFD). Returns null if <paramref name='bytes'/> is null, if
            <paramref name='headerFieldName'/> is null, is more than 997
            characters long, or has a character less than U+0021 or greater
            than U+007E in the Unicode Standard, if a header field with that
            name does not exist, or if a body (even an empty one) does not
            follow the header fields.</returns>

</doc>
<doc name="P:PeterO.Mail.Message.FileName">

            <summary><para>Gets a file name suggested by this message for saving the
            message's body to a file. For more information on the algorithm,
            see ContentDisposition.MakeFilename.</para>
            <para>This method generates a file name based on the
            <c>filename</c> parameter of the Content-Disposition header field,
            if it exists, or on the <c>name</c> parameter of the Content-Type
            header field, otherwise.</para></summary>
            <value>A suggested name for the file. Returns the empty string if
            there is no filename suggested by the content type or content
            disposition, or if that filename is an empty string.</value>

</doc>
<doc name="P:PeterO.Mail.Message.FromAddresses">

            <summary>Gets a list of addresses found in the From header field or
            fields.</summary>
            <value>A list of addresses found in the From header field or
            fields.</value>

</doc>
<doc name="M:PeterO.Mail.Message.FromMailtoUri(System.String)">

            <summary>Creates a message object from a MailTo URI (uniform
            resource identifier). The MailTo URI can contain key-value pairs
            that follow a question-mark, as in the following example:
            "mailto:me@example.com?subject=A%20Subject". In this example,
            "subject" is the subject of the email address. Only certain keys
            are supported, namely, "to", "cc", "bcc", "subject", "in-reply-to",
            "comments", "keywords", and "body". The first seven are header
            field names that will be used to set the returned message's
            corresponding header fields. The last, "body", sets the body of the
            message to the given text. Keys other than these eight will be
            ignored. (Keys are compared using a basic case-sensitive
            comparison, in which two strings are equal if they match after
            converting the basic uppercase letters A to Z (U+0041 to U+005A)
            in both strings to basic lowercase letters.) The same key (matched
            using a basic case-insensitive comparison) can appear more than
            once; for "subject", "cc", "bcc", and "in-reply-to", the last value
            with the given key is used; for "to", all header field values as
            well as the path are combined to a single To header field; for
            "keywords" and "comments", each value adds another header field of
            the given key; and for "body", the last value with that key is used
            as the body.</summary>
            <param name='uri'>The parameter <paramref name='uri'/> is a text
            string.</param>
            <returns>A Message object created from the given MailTo URI. Returs
            null if <paramref name='uri'/> is null, is syntactically invalid,
            or is not a MailTo URI.</returns>

</doc>
<doc name="M:PeterO.Mail.Message.FromMailtoUri(System.Uri)">

            <summary>Creates a message object from a MailTo URI (uniform
            resource identifier) in the form of a URI object. For more
            information, see <b>FromMailtoUri(string)</b>.</summary>
            <param name='uri'>The MailTo URI in the form of a URI
            object.</param>
            <returns>A Message object created from the given MailTo URI. Returs
            null if <paramref name='uri'/> is null, is syntactically invalid,
            or is not a MailTo URI.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='uri'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.FromMailtoUrl(System.String)">

            <summary>Creates a message object from a MailTo URI (uniform
            resource identifier). For more information, see
            <b>FromMailtoUri(string)</b>.</summary>
            <param name='url'>A MailTo URI.</param>
            <returns>A Message object created from the given MailTo URI. Returs
            null if <paramref name='url'/> is null, is syntactically invalid,
            or is not a MailTo URI.</returns>

</doc>
<doc name="M:PeterO.Mail.Message.Generate">

            <summary>Generates this message's data in text form.
            <para>The generated message will have only Basic Latin code points
            (U+0000 to U+007F), and the transfer encoding will always be 7bit,
            quoted-printable, or base64 (the declared transfer encoding for
            this message will be ignored).</para>
            <para>The following applies to the following header fields: From,
            To, Cc, Bcc, Reply-To, Sender, Resent-To, Resent-From, Resent-Cc,
            Resent-Bcc, and Resent-Sender. If the header field exists, but has
            an invalid syntax, has no addresses, or appears more than once,
            this method will combine the addresses into one header field if
            possible (in the case of all fields given other than From and
            Sender), and otherwise generate a synthetic header field with the
            display-name set to the contents of all of the header fields with
            the same name, and the address set to
            <c>me@[header-name]-address.invalid</c> as the address (a
            <c>.invalid</c> address is a reserved address that can never belong
            to anyone). (An exception is that the Resent-* header fields may
            appear more than once.) The generated message should always have a
            From header field.</para>
            <para>If a Date and/or Message-ID header field doesn't exist, a
            field with that name will be generated (using the current local
            time for the Date field).</para>
            <para>When encoding the message's body, if the message has a text
            content type ("text/*"), the line breaks are a CR byte (carriage
            return, 0x0d) followed by an LF byte (line feed, 0x0a), CR alone,
            or LF alone. If the message has any other content type, only CR
            followed by LF is considered a line break.</para></summary>
            <returns>The generated message.</returns>
            <exception cref='PeterO.Mail.MessageDataException'>The message
            can't be generated.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.GenerateBytes">

            <summary>Generates this message's data as a byte array, using the
            same algorithm as the Generate method.</summary>
            <returns>The generated message as a byte array.</returns>

</doc>
<doc name="M:PeterO.Mail.Message.GetAddresses(System.String)">

            <summary>Gets a list of addresses contained in the header fields
            with the given name in this message.</summary>
            <param name='headerName'>The name of the header fields to
            retrieve.</param>
            <returns>A list of addresses, in the order in which they appear in
            this message's header fields of the given name.</returns>
            <exception cref='NotSupportedException'>The parameter <paramref name='headerName'/> is not supported for this method. Currently,
            the only header fields supported are To, Cc, Bcc, Reply-To, Sender,
            and From.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='headerName'/> is null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='headerName'/> is empty.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.GetAttachments">

            <summary>Gets a list of descendant body parts of this message that
            are considered attachments. An
            <i>attachment</i> is a body part or descendant body part that has a
            content disposition with a type other than inline. This message
            itself is not included in the list even if it's an attachment as
            just defined.</summary>
            <returns>A list of descendant body parts of this message that are
            considered attachments.</returns>

</doc>
<doc name="M:PeterO.Mail.Message.GetBody">

            <summary>Gets the byte array for this message's body. This method
            doesn' t make a copy of that byte array.</summary>
            <returns>A byte array.</returns>

</doc>
<doc name="M:PeterO.Mail.Message.GetBodyMessage">

            <summary>Returns the mail message contained in this message's
            body.</summary>
            <returns>A message object if this object's content type is
            "message/rfc822", "message/news", or "message/global", or null
            otherwise.</returns>

</doc>
<doc name="M:PeterO.Mail.Message.GetBodyString">

            <summary>Gets the body of this message as a text string. If this
            message's media type is "multipart/alternative", returns the result
            of this method for the last supported body part. For any other
            "multipart" media type, returns the result of this method for the
            first body part for which this method returns a text
            string.</summary>
            <returns>The body of this message as a text string.</returns>
            <exception cref='NotSupportedException'>This message is a multipart
            message without a supported body part; or this message has a
            content disposition with a type other than "inline"; or this
            message's media type is a nonmultipart type and does not specify
            the use of a "charset" parameter, has no character encoding
            declared or assumed for it (which is usually the case for nontext
            messages), or has an unsupported character encoding.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.GetDate">

            <summary>Gets the date and time extracted from this message's Date
            header field (the value of which is found as though
            GetHeader("date") were called). See
            <b>MailDateTime.ParseDateString(string, bool)</b> for more
            information on the format of the date-time array returned by this
            method.</summary>
            <returns>An array of 32-bit unsigned integers.</returns>

</doc>
<doc name="M:PeterO.Mail.Message.GetFormattedBodyString">

            <summary><para>Gets a Hypertext Markup Language (HTML) rendering of this
            message's text body. This method currently supports any message for
            which <c>GetBodyString()</c> gives out a text string and treats the
            following media types specially: text/plain with
            <c>format=flowed</c>, text/enriched, text/markdown (original
            Markdown).</para></summary>
            <returns>An HTML rendering of this message's text.</returns>
            <exception cref='NotSupportedException'>No supported body part was
            found; see <c>GetBodyString()</c> for more information.</exception>
            <remarks>
            <para>REMARK: The Markdown implementation currently supports all
            features of original Markdown, except that the
            implementation:</para>
            <list>
            <item>does not strictly check the placement of "block-level HTML
            elements",</item>
            <item>does not prevent Markdown content from being interpreted as
            such merely because it's contained in a "block-level HTML element",
            and</item>
            <item>does not deliberately use HTML escapes to obfuscate email
            addresses wrapped in angle-brackets.</item></list></remarks>

</doc>
<doc name="M:PeterO.Mail.Message.GetHeader(System.Int32)">

            <summary>Gets the name and value of a header field by
            index.</summary>
            <param name='index'>Zero-based index of the header field to
            get.</param>
            <returns>A key/value pair. The key is the name of the header field,
            such as "From" or "Content-ID". The value is the header field's
            value.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='index'/> is 0 or at least as high as the number of header
            fields.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.GetHeader(System.String)">

            <summary>Gets the first instance of the header field with the
            specified name, using a basic case-insensitive comparison. (Two
            strings are equal in such a comparison, if they match after
            converting the basic uppercase letters A to Z (U+0041 to U+005A)
            in both strings to basic lowercase letters.).</summary>
            <param name='name'>The name of a header field.</param>
            <returns>The value of the first header field with that name, or
            null if there is none.</returns>
            <exception cref='ArgumentNullException'>Name is null.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.GetHeaderArray(System.String)">

            <summary>Gets an array with the values of all header fields with
            the specified name, using a basic case-insensitive comparison. (Two
            strings are equal in such a comparison, if they match after
            converting the basic uppercase letters A to Z (U+0041 to U+005A)
            in both strings to basic lowercase letters.).</summary>
            <param name='name'>The name of a header field.</param>
            <returns>An array containing the values of all header fields with
            the given name, in the order they appear in the message. The array
            will be empty if no header field has that name.</returns>
            <exception cref='ArgumentNullException'>Name is null.</exception>

</doc>
<doc name="P:PeterO.Mail.Message.HeaderFields">

            <summary>Gets a snapshot of the header fields of this message, in
            the order in which they appear in the message. For each item in the
            list, the key is the header field's name (where any basic
            uppercase letters, U+0041 to U+005A, are converted to basic
            lowercase letters) and the value is the header field's
            value.</summary>
            <value>A snapshot of the header fields of this message.</value>

</doc>
<doc name="M:PeterO.Mail.Message.MakeMultilingualMessage(System.Collections.Generic.IList{PeterO.Mail.Message},System.Collections.Generic.IList{System.String})">

            <summary>Generates a multilingual message (see RFC 8255) from a
            list of messages and a list of language strings.</summary>
            <param name='messages'>A list of messages forming the parts of the
            multilingual message object. Each message should have the same
            content, but be in a different language. Each message must have a
            From header field and use the same email address in that field as
            the other messages. The messages should be ordered in descending
            preference of language.</param>
            <param name='languages'>A list of language strings corresponding to
            the messages given in the "messages" parameter. A language string
            at a given index corresponds to the message at the same index. Each
            language string must follow the syntax of the Content-Language
            header field (see LanguageTags.GetLanguageList).</param>
            <returns>A Message object with the content type
            "multipart/multilingual" . It will begin with an explanatory body
            part and be followed by the messages given in the <paramref name='messages'/> parameter in the order given.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='messages'/> or <paramref name='languages'/> is
            null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='messages'/> or <paramref name='languages'/> is empty, their
            lengths don't match, at least one message is "null", each message
            doesn't contain the same email addresses in their From header
            fields, <paramref name='languages'/> contains a syntactically
            invalid language tag list, <paramref name='languages'/> contains
            the language tag "zzx" not appearing alone or at the end of the
            language tag list, or the first message contains no From header
            field.</exception>

</doc>
<doc name="P:PeterO.Mail.Message.MessageStackEntry.Boundary">

            <summary>Gets a value which is used in an internal API.</summary>
            <value>This is an internal API.</value>

</doc>
<doc name="P:PeterO.Mail.Message.MessageStackEntry.Message">

            <summary>Gets a value which is used in an internal API.</summary>
            <value>This is an internal API.</value>

</doc>
<doc name="M:PeterO.Mail.Message.NewBodyPart">

            <summary>Creates a message object with no header fields.</summary>
            <returns>A message object with no header fields.</returns>

</doc>
<doc name="P:PeterO.Mail.Message.Parts">

            <summary>Gets a list of all the parts of this message. This list is
            editable. This will only be used if the message is a multipart
            message.</summary>
            <value>A list of all the parts of this message. This list is
            editable. This will only be used if the message is a multipart
            message.</value>

</doc>
<doc name="M:PeterO.Mail.Message.RemoveHeader(System.Int32)">

            <summary>Removes a header field by index.
            <para>This method updates the ContentType and ContentDisposition
            properties if those header fields have been modified by this
            method.</para></summary>
            <param name='index'>Zero-based index of the header field to
            set.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='index'/> is 0 or at least as high as the number of header
            fields.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.RemoveHeader(System.String)">

            <summary>Removes all instances of the given header field from this
            message. If this is a multipart message, the header field is not
            removed from its body part headers. A basic case-insensitive
            comparison is used. (Two strings are equal in such a comparison, if
            they match after converting the basic uppercase letters A to Z
            (U+0041 to U+005A) in both strings to basic lowercase letters.).
            <para>This method updates the ContentType and ContentDisposition
            properties if those header fields have been modified by this
            method.</para></summary>
            <param name='name'>The name of the header field to remove.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='name'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.SelectLanguageMessage(System.Collections.Generic.IList{System.String})">

            <summary>Selects a body part for a multiple-language message(
            <c>multipart/multilingual</c> ) according to the given language
            priority list.</summary>
            <param name='languages'>A list of basic language ranges, sorted in
            descending order of priority (see the
            LanguageTags.LanguageTagFilter method).</param>
            <returns>The best matching body part for the given languages. If
            the body part has no subject, then the top-level subject is used.
            If this message is not a multipart/multilingual message or has
            fewer than two body parts, returns this object. If no body part
            matches the given languages, returns the last body part if its
            language is "zxx", or the second body part otherwise.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='languages'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.SelectLanguageMessage(System.Collections.Generic.IList{System.String},System.Boolean)">

            <summary>Selects a body part for a multiple-language message(
            <c>multipart/multilingual</c> ) according to the given language
            priority list and original-language preference.</summary>
            <param name='languages'>A list of basic language ranges, sorted in
            descending order of priority (see the
            LanguageTags.LanguageTagFilter method).</param>
            <param name='preferOriginals'>If true, a body part marked as the
            original language version is chosen if it matches one of the given
            language ranges, even if the original language has a lower priority
            than another language with a matching body part.</param>
            <returns>The best matching body part for the given languages. If
            the body part has no subject, then the top-level subject is used.
            If this message is not a multipart/multilingual message or has
            fewer than two body parts, returns this object. If no body part
            matches the given languages, returns the last body part if its
            language is "zxx", or the second body part otherwise.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='languages'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.SetBody(System.Byte[])">

            <summary>Sets the body of this message to the given byte array.
            This method doesn't make a copy of that byte array.</summary>
            <param name='bytes'>A byte array.</param>
            <returns>This object.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bytes'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.SetCurrentDate">

            <summary>Sets this message's Date header field to the current time
            as its value, with an unspecified time zone offset.
            <para>This method can be used when the message is considered
            complete and ready to be generated, for example, using the
            "Generate()" method.</para></summary>
            <returns>This object.</returns>

</doc>
<doc name="M:PeterO.Mail.Message.SetDate(System.Int32[])">

            <summary>Sets this message's Date header field to the given date
            and time.</summary>
            <param name='dateTime'>An array containing at least eight elements
            expressing a date and time. See
            <b>MailDateTime.ParseDateString(string, bool)</b> for more
            information on this parameter.</param>
            <returns>This object.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='dateTime'/> contains fewer than eight elements or contains
            invalid values (see <b>MailDateTime.ParseDateString(string,
            bool)</b> ).</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='dateTime'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.SetHeader(System.Int32,System.Collections.Generic.KeyValuePair{System.String,System.String})">

            <summary>Sets the name and value of a header field by index.
            <para>This method updates the ContentType and ContentDisposition
            properties if those header fields have been modified by this
            method.</para></summary>
            <param name='index'>Zero-based index of the header field to
            set.</param>
            <param name='header'>A key/value pair. The key is the name of the
            header field, such as "From" or "Content-ID". The value is the
            header field's value.</param>
            <returns>A Message object.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='index'/> is 0 or at least as high as the number of header
            fields; or, the header field name is too long or contains an
            invalid character, or the header field's value is syntactically
            invalid.</exception>
            <exception cref='ArgumentNullException'>The key or value of
            <paramref name='header'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.SetHeader(System.Int32,System.String)">

            <summary>Sets the value of a header field by index without changing
            its name.
            <para>This method updates the ContentType and ContentDisposition
            properties if those header fields have been modified by this
            method.</para></summary>
            <param name='index'>Zero-based index of the header field to
            set.</param>
            <param name='value'>Value of the header field.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='index'/> is 0 or at least as high as the number of header
            fields; or, the header field name is too long or contains an
            invalid character, or the header field's value is syntactically
            invalid.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='value'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.SetHeader(System.Int32,System.String,System.String)">

            <summary>Sets the name and value of a header field by index.
            <para>This method updates the ContentType and ContentDisposition
            properties if those header fields have been modified by this
            method.</para></summary>
            <param name='index'>Zero-based index of the header field to
            set.</param>
            <param name='name'>Name of a header field, such as "From" or
            "Content-ID" .</param>
            <param name='value'>Value of the header field.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='index'/> is 0 or at least as high as the number of header
            fields; or, the header field name is too long or contains an
            invalid character, or the header field's value is syntactically
            invalid.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='name'/> or <paramref name='value'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.SetHeader(System.String,System.String)">

            <summary>Sets the value of this message's header field. If a header
            field with the same name exists, its value is replaced. If the
            header field's name occurs more than once, only the first instance
            of the header field is replaced.
            <para>This method updates the ContentType and ContentDisposition
            properties if those header fields have been modified by this
            method.</para></summary>
            <param name='name'>The name of a header field, such as "from" or
            "subject" .</param>
            <param name='value'>The header field's value.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentException'>The header field name is too
            long or contains an invalid character, or the header field's value
            is syntactically invalid.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='name'/> or <paramref name='value'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.SetHtmlBody(System.String)">

            <summary>Sets the body of this message to the specified string in
            Hypertext Markup Language (HTML) format. The character sequences CR
            (carriage return, "\r", U+000D), LF (line feed, "\n", U+000A), and
            CR/LF will be converted to CR/LF line breaks. Unpaired surrogate
            code points will be replaced with replacement characters.</summary>
            <param name='str'>A string consisting of the message in HTML
            format.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.SetTextAndHtml(System.String,System.String)">

            <summary>Sets the body of this message to a multipart body with
            plain text and Hypertext Markup Language (HTML) versions of the
            same message. The character sequences CR (carriage return, "\r",
            U+000D), LF (line feed, "\n", U+000A), and CR/LF will be converted
            to CR/LF line breaks. Unpaired surrogate code points will be
            replaced with replacement characters.</summary>
            <param name='text'>A string consisting of the plain text version of
            the message.</param>
            <param name='html'>A string consisting of the HTML version of the
            message.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='text'/> or <paramref name='html'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.Message.SetTextAndMarkdown(System.String,System.String)">

            <summary>Sets the body of this message to a multipart body with
            plain text, Markdown, and Hypertext Markup Language (HTML) versions
            of the same message. The character sequences CR (carriage return,
            "\r", U+000D), LF (line feed, "\n", U+000A), and CR/LF will be
            converted to CR/LF line breaks. Unpaired surrogate code points will
            be replaced with replacement characters.</summary>
            <param name='text'>A string consisting of the plain text version of
            the message. Can be null, in which case the value of the "markdown"
            parameter is used as the plain text version.</param>
            <param name='markdown'>A string consisting of the Markdown version
            of the message. For interoperability, this Markdown version will be
            converted to HTML, where the Markdown text is assumed to be in the
            original Markdown flavor.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='markdown'/> is null.</exception>
            <remarks>
            <para>REMARK: The Markdown-to-HTML implementation currently
            supports all features of original Markdown, except that the
            implementation:</para>
            <list>
            <item>does not strictly check the placement of "block-level HTML
            elements",</item>
            <item>does not prevent Markdown content from being interpreted as
            such merely because it's contained in a "block-level HTML element",
            and</item>
            <item>does not deliberately use HTML escapes to obfuscate email
            addresses wrapped in angle-brackets.</item></list></remarks>

</doc>
<doc name="M:PeterO.Mail.Message.SetTextBody(System.String)">

            <summary>Sets the body of this message to the specified plain text
            string. The character sequences CR (carriage return, "\r", U+000D),
            LF (line feed, "\n", U+000A), and CR/LF will be converted to CR/LF
            line breaks. Unpaired surrogate code points will be replaced with
            replacement characters. This method changes this message's media
            type to plain text.</summary>
            <param name='str'>A string consisting of the message in plain text
            format.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="P:PeterO.Mail.Message.Subject">

            <summary>Gets or sets this message's subject. The subject's value
            is found as though GetHeader("subject") were called.</summary>
            <value>This message's subject, or null if there is none.</value>

</doc>
<doc name="P:PeterO.Mail.Message.ToAddresses">

            <summary>Gets a list of addresses found in the To header field or
            fields.</summary>
            <value>A list of addresses found in the To header field or
            fields.</value>

</doc>
<doc name="M:PeterO.Mail.Message.ToMailtoUri">

            <summary>Generates a MailTo URI (uniform resource identifier)
            corresponding to this message. The following header fields, and
            only these, are used to generate the URI: To, Cc, Bcc, In-Reply-To,
            Subject, Keywords, Comments. The message body is included in the
            URI only if <c>GetBodyString()</c> would return a nonempty
            string.. The To header field is included in the URI only if it has
            display names or group syntax.</summary>
            <returns>A MailTo URI corresponding to this message.</returns>

</doc>
<doc name="M:PeterO.Mail.Message.ToMailtoUrl">

            <summary>Generates a MailTo URI (uniform resource identifier)
            corresponding to this message. The following header fields, and
            only these, are used to generate the URI: To, Cc, Bcc, In-Reply-To,
            Subject, Keywords, Comments. The message body is included in the
            URI only if <c>GetBodyString()</c> would return a nonempty string.
            The To header field is included in the URI only if it has display
            names or group syntax.</summary>
            <returns>A MailTo URI corresponding to this message.</returns>

</doc>
<doc name="T:PeterO.Mail.MessageDataException">

            <summary>Exception thrown when a message has invalid syntax.
            <para>This library may throw exceptions of this type in certain
            cases, notably when errors occur, and may supply messages to those
            exceptions (the message can be accessed through the <c>Message</c> property in.NET or the <c>getMessage()</c> method in Java). These
            messages are intended to be read by humans to help diagnose the
            error (or other cause of the exception); they are not intended to
            be parsed by computer programs, and the exact text of the messages
            may change at any time between versions of this
            library.</para></summary>

</doc>
<doc name="M:PeterO.Mail.MessageDataException.#ctor">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.MessageDataException'/> class.</summary>

</doc>
<doc name="M:PeterO.Mail.MessageDataException.#ctor(System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.MessageDataException'/> class.</summary>
            <param name='message'>A string to use as the exception
            message.</param>

</doc>
<doc name="M:PeterO.Mail.MessageDataException.#ctor(System.String,System.Exception)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.MessageDataException'/> class.</summary>
            <param name='message'>A string to use as the exception
            message.</param>
            <param name='innerException'>The parameter <paramref name='innerException'/> is an Exception object.</param>

</doc>
<doc name="T:PeterO.Mail.NamedAddress">

            <summary>Represents an email address and a name for that address.
            Can represent a group of email addresses instead.</summary>

</doc>
<doc name="M:PeterO.Mail.NamedAddress.#ctor(System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.NamedAddress'/> class. Examples:
            <list>
            <item><c>john@example.com</c></item>
            <item><c>"John Doe" &lt;john@example.com&gt;</c></item>
              <item><c>=?utf-8?q?John</c><c>=</c><c>27s_Office?=&lt;john@example.com&gt;</c></item>
            <item><c>John &lt;john@example.com&gt;</c></item>
            <item><c>"Group" : Tom &lt;tom@example.com&gt;, Jane
            &lt;jane@example.com&gt;;</c></item></list></summary>
            <param name='address'>A text string identifying a single email
            address or a group of email addresses. Comments, or text within
            parentheses, can appear. Multiple email addresses are not allowed
            unless they appear in the group syntax given earlier. Encoded words
            under RFC 2047 that appear within comments or display names will be
            decoded.
            <para>An RFC 2047 encoded word consists of "=?", a character
            encoding name, such as <c>utf-8</c>, either "?B?" or "?Q?" (in
            uppercase or lowercase), a series of bytes in the character encoding,
            further encoded using B or Q encoding, and finally "?=". B encoding
            uses Base64, while in Q encoding, spaces are changed to "_", equals
            are changed to "=3D", and most bytes other than the basic digits 0
            to 9 (0x30 to 0x39) and the basic letters A/a to Z/z (0x41 to 0x5a,
            0x61 to 0x7a) are changed to "=" followed by their 2-digit
            hexadecimal form. An encoded word's maximum length is 75
            characters. See the third example.</para>.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='address'/> is null.</exception>
            <exception cref='ArgumentException'>Address has an invalid syntax.;
            Address has an invalid syntax.</exception>

</doc>
<doc name="M:PeterO.Mail.NamedAddress.#ctor(System.String,PeterO.Mail.Address)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.NamedAddress'/> class using the given
            display name and email address.</summary>
            <param name='displayName'>The display name of the email address.
            Can be null or empty. Encoded words under RFC 2047 will not be
            decoded.</param>
            <param name='address'>An email address.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='address'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.NamedAddress.#ctor(System.String,System.Collections.Generic.IList{PeterO.Mail.NamedAddress})">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.NamedAddress'/> class. Takes a group name
            and several named email addresses as parameters, and forms a group
            with them.</summary>
            <param name='groupName'>The group's name.</param>
            <param name='mailboxes'>A list of named addresses that make up the
            group.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='groupName'/> or <paramref name='mailboxes'/> is
            null.</exception>
            <exception cref='ArgumentException'>GroupName is empty.; A mailbox
            in the list is a group.</exception>

</doc>
<doc name="M:PeterO.Mail.NamedAddress.#ctor(System.String,System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.NamedAddress'/> class using the given
            display name and email address.</summary>
            <param name='displayName'>The display name of the email address.
            Can be null or empty. Encoded words under RFC 2047 will not be
            decoded.</param>
            <param name='address'>An email address.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='address'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.NamedAddress.#ctor(System.String,System.String,System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.NamedAddress'/> class using the given name
            and an email address made up of its local part and
            domain.</summary>
            <param name='displayName'>The display name of the email address.
            Can be null or empty.</param>
            <param name='localPart'>The local part of the email address (before
            the "@").</param>
            <param name='domain'>The domain of the email address (before the
            "@").</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='localPart'/> or <paramref name='domain'/> is
            null.</exception>

</doc>
<doc name="P:PeterO.Mail.NamedAddress.Address">

            <summary>Gets the email address associated with this
            object.</summary>
            <value>The email address associated with this object. This value is
            null if this object represents a group of addresses
            instead.</value>

</doc>
<doc name="M:PeterO.Mail.NamedAddress.AddressesEqual(PeterO.Mail.NamedAddress)">

            <summary>Determines whether the email addresses stored this object
            are the same between this object and the given object, regardless
            of the display names they store. For groups, the email addresses
            must be equal and in the same order in both objects.</summary>
            <param name='na'>A named address object to compare with this one.
            Can be null.</param>
            <returns>Either <c>true</c> or <c>false</c>.</returns>

</doc>
<doc name="P:PeterO.Mail.NamedAddress.DisplayName">

            <summary>Gets the display name for this email address.</summary>
            <value>The display name for this email address. Returns null if the
            display name is absent.</value>

</doc>
<doc name="M:PeterO.Mail.NamedAddress.Equals(System.Object)">

            <summary>Determines whether this object and another object are
            equal. For groups, the named addresses (display name/email address
            pairs) must be equal and in the same order in both
            objects.</summary>
            <param name='obj'>An arbitrary object to compare with this
            one.</param>
            <returns><c>true</c> if this object and another object are equal
            and have the same type; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Mail.NamedAddress.GetHashCode">

            <summary>Calculates the hash code of this object. The exact
            algorithm used by this method is not guaranteed to be the same
            between versions of this library, and no application or process IDs
            are used in the hash code calculation.</summary>
            <returns>A 32-bit hash code.</returns>

</doc>
<doc name="P:PeterO.Mail.NamedAddress.GroupAddresses">

            <summary>Gets a read-only list of addresses that make up the group,
            if this object represents a group, or an empty list
            otherwise.</summary>
            <value>A list of addresses that make up the group, if this object
            represents a group, or an empty list otherwise.</value>

</doc>
<doc name="P:PeterO.Mail.NamedAddress.IsGroup">

            <summary>Gets a value indicating whether this represents a group of
            addresses rather than a single address.</summary>
            <value><c>true</c> If this represents a group of addresses; otherwise, <c>false</c>.</value>

</doc>
<doc name="P:PeterO.Mail.NamedAddress.Name">

            <summary>Gets the display name for this email address, or the email
            address's value if the display name is null. Returns an empty
            string if the address and display name are null.</summary>
            <value>The name for this email address.</value>

</doc>
<doc name="M:PeterO.Mail.NamedAddress.ParseAddresses(System.String)">

            <summary>Generates a list of NamedAddress objects from a
            comma-separated list of addresses. Each address must follow the
            syntax accepted by the one-argument constructor of
            NamedAddress.</summary>
            <param name='addressValue'>A comma-separated list of addresses in
            the form of a text string.</param>
            <returns>A list of addresses generated from the <paramref name='addressValue'/> parameter.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='addressValue'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.NamedAddress.ToDisplayString">

            <summary>Converts this named-address object to a text string
            intended to be displayed for others to see. The returned string is not
            intended to be parsed by computer programs.</summary>
            <returns>A text string of this named-address object, intended for
            display to end-users.</returns>

</doc>
<doc name="M:PeterO.Mail.NamedAddress.ToDisplayString(System.Collections.Generic.IList{PeterO.Mail.NamedAddress})">

            <summary>Generates a string containing the display names and email
            addresses of the given named-address objects, separated by commas.
            The generated string is intended to be displayed for others to see, and
            is not intended to be parsed by computer programs.</summary>
            <param name='addresses'>A list of named address objects.</param>
            <returns>A string containing the display names and email addresses
            of the given named-address objects, separated by commas.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='addresses'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.NamedAddress.ToDisplayStringShort(System.Collections.Generic.IList{PeterO.Mail.NamedAddress})">

            <summary>Generates a string containing the display names of the
            given named-address objects, separated by commas. The generated
            string is intended to be displayed for others to see, and is not
            intended to be parsed by computer programs. If a named address has
            no display name, its email address is used as the display
            name.</summary>
            <param name='addresses'>A list of named address objects.</param>
            <returns>A string containing the display names of the given
            named-address objects, separated by commas.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='addresses'/> is null.</exception>

</doc>
<doc name="M:PeterO.Mail.NamedAddress.ToString">

            <summary>Converts this object to a text string. This will generally
            be the form of this NamedAddress object as it could appear in a
            "To" header field.</summary>
            <returns>A string representation of this object.</returns>

</doc>
<doc name="T:PeterO.Mail.QuotedPrintableEncoder">

            <summary>Encodes binary data into Quoted Printable.</summary>

</doc>
<doc name="T:PeterO.Mail.StringAndQuality">

            <summary>Stores an arbitrary string and a "quality value" for that
            string. For instance, the string can be a language tag, and the
            "quality value" can be the degree of preference for that
            language.</summary>

</doc>
<doc name="M:PeterO.Mail.StringAndQuality.#ctor(System.String,System.Int32)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Mail.StringAndQuality'/> class.</summary>
            <param name='value'>An arbitrary text string.</param>
            <param name='quality'>A 32-bit signed integer serving as the
            "quality" value.</param>

</doc>
<doc name="P:PeterO.Mail.StringAndQuality.Quality">

            <summary>Gets the quality value stored by this object.</summary>
            <value>The quality value stored by this object.</value>

</doc>
<doc name="P:PeterO.Mail.StringAndQuality.Value">

            <summary>Gets the arbitrary string stored by this object.</summary>
            <value>The arbitrary string stored by this object.</value>

</doc>
<doc name="M:PeterO.Mail.Tokener.Compare(System.Int32[],System.Int32[])">
<summary>Compares one integer array with another.
    </summary>
    <param name='x'>An integer array.
    </param>
    <param name='y'>An integer array.
    </param>
    <returns>Zero if both values are equal; a negative number if
      <paramref name='x'/>
       is less than
      <paramref name='y'/>
       , or a positive number if
      <paramref name='x'/>
       is greater than
      <paramref name='y'/>
       .
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='x'/>
       or
      <paramref name='y'/>
       is null.
    </exception>
</doc>
<doc name="P:PeterO.Mail.Transforms.BoundaryCheckerTransform.HasNewBodyPart">

            <summary>Gets a value indicating whether a new body part was
            detected.</summary>
            <value><c>true</c> If a new body part was detected; otherwise, <c>false</c>.</value>

</doc>
<doc name="T:PeterO.Mail.URIUtility">
<summary>Contains auxiliary methods for processing Uniform Resource Identifiers
      (URIs) and Internationalized Resource Identifiers (IRIs) under RFC3986 and
      RFC3987, respectively. In the following documentation, URIs and IRIs
      include URI references and IRI references, for convenience.
    </summary>
</doc>
<doc name="T:PeterO.Mail.URIUtility.ParseMode">
<summary>Specifies whether certain characters are allowed when parsing IRIs and
      URIs.
    </summary>
</doc>
<doc name="F:PeterO.Mail.URIUtility.ParseMode.IRILenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Even with this mode, strings with unpaired surrogate code points are
      considered invalid.
    </summary>
</doc>
<doc name="F:PeterO.Mail.URIUtility.ParseMode.IRIStrict">
<summary>The rules follow the syntax for parsing IRIs. In particular, many code
      points outside the Basic Latin range (U+0000 to U+007F) are allowed.
      Strings with unpaired surrogate code points are considered invalid.
    </summary>
</doc>
<doc name="F:PeterO.Mail.URIUtility.ParseMode.IRISurrogateLenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Unpaired surrogate code points are treated as though they were replacement
      characters instead for the purposes of these rules, so that strings with
      those code points are not considered invalid strings.
    </summary>
</doc>
<doc name="F:PeterO.Mail.URIUtility.ParseMode.URILenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Code points outside the Basic Latin range (U+0000 to U+007F) are not
      allowed.
    </summary>
</doc>
<doc name="F:PeterO.Mail.URIUtility.ParseMode.URIStrict">
<summary>The rules follow the syntax for parsing IRIs, except that code points
      outside the Basic Latin range (U+0000 to U+007F) are not allowed.
    </summary>
</doc>
<doc name="M:PeterO.Mail.URIUtility.PercentDecode(System.String)">
<summary>Decodes percent-encoding (of the form "%XX" where X is a hexadecimal (base-16) digit) in the given string. Successive percent-encoded bytes are assumed
      to form characters in UTF-8.
    </summary>
    <param name='str'>A string that may contain percent encoding. May be null.
    </param>
    <returns>The string in which percent-encoding was decoded.
    </returns>
</doc>
<doc name="M:PeterO.Mail.URIUtility.PercentDecode(System.String,System.Int32,System.Int32)">
<summary>Decodes percent-encoding (of the form "%XX" where X is a hexadecimal (base-16) digit) in the given portion of a string. Successive percent-encoded bytes
      are assumed to form characters in UTF-8.
    </summary>
    <param name='str'>A string a portion of which may contain percent encoding. May be null.
    </param>
    <param name='index'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='endIndex'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       ends. The character before this index is the last character.
    </param>
    <returns>The portion of the given string in which percent-encoding was decoded.
      Returns null if
      <paramref name='str'/>
       is ull.
    </returns>
</doc>
<doc name="M:PeterO.Mail.URIUtility.escapeURI(System.String,System.Int32)">
<summary>Escapes characters that can't appear in URIs or IRIs. The function is
      idempotent; that is, calling the function again on the result with the
      same mode doesn't change the result.
    </summary>
    <param name='s'>A string to escape.
    </param>
    <param name='mode'>The parameter
      <paramref name='mode'/>
       is a 32-bit signed integer.
    </param>
    <returns>A string possibly containing escaped characters, or null if s is null.
    </returns>
</doc>
<doc name="M:PeterO.Mail.URIUtility.hasScheme(System.String)">
<summary>Determines whether the string is a valid IRI with a scheme component. This
      can be used to check for relative IRI references.
      <para>The following cases return true:
      </para>
      <code>xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid IRI with a scheme component; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Mail.URIUtility.hasSchemeForURI(System.String)">
<summary>Determines whether the string is a valid URI with a scheme component. This
      can be used to check for relative URI references. The following cases
      return true:
      <code>http://example/z xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid URI with a scheme component; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Mail.URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)">
<summary>Determines whether the substring is a valid CURIE reference under RDFA
      1.1. (The CURIE reference is the part after the colon.).
    </summary>
    <param name='s'>A string containing a CURIE reference. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The number of elements in the desired portion of "s" (but not more than
      "s" 's length).
    </param>
    <returns><c>true</c> if the substring is a valid CURIE reference under RDFA 1; otherwise, <c>false</c> . Returns false if
      <paramref name='s'/>
       is null.
    </returns>
    <exception cref='ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
</doc>
<doc name="M:PeterO.Mail.URIUtility.relativeResolve(System.String,System.String)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue. Example:
      <c>http://example.com/my/path/dir/file.txt</c> .
    </returns>
</doc>
<doc name="M:PeterO.Mail.URIUtility.relativeResolve(System.String,System.String,PeterO.Mail.URIUtility.ParseMode)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> . Can be null.
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue.
    </returns>
</doc>
<doc name="M:PeterO.Mail.URIUtility.splitIRI(System.String)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI reference is syntactically valid, splits the string
      into its components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. The
      scheme, authority, query, and fragment components, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
</doc>
<doc name="M:PeterO.Mail.URIUtility.splitIRI(System.String,PeterO.Mail.URIUtility.ParseMode)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI is syntactically valid, splits the string into its
      components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string representing an IRI. Can be null.
    </param>
    <param name='parseMode'>The parameter
      <paramref name='parseMode'/>
       is a ParseMode object.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. The
      scheme, authority, query, and fragment components, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
</doc>
<doc name="M:PeterO.Mail.URIUtility.splitIRI(System.String,System.Int32,System.Int32,PeterO.Mail.URIUtility.ParseMode)">
<summary>Parses a substring that represents an Internationalized Resource
      Identifier (IRI) under RFC3987. If the IRI is syntactically valid, splits
      the string into its components and returns an array containing the indices
      into the components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The length of the desired portion of "s" (but not more than "s" 's
      length).
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>If the string is a valid IRI, returns an array of 10 integers. Each of the
      five pairs corresponds to the start and end index of the IRI's scheme,
      authority, path, query, or fragment component, respectively. The scheme,
      authority, query, and fragment components, if present, will each be given
      without the ending colon, the starting "//", the starting "?", and the
      starting "#", respectively. If a component is absent, both indices in that
      pair will be -1 (an index won't be less than 0 in any other case). If the
      string is null or is not a valid IRI, returns null.
    </returns>
    <exception cref='ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
</doc>
<doc name="T:PeterO.Rdf.URIUtility">
<summary>Contains auxiliary methods for processing Uniform Resource Identifiers
      (URIs) and Internationalized Resource Identifiers (IRIs) under RFC3986 and
      RFC3987, respectively. In the following documentation, URIs and IRIs
      include URI references and IRI references, for convenience.
    </summary>
</doc>
<doc name="T:PeterO.Rdf.URIUtility.ParseMode">
<summary>Specifies whether certain characters are allowed when parsing IRIs and
      URIs.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.IRILenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Even with this mode, strings with unpaired surrogate code points are
      considered invalid.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.IRIStrict">
<summary>The rules follow the syntax for parsing IRIs. In particular, many code
      points outside the Basic Latin range (U+0000 to U+007F) are allowed.
      Strings with unpaired surrogate code points are considered invalid.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.IRISurrogateLenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Unpaired surrogate code points are treated as though they were replacement
      characters instead for the purposes of these rules, so that strings with
      those code points are not considered invalid strings.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.URILenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Code points outside the Basic Latin range (U+0000 to U+007F) are not
      allowed.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.URIStrict">
<summary>The rules follow the syntax for parsing IRIs, except that code points
      outside the Basic Latin range (U+0000 to U+007F) are not allowed.
    </summary>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.escapeURI(System.String,System.Int32)">
<returns>A string possibly containing escaped characters, or null if s is null.
    </returns>
    <summary>Escapes characters that cannot appear in URIs or IRIs. The function is
      idempotent; that is, calling the function again on the result with the
      same mode doesn't change the result.
    </summary>
    <param name='s'>A string to escape.
    </param>
    <param name='mode'>The parameter
      <paramref name='mode'/>
       is a 32-bit signed integer.
    </param>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.hasScheme(System.String)">
<summary>Determines whether the string is a valid IRI with a scheme component. This
      can be used to check for relative IRI references.
      <para>The following cases return true:
      </para>
      <code>xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid IRI with a scheme component; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.hasSchemeForURI(System.String)">
<summary>Determines whether the string is a valid URI with a scheme component. This
      can be used to check for relative URI references. The following cases
      return true:
      <code>http://example/z xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid URI with a scheme component; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)">
<summary>Determines whether the substring is a valid CURIE reference under RDFA
      1.1. (The CURIE reference is the part after the colon.).
    </summary>
    <param name='s'>A string containing a CURIE reference. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The number of elements in the desired portion of "s" (but not more than
      "s" 's length).
    </param>
    <returns><c>true</c> if the substring is a valid CURIE reference under RDFA 1; otherwise, <c>false</c> . Returns false if
      <paramref name='s'/>
       is null.
    </returns>
    <exception cref='ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       's length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.relativeResolve(System.String,System.String)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If base is null or is not a valid IRI,
      returns refValue. Example: http://example.com/my/path/dir/file.txt.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.relativeResolve(System.String,System.String,PeterO.Rdf.URIUtility.ParseMode)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If base is null or is not a valid IRI,
      returns refValue.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.splitIRI(System.String)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI reference is syntactically valid, splits the string
      into its components and returns an array containing the indices into the
      components.
      <returns>If the string is a valid IRI reference, returns an array of 10 integers.
        Each of the five pairs corresponds to the start and end index of the
        IRI's scheme, authority, path, query, or fragment component,
        respectively. If a component is absent, both indices in that pair will
        be -1. If the string is null or is not a valid IRI, returns null.
      </returns>
    </summary>
    <param name='s'>A string that contains an IRI.
    </param>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.splitIRI(System.String,PeterO.Rdf.URIUtility.ParseMode)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI is syntactically valid, splits the string into its
      components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string representing an IRI. Can be null.
    </param>
    <param name='parseMode'>The parameter
      <paramref name='parseMode'/>
       is a ParseMode object.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. If a
      component is absent, both indices in that pair will be -1. If the string
      is null or is not a valid IRI, returns null.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.splitIRI(System.String,System.Int32,System.Int32,PeterO.Rdf.URIUtility.ParseMode)">
<summary>Parses a substring that represents an Internationalized Resource
      Identifier (IRI) under RFC3987. If the IRI is syntactically valid, splits
      the string into its components and returns an array containing the indices
      into the components.
    </summary>
    <param name='s'>A string that contains an IRI.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The length of the desired portion of "s" (but not more than "s" 's
      length).
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>If the string is a valid IRI, returns an array of 10 integers. Each of the
      five pairs corresponds to the start and end index of the IRI's scheme,
      authority, path, query, or fragment component, respectively. If a
      component is absent, both indices in that pair will be -1 (an index won't
      be less than 0 in any other case). If the string is null or is not a valid
      IRI, returns null.
    </returns>
    <exception cref='ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       's length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Text.ByteData.DecompressLz4(System.Byte[])">

            <summary>Decompresses a byte array compressed using the LZ4 format
            (see "LZ4 Format Description" by Y Collet for more
            information).</summary>
            <param name='input'>Input byte array.</param>
            <returns>Decompressed output byte array.</returns>
            <exception cref='ArgumentNullException'>The parameter "output" is
            null.</exception>
            <exception cref='ArgumentException'>Invalid LZ4.</exception>

</doc>
<doc name="T:PeterO.Text.DomainUtility">
<summary>An auxiliary method for domain names.
    </summary>
</doc>
<doc name="M:PeterO.Text.DomainUtility.PunycodeLength(System.String,System.Int32,System.Int32)">
<summary>Gets the Punycode length of a string (Punycode is defined in RFC 3492).
    </summary>
    <param name='str'>A string containing the desired portion to get the length for.
    </param>
    <param name='index'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='endIndex'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       ends. The character before this index is the last character.
    </param>
    <returns>The Punycode length of the encoded string. If the string contains code
      points outside the Basic Latin range (U+0000 to U+007F), returns the
      Punycode length plus 4 (the length of the prefix "xn--", which usually
      indicates an internationalized domain name). If there are only Basic Latin
      code points, returns the length of the string. Returns -1 if an overflow
      error occurs.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <exception cref='ArgumentNullException'>Either
      <paramref name='index'/>
       or
      <paramref name='endIndex'/>
       is less than 0 or greater than
      <paramref name='str'/>
       's length, or
      <paramref name='index'/>
       is greater than
      <paramref name='endIndex'/>
       .
    </exception>
</doc>
<doc name="T:PeterO.Text.Idna">

            <summary><para>Contains methods that implement Internationalized Domain
            Names in Applications (IDNA). IDNA enables using a wider range of
            letters, numbers, and certain other characters in domain names.
            This class implements the 2008 revision of IDNA, also known as
            IDNA2008.</para>
            <para>The following summarizes the rules for domain names in
            IDNA2008; see RFC5890 for more information and additional
            terminology.</para>
            <para>A domain name is divided into one or more strings separated
            by dots ("."), called <b>labels</b>. For IDNA2008's purposes, a
            valid label can be an <b>NR-LDH label</b>, an <b>A-label</b>, or
            a <b>U-label</b>.</para>
            <para>An LDH label contains only basic uppercase letters, basic
            lowercase letters, basic digits, and/or "-", and neither begins nor
            ends with "-". For example, "exa-mple", "EXAMPLE", and "1example"
            are LDH labels, but not "-example".</para>
            <para>An NR-LDH label is an LDH label whose third and fourth
            characters are not both "-". For example, "ex--ample" is not an
            NR-LDH label.</para>
            <para>A U-label contains one or more characters outside the Basic
            Latin range (U+0000 to U+007F) and meets IDNA2008 requirements for
            labels with such characters. An example is "eá".</para>
            <para>An A-label is an LDH label beginning with "xn--" where the
            letters can be any combination of basic uppercase and basic lowercase letters, and is convertible to a U-label. An example is
            "xn--e-ufa".</para>
            <para>An XN-label is an LDH label beginning with "xn--" where the
            letters can be any combination of basic uppercase and basic lowercase letters.</para>
            <para>NOTICE: While this class's source code is in the public
            domain, the class uses two internal classes, called
            <c>NormalizationData</c> and <c>IdnaData</c>, that include data
            derived from the Unicode Character Database. See the documentation
            for the NormalizerInput class for the permission notice for the
            Unicode Character Database.</para></summary>

</doc>
<doc name="M:PeterO.Text.Idna.DecodeDomainName(System.String)">

            <summary>Tries to encode each XN-label of the given domain name
            into Unicode. This method does not check the syntactic validity of
            the domain name before proceeding.</summary>
            <param name='value'>A domain name.</param>
            <returns>The domain name where each XN-label is encoded into
            Unicode. Labels where this is not possible remain
            unchanged.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='value'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.Idna.DecodeDomainName(System.String,System.Boolean)">
<summary>Tries to encode each XN-label of the given domain name into Unicode. This
      method does not check the syntactic validity of the domain name before
      proceeding.
    </summary>
    <param name='value'>A domain name.
    </param>
    <returns>The domain name where each XN-label is encoded into Unicode. Labels where
      this is not possible remain unchanged.
    </returns>
    <exception cref='ArgumentNullException'>value" is null.
    </exception>
</doc>
<doc name="M:PeterO.Text.Idna.EncodeDomainName(System.String)">

            <summary>Tries to encode each label of a domain name with code
            points outside the Basic Latin range (U+0000 to U+007F) into an
            XN-label. This method does not check the syntactic validity of the
            domain name before proceeding.</summary>
            <param name='value'>A domain name.</param>
            <returns>The domain name where each label with code points outside
            the Basic Latin range (U+0000 to U+007F) is encoded into an
            XN-label. Labels where this is not possible remain
            unchanged.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='value'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.Idna.IsValidDomainName(System.String,System.Boolean)">

            <summary>Determines whether the given string is a domain name
            containing only U-labels, A-labels, NR-LDH labels, or any
            combination of these, separated by dots (".").</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='lookupRules'>If true, uses rules to apply when looking
            up the string as a domain name. If false, uses rules to apply when
            registering the string as a domain name.</param>
            <returns><c>true</c> if the given string is a syntactically valid
            domain name; otherwise; false.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="T:PeterO.Text.Normalization">

            <summary>Represents a Unicode normalization form.</summary>

</doc>
<doc name="F:PeterO.Text.Normalization.NFC">

            <summary>Normalization form C: canonical decomposition followed by
            canonical composition.</summary>

</doc>
<doc name="F:PeterO.Text.Normalization.NFD">

            <summary>Normalization form D: canonical decomposition.</summary>

</doc>
<doc name="F:PeterO.Text.Normalization.NFKC">

            <summary>Normalization form KC: compatibility decomposition
            followed by canonical composition.</summary>

</doc>
<doc name="F:PeterO.Text.Normalization.NFKD">

            <summary>Normalization form KD: compatibility
            decomposition.</summary>

</doc>
<doc name="T:PeterO.Text.Normalizer">

            <summary><para>Implements the Unicode normalization algorithm and contains
            methods and functionality to test and convert Unicode strings for
            Unicode normalization.</para>
            <para>NOTICE: While this class's source code is in the public
            domain, the class uses an internal class, called NormalizationData,
            that includes data derived from the Unicode Character Database. See
            the documentation for the NormalizerInput class for the permission
            notice for the Unicode Character Database.</para></summary>

</doc>
<doc name="M:PeterO.Text.Normalizer.#ctor(System.String,PeterO.Text.Normalization)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Text.Normalizer'/> class.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='form'>The parameter <paramref name='form'/> is a
            Normalization object.</param>

</doc>
<doc name="M:PeterO.Text.Normalizer.IsNormalized(System.String,PeterO.Text.Normalization)">

            <summary>Returns whether this string is normalized.</summary>
            <param name='str'>The string to check.</param>
            <param name='form'>The parameter <paramref name='form'/> is a
            Normalization object.</param>
            <returns><c>true</c> if this string is normalized; otherwise, <c>false</c>. Returns <c>false</c> if the string contains an
            unpaired surrogate code point.</returns>

</doc>
<doc name="M:PeterO.Text.Normalizer.Normalize(System.String,PeterO.Text.Normalization)">

            <summary>Converts a string to the given Unicode normalization
            form.</summary>
            <param name='str'>An arbitrary string.</param>
            <param name='form'>The Unicode normalization form to convert
            to.</param>
            <returns>The parameter <paramref name='str'/> converted to the
            given normalization form.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.Normalizer.Read(System.Int32[],System.Int32,System.Int32)">

            <summary>Reads a sequence of Unicode code points from a data
            source.</summary>
            <param name='chars'>Output buffer.</param>
            <param name='index'>Index in the output buffer to start writing
            to.</param>
            <param name='length'>Maximum number of code points to
            write.</param>
            <returns>The number of Unicode code points read, or 0 if the end of
            the source is reached.</returns>
            <exception cref='ArgumentException'>Either <paramref name='index'/>
            or <paramref name='length'/> is less than 0 or greater than
            <paramref name='chars'/> 's length, or <paramref name='chars'/> 's
            length minus <paramref name='index'/> is less than <paramref name='length'/>.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='chars'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.Normalizer.ReadChar">

            <summary>Reads a Unicode character from a data source.</summary>
            <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000
            to 0x10ffff), or the value -1 indicating the end of the
            source.</returns>

</doc>
<doc name="T:PeterO.Text.NormalizerInput">

            <summary><para>A character input class that implements the Unicode
            normalization algorithm and contains methods and functionality to
            test and convert text strings for normalization. This is similar to
            the deprecated Normalizer class, except it implements the
            ICharacterInput interface.</para>
            <para>The Unicode Standard includes characters, such as an acute
            accent, that can be combined with other characters to make new
            characters. For example, the letter E combines with an acute accent
            to make E-acute (É). In some cases, the combined form (E-acute)
            should be treated as equivalent to the uncombined form (E plus
            acute). Therefore, the standard defines four
            <i>normalization forms</i> that convert strings to a single
            equivalent form:</para>
            <list>
            <item><b>NFD</b> (Normalization Form D) decomposes combined forms
            to their constituent characters (E plus acute, for example), then
            reorders combining marks to a standardized order. This is called
            canonical decomposition.</item>
            <item><b>NFC</b> does canonical decomposition, then combines
            certain constituent characters to their composites (E-acute, for
            example). This is called canonical composition.</item>
            <item>Two normalization forms, <b>NFKC</b> and <b>NFKD</b>, are
            similar to NFC and NFD, except they also "decompose" certain
            characters, such as ligatures, font or positional variants, and
            subscripts, whose visual distinction can matter in some contexts.
            This is called compatibility decomposition.</item></list>
            <para>For more information, see Standard Annex 15 at
            <c>http://www.unicode.org/reports/tr15/</c>.</para>
            <para><b>Thread safety:</b> This class is mutable; its properties
            can be changed. None of its instance methods are designed to be
            thread safe. Therefore, access to objects from this class must be
            synchronized if multiple threads can access them at the same
            time.</para>
            <para>NOTICE: While this class's source code is in the public
            domain, the class uses an internal class, called NormalizationData,
            that includes data derived from the Unicode Character Database. In
            case doing so is required, the permission notice for the Unicode
            Character Database is given here:</para>
            <para>COPYRIGHT AND PERMISSION NOTICE.</para>
            <para>Copyright (c) 1991-2014 Unicode, Inc. All rights reserved.
            Distributed under the Terms of Use in
            http://www.unicode.org/copyright.html.</para>
            <para>Permission is hereby granted, free of charge, to any person
            obtaining a copy of the Unicode data files and any associated
            documentation (the "Data Files") or Unicode software and any
            associated documentation (the "Software") to deal in the Data Files
            or Software without restriction, including without limitation the
            rights to use, copy, modify, merge, publish, distribute, and/or
            sell copies of the Data Files or Software, and to permit persons to
            whom the Data Files or Software are furnished to do so, provided
            that (a) this copyright and permission notice appear with all
            copies of the Data Files or Software, (b) this copyright and
            permission notice appear in associated documentation, and (c) there
            is clear notice in each modified Data File or in the Software as
            well as in the documentation associated with the Data File(s) or
            Software that the data or software has been modified.</para>
            <para>THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT
            WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
            TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
            PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT
            SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE
            LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL
            DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
            OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
            TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
            PERFORMANCE OF THE DATA FILES OR SOFTWARE.</para>
            <para>Except as contained in this notice, the name of a copyright
            holder shall not be used in advertising or otherwise to promote the
            sale, use or other dealings in these Data Files or Software without
            prior written authorization of the copyright
            holder.</para></summary>

</doc>
<doc name="M:PeterO.Text.NormalizerInput.#ctor(PeterO.Text.ICharacterInput)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Text.NormalizerInput'/> class using Normalization
            Form C.</summary>
            <param name='input'>The parameter <paramref name='input'/> is an
            ICharacterInput object.</param>

</doc>
<doc name="M:PeterO.Text.NormalizerInput.#ctor(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Text.NormalizerInput'/> class.</summary>
            <param name='stream'>The parameter <paramref name='stream'/> is an
            ICharacterInput object.</param>
            <param name='form'>Specifies the normalization form to use when
            normalizing the text.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizerInput.#ctor(System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Text.NormalizerInput'/> class using Normalization
            Form C.</summary>
            <param name='str'>A string specifying the text to
            normalize.</param>

</doc>
<doc name="M:PeterO.Text.NormalizerInput.#ctor(System.String,PeterO.Text.Normalization)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Text.NormalizerInput'/> class.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='form'>Specifies the normalization form to use when
            normalizing the text.</param>

</doc>
<doc name="M:PeterO.Text.NormalizerInput.#ctor(System.String,System.Int32,System.Int32,PeterO.Text.Normalization)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Text.NormalizerInput'/> class. Uses a portion of
            a string as the input.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='index'>An index starting at 0 showing where the
            desired portion of <paramref name='str'/> begins.</param>
            <param name='length'>The number of elements in the desired portion
            of <paramref name='str'/> (but not more than <paramref name='str'/>
            's length).</param>
            <param name='form'>Specifies the normalization form to use when
            normalizing the text.</param>
            <exception cref='ArgumentException'>Either <paramref name='index'/>
            or <paramref name='length'/> is less than 0 or greater than
            <paramref name='str'/> 's length, or <paramref name='str'/> 's
            length minus <paramref name='index'/> is less than <paramref name='length'/>.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizerInput.IsNormalized(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)">

            <summary>Determines whether the text provided by a character input
            is normalized.</summary>
            <param name='chars'>A object that implements a streamable character
            input.</param>
            <param name='form'>Specifies the normalization form to
            check.</param>
            <returns><c>true</c> if the text is normalized; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='chars'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizerInput.IsNormalized(System.String,PeterO.Text.Normalization)">

            <summary>Determines whether the given string is in the given
            Unicode normalization form.</summary>
            <param name='str'>An arbitrary string.</param>
            <param name='form'>Specifies the normalization form to use when
            normalizing the text.</param>
            <returns><c>true</c> if the given string is in the given Unicode
            normalization form; otherwise, <c>false</c>. Returns <c>false</c> if the string contains an unpaired surrogate code point.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizerInput.Normalize(System.String,PeterO.Text.Normalization)">

            <summary>Converts a string to the given Unicode normalization
            form.</summary>
            <param name='str'>An arbitrary string.</param>
            <param name='form'>The Unicode normalization form to convert
            to.</param>
            <returns>The parameter <paramref name='str'/> converted to the
            given normalization form.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='str'/> contains an unpaired surrogate code point.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizerInput.Read(System.Int32[],System.Int32,System.Int32)">

            <summary>Reads a sequence of Unicode code points from a data
            source.</summary>
            <param name='chars'>Output buffer.</param>
            <param name='index'>An index starting at 0 showing where the
            desired portion of <paramref name='chars'/> begins.</param>
            <param name='length'>The number of elements in the desired portion
            of <paramref name='chars'/> (but not more than <paramref name='chars'/> 's length).</param>
            <returns>The number of Unicode code points read, or 0 if the end of
            the source is reached.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='chars'/> is null.</exception>
            <exception cref='ArgumentException'>Either <paramref name='index'/>
            or <paramref name='length'/> is less than 0 or greater than
            <paramref name='chars'/> 's length, or <paramref name='chars'/> 's
            length minus <paramref name='index'/> is less than <paramref name='length'/>.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizerInput.ReadChar">

            <summary>Reads a Unicode character from a data source.</summary>
            <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000
            to 0x10ffff), or the value -1 indicating the end of the
            source.</returns>

</doc>
<doc name="T:PeterO.Text.NormalizingCharacterInput">

            <summary><para>A character input class that implements the Unicode
            normalization algorithm and contains methods and functionality to
            test and convert text strings for normalization. This is similar to
            the deprecated Normalizer class, except it implements the
            ICharacterInput interface.</para>
            <list>
            <item><b>NFD</b> (Normalization Form D) decomposes combined forms
            to their constituent characters (E plus acute, for example), then
            reorders combining marks to a standardized order. This is called
            canonical decomposition.</item>
            <item><b>NFC</b> does canonical decomposition, then combines
            certain constituent characters to their composites (E-acute, for
            example). This is called canonical composition.</item>
            <item>Two normalization forms, <b>NFKC</b> and <b>NFKD</b>, are
            similar to NFC and NFD, except they also "decompose" certain
            characters, such as ligatures, font or positional variants, and
            subscripts, whose visual distinction can matter in some contexts.
            This is called compatibility decomposition.</item></list>
            <para>For more information, see Standard Annex 15 at
            <c>http://www.unicode.org/reports/tr15/</c>.</para>
            <para><b>Thread safety:</b> This class is mutable; its properties
            can be changed. None of its instance methods are designed to be
            thread safe. Therefore, access to objects from this class must be
            synchronized if multiple threads can access them at the same
            time.</para>
            <para>NOTICE: While this class's source code is in the public
            domain, the class uses an internal class, called NormalizationData,
            that includes data derived from the Unicode Character Database. In
            case doing so is required, the permission notice for the Unicode
            Character Database is given here:</para>
            <para>COPYRIGHT AND PERMISSION NOTICE.</para>
            <para>Copyright (c) 1991-2014 Unicode, Inc. All rights reserved.
            Distributed under the Terms of Use in
            http://www.unicode.org/copyright.html.</para>
            <para>Permission is hereby granted, free of charge, to any person
            obtaining a copy of the Unicode data files and any associated
            documentation (the "Data Files") or Unicode software and any
            associated documentation (the "Software") to deal in the Data Files
            or Software without restriction, including without limitation the
            rights to use, copy, modify, merge, publish, distribute, and/or
            sell copies of the Data Files or Software, and to permit persons to
            whom the Data Files or Software are furnished to do so, provided
            that (a) this copyright and permission notice appear with all
            copies of the Data Files or Software, (b) this copyright and
            permission notice appear in associated documentation, and (c) there
            is clear notice in each modified Data File or in the Software as
            well as in the documentation associated with the Data File(s) or
            Software that the data or software has been modified.</para>
            <para>THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT
            WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
            TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
            PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT
            SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE
            LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL
            DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
            OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
            TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
            PERFORMANCE OF THE DATA FILES OR SOFTWARE.</para>
            <para>Except as contained in this notice, the name of a copyright
            holder shall not be used in advertising or otherwise to promote the
            sale, use or other dealings in these Data Files or Software without
            prior written authorization of the copyright
            holder.</para></summary>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.#ctor(PeterO.Text.ICharacterInput)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Text.NormalizingCharacterInput'/>
            class.</summary>
            <param name='input'>The parameter <paramref name='input'/> is an
            ICharacterInput object.</param>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.#ctor(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Text.NormalizingCharacterInput'/>
            class.</summary>
            <param name='stream'>The parameter <paramref name='stream'/> is an
            ICharacterInput object.</param>
            <param name='form'>The parameter <paramref name='form'/> is a
            Normalization object.</param>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.#ctor(System.Collections.Generic.IList{System.Int32})">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Text.NormalizingCharacterInput'/>
            class.</summary>
            <param name='characterList'>The parameter <paramref name='characterList'/> is an IList object.</param>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.#ctor(System.Collections.Generic.IList{System.Int32},PeterO.Text.Normalization)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Text.NormalizingCharacterInput'/>
            class.</summary>
            <param name='characterList'>The parameter <paramref name='characterList'/> is an IList object.</param>
            <param name='form'>The parameter <paramref name='form'/> is a
            Normalization object.</param>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.#ctor(System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Text.NormalizingCharacterInput'/>
            class.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.#ctor(System.String,PeterO.Text.Normalization)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Text.NormalizingCharacterInput'/>
            class.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='form'>The parameter <paramref name='form'/> is a
            Normalization object.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.#ctor(System.String,System.Int32,System.Int32,PeterO.Text.Normalization)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Text.NormalizingCharacterInput'/>
            class.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='index'>An index, starting at 0, showing where the
            desired portion of <paramref name='str'/> begins.</param>
            <param name='length'>The length, in code units, of the desired
            portion of <paramref name='str'/> (but not more than <paramref name='str'/> 's length).</param>
            <param name='form'>The parameter <paramref name='form'/> is a
            Normalization object.</param>
            <exception cref='ArgumentException'>Either <paramref name='index'/>
            or <paramref name='length'/> is less than 0 or greater than
            <paramref name='str'/> 's length, or <paramref name='str'/> 's
            length minus <paramref name='index'/> is less than <paramref name='length'/>.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.GetChars(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)">

            <summary>Gets a list of normalized code points after reading from a
            character stream.</summary>
            <param name='chars'>An object that implements a stream of Unicode
            characters.</param>
            <param name='form'>Specifies the normalization form to use when
            normalizing the text.</param>
            <returns>A list of the normalized Unicode characters.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='chars'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.GetChars(System.String,PeterO.Text.Normalization)">

            <summary>Gets a list of normalized code points after reading from a
            string.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='form'>Specifies the normalization form to use when
            normalizing the text.</param>
            <returns>A list of the normalized Unicode characters.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.IsNormalized(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)">

            <summary>Determines whether the text provided by a character input
            is normalized.</summary>
            <param name='chars'>A object that implements a streamable character
            input.</param>
            <param name='form'>Specifies the normalization form to
            check.</param>
            <returns><c>true</c> if the text is normalized; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='chars'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.IsNormalized(System.Collections.Generic.IList{System.Int32},PeterO.Text.Normalization)">

            <summary>Determines whether the given list of characters is in the
            given Unicode normalization form.</summary>
            <param name='charList'>A list of Unicode code points.</param>
            <param name='form'>Specifies the normalization form to use when
            normalizing the text.</param>
            <returns><c>true</c> if the given list of characters is in the
            given Unicode normalization form; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='charList'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.IsNormalized(System.Int32[],PeterO.Text.Normalization)">

            <summary>Determines whether the given array of characters is in the
            given Unicode normalization form.</summary>
            <param name='charArray'>An array of Unicode code points.</param>
            <param name='form'>Specifies the normalization form to use when
            normalizing the text.</param>
            <returns><c>true</c> if the given list of characters is in the
            given Unicode normalization form; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter "charList" is
            null.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.IsNormalized(System.String,PeterO.Text.Normalization)">

            <summary>Determines whether the given string is in the given
            Unicode normalization form.</summary>
            <param name='str'>An arbitrary string.</param>
            <param name='form'>Specifies the normalization form to use when
            normalizing the text.</param>
            <returns><c>true</c> if the given string is in the given Unicode
            normalization form; otherwise, <c>false</c>. Returns <c>false</c> if the string contains an unpaired surrogate code point.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.Normalize(System.String,PeterO.Text.Normalization)">

            <summary>Converts a string to the given Unicode normalization
            form.</summary>
            <param name='str'>An arbitrary string.</param>
            <param name='form'>The Unicode normalization form to convert
            to.</param>
            <returns>The parameter <paramref name='str'/> converted to the
            given normalization form.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='str'/> contains an unpaired surrogate code point.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.Read(System.Int32[],System.Int32,System.Int32)">

            <summary>Reads a sequence of Unicode code points from a data
            source.</summary>
            <param name='chars'>Output buffer.</param>
            <param name='index'>An index starting at 0 showing where the
            desired portion of <paramref name='chars'/> begins.</param>
            <param name='length'>The number of elements in the desired portion
            of <paramref name='chars'/> (but not more than <paramref name='chars'/> 's length).</param>
            <returns>The number of Unicode code points read, or 0 if the end of
            the source is reached.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='chars'/> is null.</exception>
            <exception cref='ArgumentException'>Either <paramref name='index'/>
            or <paramref name='length'/> is less than 0 or greater than
            <paramref name='chars'/> 's length, or <paramref name='chars'/> 's
            length minus <paramref name='index'/> is less than <paramref name='length'/>.</exception>

</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.ReadChar">

            <summary>Reads a Unicode character from a data source.</summary>
            <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000
            to 0x10ffff), or the value -1 indicating the end of the
            source.</returns>

</doc>
<doc name="T:PeterO.Text.ProtocolStrings">

            <summary><para>Contains methods for preparing user-facing protocol strings
            (such as user identifiers) for equality comparison and validity
            checking. Such strings can be _internationalized_, that is, contain
            characters beyond the Basic Latin block (U+0000 to U+007F) of the
            Unicode Standard. See RFC 8264. Currently there are four profiles
            for internationalized strings: two for strings serving as user
            identifiers, one for arbitrary single-line strings (such as
            passwords), and one for display names.</para></summary>
            <remarks>
            <list>
            <item>Other user-facing internationalized strings not expressly
            handled by this class include the following. Their preparation and
            comparison are outside the scope of this class.
            <br/> -- File and directory names.
            <br/> -- Domain names.
            <br/> -- Text strings with multiple language versions (such as a
            checkbox's label or a dialog box's title).
            <br/> -- Profile data voluntarily entered by users.
            <br/> -- The text of article, post, and message bodies.</item>
            <item>The methods in this class are not well suited for
            <i>collation</i>, or lexicographic ordering, which is a comparison
            of text strings that is usually language-dependent and goes beyond
            equality comparison. Further discussion on collation can be found
            in Unicode Technical Standard 10 (UTS 10), "Unicode Collation
            Algorithm".</item>
            <item>As explained in UTS 10 sec. 1.6, collation serves the
            purposes of searching and selection (for example, searches by name or by
            title). However, this class is directed more to equality
            comparisons for authentication or authorization purposes, or to
            avoid creating multiple items that use the same string, rather
            than, say, to comparisons of names or parts of names for the
            purpose of showing matching records.</item></list>
            <para><b>Security Considerations</b></para>
            <para>Many of the methods in this class take text strings and
            output text strings. However, specifying text strings as these
            methods do is not ideal if the string represents a password or
            other sensitive data, since strings are immutable in.NET and Java,
            so that they can't be modified, and the memory they occupy is not
            guaranteed to be cleared in a timely fashion due to garbage
            collection.</para>
            <para>The methods in this class are not guaranteed to be
            "constant-time" (nondata-dependent) for all relevant inputs.
            Neither are string comparison methods (such as String.Equals)
            necessarily guaranteed to be "constant-time". Certain attacks that
            involve encrypted communications have exploited the timing and
            other aspects of such communications to derive keying material or
            cleartext indirectly, or for example, to leak information about
            whether a user name and password were accepted by the server, or
            whether a user name or display name was already taken. This is an
            important consideration especially for strings representing account
            identifiers or passwords, even when comparing two such strings of
            the same length.</para></remarks>

</doc>
<doc name="M:PeterO.Text.ProtocolStrings.IsInFreeformClass(System.String)">

            <summary>Determines whether the given string belongs in RFC 8264's
            FreeformClass. In general, the FreeformClass contains most letters,
            digits, spaces, punctuation, and symbols in the Unicode standard,
            as well as all basic printable characters (U+0021 to U+007E), but
            excludes control characters and separators. Horizontal tab, U+0009,
            and other code points in the range U+0000 to U+001F, are among the
            excluded characters.</summary>
            <param name='str'>A string to check.</param>
            <returns><c>true</c> if the given string is empty or contains only
            characters allowed in RFC 8264's FreeformClass (in the contexts
            required); otherwise, <c>false</c>. Returns <c>false</c> if
            <paramref name='str'/> is null.</returns>

</doc>
<doc name="M:PeterO.Text.ProtocolStrings.IsInIdentifierClass(System.String)">

            <summary>Determines whether the given string belongs in RFC 8264's
            IdentifierClass. In general, the IdentifierClass contains all code
            points in the FreeformClass, except certain uncommon letters and
            digits, spaces, as well as punctuation and symbols outside the
            Basic Latin range (U+0000 to U+007F).</summary>
            <param name='str'>A string to check.</param>
            <returns><c>true</c> if the given string is empty or contains only
            characters allowed in RFC 8264's IdentifierClass (in the contexts
            required); otherwise, <c>false</c>. Returns <c>false</c> if
            <paramref name='str'/> is null.</returns>

</doc>
<doc name="M:PeterO.Text.ProtocolStrings.NicknameEnforce(System.String)">

            <summary>Checks the validity of a string serving as a "memorable,
            human-friendly name" for something (see RFC 8266), as opposed to
            that thing's identity for authentication or authorization purposes
            (see sec. 6.1 of that RFC). This checking is done using the
            Nickname profile in RFC 8266. Such names are not intended to serve
            as URIs or file paths (see sec. 6.1 of that RFC).</summary>
            <param name='str'>A string serving as a nickname for
            something.</param>
            <returns>A nickname prepared for enforcement under the Nickname
            profile in RFC 8266. Returns null if that string is invalid under
            that profile (including if <paramref name='str'/> is null or
            empty). Return values of this method should not be used for
            comparison purposes (see RFC 8266, sec. 2.3); for such purposes,
            use the NicknameForComparison method instead.</returns>

</doc>
<doc name="M:PeterO.Text.ProtocolStrings.NicknameForComparison(System.String)">

            <summary>Prepares for comparison a string serving as a "memorable,
            human-friendly name" for something (see RFC 8266), as opposed to
            that thing's identity for authentication or authorization purposes
            (see sec. 6.1 of that RFC). This operation is done using the
            Nickname profile in RFC 8266. Such names are not intended to serve
            as URIs or file paths (see sec. 6.1 of that RFC).</summary>
            <param name='str'>A string serving as a nickname for
            something.</param>
            <returns>A nickname prepared for comparison under the Nickname
            profile in RFC 8266. Returns null if that string is invalid under
            that profile (including if <paramref name='str'/> is null or
            empty). For comparison purposes, return values of this method
            should be compared code point by code point (see RFC 8266, sec.
            2.4).</returns>

</doc>
<doc name="M:PeterO.Text.ProtocolStrings.OpaqueStringEnforce(System.String)">

            <summary>Checks the validity of a string serving as an arbitrary
            single-line sequence of characters, such as a passphrase. This
            checking is done using the OpaqueString profile in RFC
            8265.</summary>
            <param name='str'>A string to prepare that represents an arbitrary
            single-line sequence of characters entered by a user.</param>
            <returns>A string prepared under the OpaqueString profile in RFC
            8265. Returns null if that string is invalid under that profile
            (including if <paramref name='str'/> is null or empty). For
            comparison purposes, return values of this method should be
            compared code point by code point (see RFC 8265, sec.
            4.2.3).</returns>

</doc>
<doc name="M:PeterO.Text.ProtocolStrings.UsernameEnforce(System.String)">

            <summary>Checks the validity of a string that can serve to identify
            a user or account (a "username"), where the string is made of one
            or more parts called "userparts" separated by spaces (U+0020) and
            where the case of letters in the string is mapped to lowercase.
            This checking is done using the UsernameCaseMapped profile in RFC
            8265.</summary>
            <param name='str'>A string to prepare that represents a user or
            account identifier.</param>
            <returns>A username where each of its parts is prepared under the
            UsernameCaseMapped profile in RFC 8265 (among other things, the
            string will be converted to lowercase). Returns null if any of
            those parts is invalid under that profile (including if <paramref name='str'/> is null or empty). Note that there will be as many
            spaces of separation between parts of the return value as between
            parts of the input; this method will not collapse multiple spaces
            (U+0020) into a single space. If such space collapsing on a string
            (or rejection of strings with multiple consecutive spaces) is
            desired, it should be done before that string is passed to this
            method. For comparison purposes, return values of this method
            should be compared code point by code point (see RFC 8265, sec.
            3.3.4).</returns>

</doc>
<doc name="M:PeterO.Text.ProtocolStrings.UsernameEnforce(System.String,System.Boolean)">

            <summary>Checks the validity of a string that can serve to identify
            a user or account (a "username"), where the string is made of one
            or more parts called "userparts" separated by spaces (U+0020) and
            where the case of letters in the string is either mapped to
            lowercase or preserved. This checking is done using the
            UsernameCaseMapped or UsernameCasePreserved profile in RFC
            8265.</summary>
            <param name='str'>A string to prepare that represents a user or
            account identifier.</param>
            <param name='preserveCase'>If true, use the UsernameCasePreserved
            profile to prepare each part of the string. If false, use the
            UsernameCaseMapped profile.</param>
            <returns>A username where each of its parts is prepared under the
            UsernameCaseMapped or UsernameCasePreserved profile in RFC 8265.
            Returns null if any of those parts is invalid under that profile
            (including if <paramref name='str'/> is null or empty). Note that
            there will be as many spaces of separation between parts of the
            return value as between parts of the input; this method will not
            collapse multiple spaces (U+0020) into a single space. If such
            space collapsing on a string (or rejection of strings with multiple
            consecutive spaces) is desired, it should be done before that
            string is passed to this method. For comparison purposes, return
            values of this method (with the same value for <paramref name='preserveCase'/> ) should be compared code point by code point
            (see RFC 8265, secs. 3.3.4 and 3.4.4).</returns>

</doc>
<doc name="M:PeterO.Text.ProtocolStrings.UserpartEnforce(System.String)">

            <summary>Checks the validity of a string without spaces that can
            serve to identify a user or account (a "userpart"), where the case
            of letters in the string is mapped to lowercase. This checking is
            done using the UsernameCaseMapped profile in RFC 8265.</summary>
            <param name='str'>A string to prepare that represents a user or
            account identifier.</param>
            <returns>A userpart prepared under the UsernameCaseMapped profile
            in RFC 8265 (among other things, the string will be converted to
            lowercase). Returns null if <paramref name='str'/> is invalid under
            that profile (including if <paramref name='str'/> is null or
            empty). For comparison purposes, return values of this method
            should be compared code point by code point (see RFC 8265, sec.
            3.3.4).</returns>

</doc>
<doc name="M:PeterO.Text.ProtocolStrings.UserpartEnforce(System.String,System.Boolean)">

            <summary>Checks the validity of a string without spaces that can
            serve to identify a user or account (a "userpart"), where the case
            of letters in the string is either mapped to lowercase or
            preserved. This checking is done using the UsernameCaseMapped or
            UsernameCasePreserved profile in RFC 8265.</summary>
            <param name='str'>A string to prepare that represents a user or
            account identifier.</param>
            <param name='preserveCase'>If true, use the UsernameCasePreserved
            profile to prepare the string. If false, use the UsernameCaseMapped
            profile.</param>
            <returns>A userpart prepared under the UsernameCaseMapped or
            UsernameCasePreserved profile in RFC 8265. Returns null if
            <paramref name='str'/> is invalid under that profile (including if
            <paramref name='str'/> is null or empty). For comparison purposes,
            return values of this method (with the same value for <paramref name='preserveCase'/> ) should be compared code point by code point
            (see RFC 8265, secs. 3.3.4 and 3.4.4).</returns>

</doc>
</docs>
