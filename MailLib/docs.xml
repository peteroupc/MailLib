<docs>
  <doc name='T:PeterO.ArrayWriter'>
    <summary>An array of bytes that grows as needed.
    </summary>
  </doc>
  <doc name='M:PeterO.ArrayWriter.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='ArrayWriter'/>
       class with a default buffer size.
    </summary>
  </doc>
  <doc name='M:PeterO.ArrayWriter.#ctor(System.Int32)'>
    <summary>Initializes a new instance of the
      <see cref='ArrayWriter'/>
       class with the given initial buffer size.
    </summary>
    <param name='initialSize'>The parameter
      <paramref name='initialSize'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.ArrayWriter.Clear'>
    <summary>Offers a fast way to reset the length of the array writer's data to 0.
    </summary>
  </doc>
  <doc name='M:PeterO.ArrayWriter.ToArray'>
    <summary>Generates an array of all bytes written so far to it.
    </summary>
    <returns>A byte array.
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayWriter.Write(System.Byte[],System.Int32,System.Int32)'>
    <summary>Writes a series of bytes to the array.
    </summary>
    <param name='src'>Byte array containing the data to write.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='src'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='src'/>
       (but not more than
      <paramref name='src'/>
       's length).
    </param>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='src'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='src'/>
       's length, or
      <paramref name='src'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.ArrayWriter.WriteByte(System.Int32)'>
    <summary>Writes an 8-bit byte to the array.
    </summary>
    <param name='byteValue'>An integer containing the byte to write. Only the lower 8 bits of this
      value will be used.
    </param>
  </doc>
  <doc name='T:PeterO.Cbor.CBORDataUtilities'>
    <summary>Contains methods useful for reading and writing data, with a focus on
      CBOR.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String)'>
    <summary>Parses a number whose format follows the JSON specification. See
      #ParseJSONNumber(String, integersOnly, parseOnly) for more information.
    </summary>
    <param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param>
    <returns>A CBOR object that represents the parsed number. Returns positive zero if
      the number is a zero that starts with a minus sign (such as "-0" or
      "-0.0"). Returns null if the parsing fails, including if the string is
      null or empty.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean)'>
    <summary>Parses a number whose format follows the JSON specification (RFC 8259).
      Roughly speaking, a valid number consists of an optional minus sign, one
      or more basic digits (starting with 1 to 9 unless the only digit is 0), an
      optional decimal point (".", full stop) with one or more basic digits, and
      an optional letter E or e with an optional plus or minus sign and one or
      more basic digits (the exponent).
    </summary>
    <param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param>
    <param name='integersOnly'>If true, no decimal points or exponents are allowed in the string.
    </param>
    <param name='positiveOnly'>If true, only positive numbers are allowed (the leading minus is
      disallowed).
    </param>
    <returns>A CBOR object that represents the parsed number. Returns positive zero if
      the number is a zero that starts with a minus sign (such as "-0" or
      "-0.0"). Returns null if the parsing fails, including if the string is
      null or empty.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean,System.Boolean)'>
    <summary>Parses a number whose format follows the JSON specification (RFC 8259).
      Roughly speaking, a valid number consists of an optional minus sign, one
      or more basic digits (starting with 1 to 9 unless the only digit is 0), an
      optional decimal point (".", full stop) with one or more basic digits, and
      an optional letter E or e with an optional plus or minus sign and one or
      more basic digits (the exponent).
    </summary>
    <param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param>
    <param name='integersOnly'>If true, no decimal points or exponents are allowed in the string.
    </param>
    <param name='positiveOnly'>If true, only positive numbers are allowed (the leading minus is
      disallowed).
    </param>
    <param name='preserveNegativeZero'>If true, returns positive zero if the number is a zero that starts with a
      minus sign (such as "-0" or "-0.0"). Otherwise, returns negative zero in
      this case.
    </param>
    <returns>A CBOR object that represents the parsed number. Returns null if the
      parsing fails, including if the string is null or empty.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.URIUtility'>
    <summary>Contains utility methods for processing Uniform Resource Identifiers
      (URIs) and Internationalized Resource Identifiers (IRIs) under RFC3986 and
      RFC3987, respectively. In the following documentation, URIs and IRIs
      include URI references and IRI references, for convenience.
    </summary>
  </doc>
  <doc name='T:PeterO.Cbor.URIUtility.ParseMode'>
    <summary>Specifies whether certain characters are allowed when parsing IRIs and
      URIs.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.URIUtility.ParseMode.IRILenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Even with this mode, strings with unpaired surrogate code points are
      considered invalid.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.URIUtility.ParseMode.IRIStrict'>
    <summary>The rules follow the syntax for parsing IRIs. In particular, many code
      points outside the Basic Latin range (U+0000 to U+007F) are allowed.
      Strings with unpaired surrogate code points are considered invalid.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.URIUtility.ParseMode.IRISurrogateLenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Unpaired surrogate code points are treated as though they were replacement
      characters instead for the purposes of these rules, so that strings with
      those code points are not considered invalid strings.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.URIUtility.ParseMode.URILenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Code points outside the Basic Latin range (U+0000 to U+007F) are not
      allowed.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.URIUtility.ParseMode.URIStrict'>
    <summary>The rules follow the syntax for parsing IRIs, except that code points
      outside the Basic Latin range (U+0000 to U+007F) are not allowed.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.PercentDecode(System.String)'>
    <summary>Decodes percent-encoding (of the form "%XX" where X is a hexadecimal
      digit) in the given string. Successive percent-encoded bytes are assumed
      to form characters in UTF-8.
    </summary>
    <param name='str'>A string that may contain percent encoding. May be null.
    </param>
    <returns>The string in which percent-encoding was decoded. Returns null if "str" is
      null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.escapeURI(System.String,System.Int32)'>
    <summary>Escapes characters that can't appear in URIs or IRIs. The function is
      idempotent; that is, calling the function again on the result with the
      same mode doesn't change the result.
    </summary>
    <param name='s'>A string to escape.
    </param>
    <param name='mode'>The parameter
      <paramref name='mode'/>
       is a 32-bit signed integer.
    </param>
    <returns>A string possibly containing escaped characters, or null if s is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.hasScheme(System.String)'>
    <summary>Determines whether the string is a valid IRI with a scheme component. This
      can be used to check for relative IRI references.
      <para>The following cases return true:
      </para>
      <code>xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid IRI with a scheme component; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.hasSchemeForURI(System.String)'>
    <summary>Determines whether the string is a valid URI with a scheme component. This
      can be used to check for relative URI references. The following cases
      return true:
      <code>http://example/z xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid URI with a scheme component; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)'>
    <summary>Determines whether the substring is a valid CURIE reference under RDFA
      1.1. (The CURIE reference is the part after the colon.).
    </summary>
    <param name='s'>A string containing a CURIE reference. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The number of elements in the desired portion of "s" (but not more than
      "s" 's length).
    </param>
    <returns><c>true</c> if the substring is a valid CURIE reference under RDFA 1; otherwise,
      <c>false</c> . Returns false if
      <paramref name='s'/>
       is null.
    </returns>
    <exception cref='System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.relativeResolve(System.String,System.String)'>
    <summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue. Example:
      <c>http://example.com/my/path/dir/file.txt</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.relativeResolve(System.String,System.String,PeterO.Cbor.URIUtility.ParseMode)'>
    <summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> . Can be null.
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.splitIRI(System.String)'>
    <summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI reference is syntactically valid, splits the string
      into its components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. The
      scheme, authority, query, and fragment components, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.splitIRI(System.String,PeterO.Cbor.URIUtility.ParseMode)'>
    <summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI is syntactically valid, splits the string into its
      components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string representing an IRI. Can be null.
    </param>
    <param name='parseMode'>The parameter
      <paramref name='parseMode'/>
       is a ParseMode object.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. The
      scheme, authority, query, and fragment components, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.splitIRI(System.String,System.Int32,System.Int32,PeterO.Cbor.URIUtility.ParseMode)'>
    <summary>Parses a substring that represents an Internationalized Resource
      Identifier (IRI) under RFC3987. If the IRI is syntactically valid, splits
      the string into its components and returns an array containing the indices
      into the components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The length of the desired portion of "s" (but not more than "s" 's
      length).
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>If the string is a valid IRI, returns an array of 10 integers. Each of the
      five pairs corresponds to the start and end index of the IRI's scheme,
      authority, path, query, or fragment component, respectively. The scheme,
      authority, query, and fragment components, if present, will each be given
      without the ending colon, the starting "//", the starting "?", and the
      starting "#", respectively. If a component is absent, both indices in that
      pair will be -1 (an index won't be less than 0 in any other case). If the
      string is null or is not a valid IRI, returns null.
    </returns>
    <exception cref='System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
  </doc>
  <doc name='T:PeterO.DataUtilities'>
    <summary>Contains methods useful for reading and writing strings. It is designed to
      have no dependencies other than the basic runtime class library.
      <para>Many of these methods work with text encoded in UTF-8, an encoding form
        of the Unicode Standard which uses one byte to encode the most basic
        characters and two to four bytes to encode other characters. For
        example, the
        <c>GetUtf8</c> method converts a text string to an array of bytes in UTF-8.
      </para>
      <para>In C# and Java, text strings are represented as sequences of 16-bit
        values called
        <c>char</c> s. These sequences are well-formed under UTF-16, a 16-bit encoding form
        of Unicode, except if they contain unpaired surrogate code points. (A
        surrogate code point is used to encode supplementary characters, those
        with code points U+10000 or higher, in UTF-16. A surrogate pair is a
        high surrogate [U+D800 to U+DBFF] followed by a low surrogate [U+DC00 to
        U+DFFF]. An unpaired surrogate code point is a surrogate not appearing
        in a surrogate pair.) Many of the methods in this class allow setting
        the behavior to follow when unpaired surrogate code points are found in
        text strings, such as throwing an error or treating the unpaired
        surrogate as a replacement character (U+FFFD).
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32)'>
    <summary>Gets the Unicode code point at the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <returns>The Unicode code point at the given position. Returns -1 if
      <paramref name='index'/>
       is 0 or less, or is greater than the string's length. Returns the
      replacement character (U+FFFD) if the code point at that position is an
      unpaired surrogate code point. If the return value is 65536 (0x10000) or
      greater, the code point takes up two UTF-16 code units.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32,System.Int32)'>
    <summary>Gets the Unicode code point at the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <param name='surrogateBehavior'>Specifies what kind of value to return if the code point at the given
      index is an unpaired surrogate code point: if 0, return the replacement
      character (U+FFFD); if 1, return the value of the surrogate code point; if
      neither 0 nor 1, return -1.
    </param>
    <returns>The Unicode code point at the given position. Returns -1 if
      <paramref name='index'/>
       is 0 or less, or is greater than the string's length. Returns a value as
      specified under
      <paramref name='surrogateBehavior'/>
       if the code point at that position is an unpaired surrogate code point.
      If the return value is 65536 (0x10000) or greater, the code point takes up
      two UTF-16 code units.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <example><para>The following example shows how to iterate a text string code point by
        code point, terminating the loop when an unpaired surrogate is found.
      </para>
      <code>for (var i = 0;i&lt;str.Length; ++i) { int codePoint =
        DataUtilities.CodePointAt(str, i, 2); if (codePoint &lt; 0) { break; /*
        Unpaired surrogate */ } Console.WriteLine("codePoint:"+codePoint); if
        (codePoint &gt;= 0x10000) { i++; /* Supplementary code point */ } }</code> .
    </example>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32)'>
    <summary>Gets the Unicode code point just before the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <returns>The Unicode code point at the previous position. Returns -1 if
      <paramref name='index'/>
       is 0 or less, or is greater than the string's length. Returns the
      replacement character (U+FFFD) if the code point at the previous position
      is an unpaired surrogate code point. If the return value is 65536
      (0x10000) or greater, the code point takes up two UTF-16 code units.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32,System.Int32)'>
    <summary>Gets the Unicode code point just before the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <param name='surrogateBehavior'>Specifies what kind of value to return if the previous code point is an
      unpaired surrogate code point: if 0, return the replacement character
      (U+FFFD); if 1, return the value of the surrogate code point; if neither 0
      nor 1, return -1.
    </param>
    <returns>The Unicode code point at the previous position. Returns -1 if
      <paramref name='index'/>
       is 0 or less, or is greater than the string's length. Returns a value as
      specified under
      <paramref name='surrogateBehavior'/>
       if the code point at the previous position is an unpaired surrogate code
      point. If the return value is 65536 (0x10000) or greater, the code point
      takes up two UTF-16 code units.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointCompare(System.String,System.String)'>
    <summary>Compares two strings in Unicode code point order. Unpaired surrogate code
      points are treated as individual code points.
    </summary>
    <param name='strA'>The first string. Can be null.
    </param>
    <param name='strB'>The second string. Can be null.
    </param>
    <returns>A value indicating which string is " less" or " greater" . 0: Both strings
      are equal or null. Less than 0: a is null and b isn't; or the first code
      point that's different is less in A than in B; or b starts with a and is
      longer than a. Greater than 0: b is null and a isn't; or the first code
      point that's different is greater in A than in B; or a starts with b and
      is longer than b.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointLength(System.String)'>
    <summary>Finds the number of Unicode code points in the given text string. Unpaired
      surrogate code points increase this number by 1. This is not necessarily
      the length of the string in "char" s.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <returns>The number of Unicode code points in the given string.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean)'>
    <summary><para>Encodes a string in UTF-8 as a byte array. This method does not insert a
        byte-order mark (U+FEFF) at the beginning of the encoded byte array.
      </para>
      <para>REMARK: It is not recommended to use
        <c>Encoding.UTF8.GetBytes</c> in.NET, or the
        <c>getBytes()</c> method in Java to do this. For instance,
        <c>getBytes()</c> encodes text strings in a default (so not fixed) character encoding,
        which can be undesirable.
      </para>
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <returns>The string encoded in UTF-8.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The string contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false, or an internal error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean,System.Boolean)'>
    <summary><para>Encodes a string in UTF-8 as a byte array. This method does not insert a
        byte-order mark (U+FEFF) at the beginning of the encoded byte array.
      </para>
      <para>REMARK: It is not recommended to use
        <c>Encoding.UTF8.GetBytes</c> in.NET, or the
        <c>getBytes()</c> method in Java to do this. For instance,
        <c>getBytes()</c> encodes text strings in a default (so not fixed) character encoding,
        which can be undesirable.
      </para>
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <param name='lenientLineBreaks'>If true, replaces carriage return (CR) not followed by line feed (LF) and
      LF not preceded by CR with CR-LF pairs.
    </param>
    <returns>The string encoded in UTF-8.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The string contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false, or an internal error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.GetUtf8Length(System.String,System.Boolean)'>
    <summary>Calculates the number of bytes needed to encode a string in UTF-8.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='replace'>If true, treats unpaired surrogate code points as having 3 UTF-8 bytes
      (the UTF-8 length of the replacement character U+FFFD).
    </param>
    <returns>The number of bytes needed to encode the given string in UTF-8, or -1 if
      the string contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Boolean)'>
    <summary>Generates a text string from a UTF-8 byte array.
    </summary>
    <param name='bytes'>A byte array containing text encoded in UTF-8.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when invalid UTF-8 is seen.
    </param>
    <returns>A string represented by the UTF-8 byte array.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='bytes'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The string is not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Int32,System.Int32,System.Boolean)'>
    <summary>Generates a text string from a portion of a UTF-8 byte array.
    </summary>
    <param name='bytes'>A byte array containing text encoded in UTF-8.
    </param>
    <param name='offset'>Offset into the byte array to start reading.
    </param>
    <param name='bytesCount'>Length, in bytes, of the UTF-8 text string.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when invalid UTF-8 is seen.
    </param>
    <returns>A string represented by the UTF-8 byte array.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='bytes'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The portion of the byte array is not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='bytesCount'/>
       is less than 0, or offset plus bytesCount is greater than the length of
      "data" .
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.ReadUtf8(System.IO.Stream,System.Int32,System.Text.StringBuilder,System.Boolean)'>
    <summary>Reads a string in UTF-8 encoding from a data stream.
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <param name='bytesCount'>The length, in bytes, of the string. If this is less than 0, this function
      will read until the end of the stream.
    </param>
    <param name='builder'>A string builder object where the resulting string will be stored.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when an unpaired surrogate code point
      is seen.
    </param>
    <returns>0 if the entire string was read without errors, -1 if the string is not
      valid UTF-8 and
      <paramref name='replace'/>
       is false, or -2 if the end of the stream was reached before the last
      character was read completely (which is only the case if
      <paramref name='bytesCount'/>
       is 0 or greater).
    </returns>
    <exception cref='System.IO.IOException'>An I/O error occurred.
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null or
      <paramref name='builder'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.ReadUtf8FromBytes(System.Byte[],System.Int32,System.Int32,System.Text.StringBuilder,System.Boolean)'>
    <summary>Reads a string in UTF-8 encoding from a byte array.
    </summary>
    <param name='data'>A byte array containing a UTF-8 text string.
    </param>
    <param name='offset'>Offset into the byte array to start reading.
    </param>
    <param name='bytesCount'>Length, in bytes, of the UTF-8 text string.
    </param>
    <param name='builder'>A string builder object where the resulting string will be stored.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when invalid UTF-8 is seen.
    </param>
    <returns>0 if the entire string was read without errors, or -1 if the string is not
      valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='data'/>
       is null or
      <paramref name='builder'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='bytesCount'/>
       is less than 0, or offset plus bytesCount is greater than the length of
      <paramref name='data'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream)'>
    <summary>Reads a string in UTF-8 encoding from a data stream in full and returns
      that string. Replaces invalid encoding with the replacement character
      (U+FFFD).
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <returns>The string read.
    </returns>
    <exception cref='System.IO.IOException'>An I/O error occurred.
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream,System.Int32,System.Boolean)'>
    <summary>Reads a string in UTF-8 encoding from a data stream and returns that
      string.
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <param name='bytesCount'>The length, in bytes, of the string. If this is less than 0, this function
      will read until the end of the stream.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, throws an error if an unpaired surrogate code point is
      seen.
    </param>
    <returns>The string read.
    </returns>
    <exception cref='System.IO.IOException'>An I/O error occurred; or, the string is not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.ToLowerCaseAscii(System.String)'>
    <summary>Returns a string with the basic upper-case letters A to Z (U+0041 to
      U+005A) converted to lower-case. Other characters remain unchanged.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <returns>The converted string, or null if
      <paramref name='str'/>
       is null.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.ToUpperCaseAscii(System.String)'>
    <summary>Returns a string with the basic lower-case letters A to Z (U+0061 to
      U+007A) converted to upper-case. Other characters remain unchanged.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <returns>The converted string, or null if
      <paramref name='str'/>
       is null.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.WriteUtf8(System.String,System.IO.Stream,System.Boolean)'>
    <summary>Writes a string in UTF-8 encoding to a data stream.
    </summary>
    <param name='str'>A string to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <returns>0 if the entire string was written; or -1 if the string contains an
      unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null or
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean)'>
    <summary>Writes a portion of a string in UTF-8 encoding to a data stream.
    </summary>
    <param name='str'>A string to write.
    </param>
    <param name='offset'>The Index starting at 0 where the string portion to write begins.
    </param>
    <param name='length'>The length of the string portion to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <returns>0 if the entire string portion was written; or -1 if the string portion
      contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null or
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='length'/>
       is less than 0, or
      <paramref name='offset'/>
       plus
      <paramref name='length'/>
       is greater than the string's length.
    </exception>
    <exception cref='System.IO.IOException'>An I/O error occurred.
    </exception>
    <exception cref='System.ArgumentException'>Either "offset" or "length" is less than 0 or greater than "str"'s length,
      or "str"'s length minus "offset" is less than "length".
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean,System.Boolean)'>
    <summary>Writes a portion of a string in UTF-8 encoding to a data stream.
    </summary>
    <param name='str'>A string to write.
    </param>
    <param name='offset'>The Index starting at 0 where the string portion to write begins.
    </param>
    <param name='length'>The length of the string portion to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <param name='lenientLineBreaks'>If true, replaces carriage return (CR) not followed by line feed (LF) and
      LF not preceded by CR with CR-LF pairs.
    </param>
    <returns>0 if the entire string portion was written; or -1 if the string portion
      contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null or
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='length'/>
       is less than 0, or
      <paramref name='offset'/>
       plus
      <paramref name='length'/>
       is greater than the string's length.
    </exception>
    <exception cref='System.IO.IOException'>An I/O error occurred.
    </exception>
    <exception cref='System.ArgumentException'>Either "offset" or "length" is less than 0 or greater than "str"'s length,
      or "str"'s length minus "offset" is less than "length".
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='T:PeterO.Mail.Address'>
    <summary>Represents an email address.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.Address.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.Address'/>
       class.
    </summary>
    <param name='addressValue'>The parameter
      <paramref name='addressValue'/>
       is a text string.
    </param>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='addressValue'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>AddressValue is empty.; Address doesn't contain a '@' sign; Invalid local
      part; Expected '@' sign after local part; Expected domain after '@';
      Invalid domain; Address too long.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.Address.Domain'>
    <summary>Gets the domain of this email address (the part after the "@" sign).
    </summary>
    <value>The domain of this email address (the part after the "@" sign).
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Address.Equals(System.Object)'>
    <summary>Determines whether this object and another object are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if this object and another object are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Address.GetHashCode'>
    <summary>Returns a hash code for this address object. No application or process
      identifiers are used in the hash code calculation.
    </summary>
    <returns>A hash code for this instance.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.Address.LocalPart'>
    <summary>Gets the local part of this email address (the part before the "@" sign).
    </summary>
    <value>The local part of this email address (the part before the "@" sign).
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Address.ToString'>
    <summary>Converts this address object to a text string.
    </summary>
    <returns>A string representation of this object.
    </returns>
  </doc>
  <doc name='T:PeterO.Mail.Base64Encoder'>
    <summary>This is an internal class.
    </summary>
  </doc>
  <doc name='T:PeterO.Mail.ContentDisposition'>
    <summary><para>Specifies how a message body should be displayed or handled by a mail
        user agent. This type is immutable; its contents can't be changed after
        it's created. To create a changeable disposition object, use the
        DispositionBuilder class.
      </para>
      <para><b>About the "filename" parameter</b> </para>
      <para>The "filename" parameter of a content disposition suggests a name to use
        when saving data to a file. For the "filename" parameter, the
        GetParameter method and Parameters property (
        <c>getParameters</c> ) method in Java) do not adapt that parameter's value using the
        ContentDisposition.MakeFilename method. Thus, for example, the
        "filename" parameter, if any, returned by this method could have an
        arbitrary length, be encoded using RFC 2047 encoded words (which some
        email and HTTP implementations still like to write out in headers, even
        though that RFC says encoded words "MUST NOT appear within a
        'quoted-string'"; see ContentDisposition.MakeFilename), or not be usable
        as is as a file name.
      </para>
      <para><b>Example:</b> An example of RFC 2047 encoded words is:
      </para>
      <para><b>=?UTF-8?Q?test?=</b> </para>
      <para>Content-Disposition header fields like the following have appeared in
        practice:
      </para>
      <para><b>Content-Disposition: attachment; filename==?UTF-8?Q?example?=</b> </para>
      <para><b>Content-Disposition: attachment; filename==?UTF-8?Q?test.png?=</b> </para>
      <para><b>Content-Disposition: attachment; filename="=?UTF-8?Q?test.png?="</b> </para>
      <para>In this implementation, the first and second of these are syntactically
        invalid, so they trigger parse errors, while the third of these is
        syntactically valid, but the "filename" parameter is treated as
        "=?UTF-8?Q?test.png?=", not "test.png" or something else -- RFC 2047
        encoded words are not decoded at the moment a content disposition is
        parsed (using the Parse method).
      </para>
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.ContentDisposition.Attachment'>
    <summary>The content disposition value "attachment" .
    </summary>
  </doc>
  <doc name='P:PeterO.Mail.ContentDisposition.DispositionType'>
    <summary>Gets a string containing this object's disposition type, such as "inline"
      or "attachment". Note that under RFC 6266 sec. 4.2 and RFC 2183 sec. 2.8,
      unrecognized disposition types should be treated as "attachment".
    </summary>
    <value>A string containing this object's disposition type, such as "inline" or
      "attachment".
    </value>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.Equals(System.Object)'>
    <summary>Determines whether this object and another object are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if the objects are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.GetCreationDate'>
    <summary>Gets the date and time extracted from this content disposition's
      "creation-date" parameter, which specifies the date of creation of a file
      (RFC 2183 sec. 2.4). See
      <see cref='PeterO.Mail.MailDateTime.ParseDateString(System.String,System.Boolean)'/>
       for information on the format of this method's return value.
    </summary>
    <returns>The extracted date and time as an 8-element array, or
      <c>null</c> if the "creation-date" parameter doesn't exist, is an empty string, or is
      syntactically invalid, or if the parameter's year would overflow a 32-bit
      signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.GetFilename'>
    <summary>Gets an adapted version of the "filename" parameter in this content
      disposition object by using the "MakeFilename" method.
    </summary>
    <returns>The adapted file name in the form of a string. Returns the empty string if
      there is no "filename" parameter or that parameter is empty.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.GetHashCode'>
    <summary>Calculates the hash code of this object. No application or process IDs are
      used in the hash code calculation.
    </summary>
    <returns>A 32-bit hash code.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.GetModificationDate'>
    <summary>Gets the date and time extracted from this content disposition's
      "modification-date" parameter, which specifies the date of last
      modification of a file (RFC 2183 sec. 2.5). See
      <see cref='PeterO.Mail.MailDateTime.ParseDateString(System.String,System.Boolean)'/>
       for information on the format of this method's return value.
    </summary>
    <returns>The extracted date and time as an 8-element array, or
      <c>null</c> if the "modification-date" parameter doesn't exist, is an empty string,
      or is syntactically invalid, or if the parameter's year would overflow a
      32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.GetParameter(System.String)'>
    <summary>Gets a parameter from this disposition object. For the "filename"
      parameter, the value of that parameter is not adapted with the
      ContentDisposition.MakeFilename method; see the documentation for the
      ContentDisposition class.
    </summary>
    <param name='name'>The name of the parameter to get. The name will be matched using a basic
      case-insensitive comparison. (Two strings are equal in such a comparison,
      if they match after converting the basic upper-case letters A to Z (U+0041
      to U+005A) in both strings to lower case.). Can't be null.
    </param>
    <returns>The value of the parameter, or null if the parameter does not exist.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='name'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='name'/>
       is empty.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.GetReadDate'>
    <summary>Gets the date and time extracted from this content disposition's
      "read-date" parameter, which specifies the date at which a file was last
      read (RFC 2183 sec. 2.6). See
      <see cref='PeterO.Mail.MailDateTime.ParseDateString(System.String,System.Boolean)'/>
       for information on the format of this method's return value.
    </summary>
    <returns>The extracted date and time as an 8-element array, or
      <c>null</c> if the "read-date" parameter doesn't exist, is an empty string, or is
      syntactically invalid, or if the parameter's year would overflow a 32-bit
      signed integer.
    </returns>
  </doc>
  <doc name='F:PeterO.Mail.ContentDisposition.Inline'>
    <summary>The content disposition value "inline" .
    </summary>
  </doc>
  <doc name='P:PeterO.Mail.ContentDisposition.IsAttachment'>
    <summary>Gets a value indicating whether the disposition type is attachment.
    </summary>
    <value><c>true</c> If the disposition type is attachment; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Mail.ContentDisposition.IsInline'>
    <summary>Gets a value indicating whether the disposition type is inline.
    </summary>
    <value><c>true</c> If the disposition type is inline; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.MakeFilename(System.String)'>
    <summary>Converts a file name from the Content-Disposition header to a suitable
      name for saving data to a file. This method is idempotent; that is,
      calling the method again on the result doesn't change that result.
      <para>Examples:
      </para>
      <para><c>"=?utf-8?q?hello=2Etxt?=" -&gt;"hello.txt"</c> (RFC 2047 encoding).
      </para>
      <para><c>"=?utf-8?q?long_filename?=" -&gt;"long filename"</c> (RFC 2047 encoding).
      </para>
      <para><c>"utf-8'en'hello%2Etxt" -&gt;"hello.txt"</c> (RFC 2231 encoding).
      </para>
      <para><c>"nul.txt" -&gt;"_nul.txt"</c> (Reserved name).
      </para>
      <para><c>"dir1/dir2/file" -&gt;"dir1_dir2_file"</c> (Directory separators).
      </para>
    </summary>
    <param name='str'>A string representing a file name. Can be null.
    </param>
    <returns>A string with the converted version of the file name. Among other things,
      encoded words under RFC 2047 are decoded (since they occur so frequently
      in Content-Disposition filenames); the value is decoded under RFC 2231 if
      possible; characters unsuitable for use in a filename (including the
      directory separators slash and backslash) are replaced with underscores;
      spaces and tabs are collapsed to a single space; leading and trailing
      spaces and tabs are removed; and the filename is truncated if it would
      otherwise be too long. Also, for reasons stated in the remarks, a
      character that is the combined form of a base character and a combining
      slash is replaced with "!" followed by the base character. The returned
      string will be in normalization form C. Returns the empty string if
      <paramref name='str'/>
       is null or empty.
    </returns>
    <remarks>
      <para><b>Remarks:</b> </para>
      <list>
        <item>The exact file name conversion used by this method is not guaranteed
          to remain the same between versions of this library, with the
          exception that the return value will be in normalization form C, will
          not contain base + slash code points, will not be null, and will be an
          empty string only if
          <paramref name='str'/>
           is null or empty.
        </item>
        <item>The string returned by this method is normalized using Unicode
          normalization form C (NFC) (see the
          <see cref='PeterO.Text.NormalizerInput'/>
           class for details). Although most file systems preserve the
          normalization of file names, there is one notable exception: The HFS
          Plus file system (on macOS before High Sierra) stores file names using
          a modified version of normalization form D (NFD) in which certain code
          points are not decomposed, including all base + slash code points,
          which are the only composed code points in Unicode that are decomposed
          in NFD but not in HFS Plus's version of NFD. If the filename will be
          used to save a file to an HFS Plus storage device, it is enough to
          normalize the return value with NFD for this purpose (because all base
          + slash code points were converted beforehand by MakeFilename to an
          alternate form). See also Apple's Technical Q&amp;A "Text Encodings in
          VFS" and Technical Note TN1150, "HFS Plus Volume Format".
        </item>
        <item><para>Email and HTTP headers may specify suggested filenames using the
            Content-Disposition header field's
            <c>filename</c> parameter or, in practice, the Content-Type header field's
            <c>name</c> parameter.
          </para>
          <para>Although RFC 2047 encoded words appearing in both parameters are
            written out by some implementations, this practice is often
            discouraged (especially since the RFC itself says that encoded words
            "MUST NOT appear within a 'quoted-string'"). Nevertheless, the
            MakeFilename method has a basis in the RFCs to decode RFC 2047
            encoded words (and RFC 2231 encoding) in file names passed to this
            method.
          </para>
          <para>RFC 2046 sec. 4.5.1 (
            <c>application/octet-stream</c> subtype in Content-Type header field) cites an earlier RFC 1341,
            which "defined the use of a 'NAME' parameter which gave a
            <i>
               suggested
            </i>
             file name to be used if the data were written to a file". Also, RFC
            2183 sec. 2.3 (
            <c>filename</c> parameter in Content-Disposition) confirms that the "
            <i>
               suggested
            </i>
             filename" in the
            <c>filename</c> parameter "should be
            <i>
               used as a basis
            </i>
             for the actual filename, where possible", and that that file name
            should "not [be] blindly use[d]". See also RFC 6266, section 4.3,
            which discusses the use of that parameter in Hypertext Transfer
            Protocol (HTTP).
          </para>
          <para>To the extent that the "name" parameter is not allowed in message
            bodies other than those with the media type
            "application/octet-stream" or treated as that media-type, this is a
            deviation of RFC 2045 and 2046 (see also RFC 2045 sec. 5, which says
            that "[t]here are NO globally meaningful parameters that apply to
            all media types"). (Some email implementations may still write out
            the "name" parameter, even for media types other than
            <c>application/octet-stream</c> and even though RFC 2046 has deprecated that parameter.)
          </para>
        </item>
      </list>
       .
    </remarks>
  </doc>
  <doc name='P:PeterO.Mail.ContentDisposition.Parameters'>
    <summary>Gets a list of parameter names associated with this object and their
      values.
      <para>For the "filename" parameter, the value of that parameter is not adapted
        with the ContentDisposition.MakeFilename method; see the documentation
        for the ContentDisposition class.
      </para>
    </summary>
    <value>A read-only list of parameter names associated with this object and their
      values. NOTE: Previous versions erroneously stated that the list will be
      sorted by name. In fact, the names will not be guaranteed to appear in any
      particular order; this is at least the case in version 0.10.0.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.Parse(System.String)'>
    <summary>Creates a new content disposition object from the value of a
      Content-Disposition header field.
    </summary>
    <param name='dispoValue'>The parameter
      <paramref name='dispoValue'/>
       is a text string.
    </param>
    <returns>A content disposition object, or ContentDisposition.Attachment" if
      <paramref name='dispoValue'/>
       is empty or syntactically invalid.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='dispoValue'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.Parse(System.String,PeterO.Mail.ContentDisposition)'>
    <summary>Parses a content disposition string and returns a content disposition
      object, or the default value if the string is invalid. This method checks
      the syntactic validity of the string, but not whether it has all
      parameters it's required to have or whether the parameters themselves are
      set to valid values for the parameter.
      <para>This method assumes the given content disposition string was directly
        extracted from the Content-Disposition header field (as defined for
        email messages) and follows the syntax given in RFC 2183. Accordingly,
        among other things, the content disposition string can contain comments
        (delimited by parentheses).
      </para>
      <para>RFC 2231 extensions allow each content disposition parameter to be
        associated with a character encoding and/or language, and support
        parameter values that span two or more key-value pairs. Parameters
        making use of RFC 2231 extensions have names with an asterisk ("*").
        Such a parameter will be ignored if it is ill-formed because of RFC
        2231's rules (except for illegal percent-decoding or undecodable
        sequences for the given character encoding). Examples of RFC 2231
        extensions follow (both examples encode the same "filename" parameter):
      </para>
      <para><b>inline; filename*=utf-8'en'filename.txt</b> </para>
      <para><b>inline; filename*0*=utf-8'en'file; filename*1*=name%2Etxt</b> </para>
      <para>This implementation ignores keys (in parameter key-value pairs) that
        appear more than once in the content disposition. Nothing in RFCs 2045,
        2183, 2231, 6266, or 7231 explicitly disallows such keys, or otherwise
        specifies error-handling behavior for such keys.
      </para>
    </summary>
    <param name='dispositionValue'>A text string that should be the value of a Content-Disposition header
      field.
    </param>
    <param name='defaultValue'>The value to return in case the disposition value is syntactically
      invalid. Can be null.
    </param>
    <returns>A ContentDisposition object.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='dispositionValue'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.ToSingleLineString'>
    <summary>Converts this content disposition to a text string form suitable for
      inserting in HTTP headers. Notably, the string contains the value of a
      Content-Disposition header field (without the text necessarily starting
      with "Content-Disposition" followed by a space), and consists of a single
      line.
    </summary>
    <returns>A text string form of this content disposition.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.ToString'>
    <summary>Converts this content disposition to a text string form suitable for
      inserting in email headers. Notably, the string contains the value of a
      Content-Disposition header field (without the text necessarily starting
      with "Content-Disposition" followed by a space), and consists of one or
      more lines.
    </summary>
    <returns>A text string form of this content disposition.
    </returns>
  </doc>
  <doc name='T:PeterO.Mail.DataUris'>
    <summary>Contains methods for parsing and generating Data URIs (uniform resource
      identifiers). Data URIs are described in RFC 2397. Examples for Data URIs
      follow.
      <code>data:, hello%20world</code> <code>data:text/markdown, hello%20world</code> <code>data:application/octet-stream;base64, AAAAAA==</code> .
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.DataUris.DataUriBytes(System.String)'>
    <summary>Extracts the data from a Data URI (uniform resource identifier) in the
      form of a byte array.
    </summary>
    <param name='uri'>The parameter
      <paramref name='uri'/>
       is a text string.
    </param>
    <returns>The data as a byte array. Returns null if
      <paramref name='uri'/>
       is null, is syntactically invalid, or is not a data URI.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='uri'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.DataUris.DataUriBytes(System.Uri)'>
    <summary>Not documented yet.
    </summary>
    <param name='uri'>The parameter
      <paramref name='uri'/>
       is not documented yet.
    </param>
    <returns>A byte array.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.DataUris.DataUriMediaType(System.String)'>
    <summary>Extracts the media type from a Data URI (uniform resource identifier).
    </summary>
    <param name='uri'>The parameter
      <paramref name='uri'/>
       is a text string.
    </param>
    <returns>The media type. Returns null if
      <paramref name='uri'/>
       is null, is syntactically invalid, or is not a Data URI.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='uri'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.DataUris.DataUriMediaType(System.Uri)'>
    <summary>Not documented yet.
    </summary>
    <param name='uri'>The parameter
      <paramref name='uri'/>
       is not documented yet.
    </param>
    <returns>A MediaType object.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.DataUris.MakeDataUri(System.Byte[],PeterO.Mail.MediaType)'>
    <summary>Encodes data with the given media type in a Data URI (uniform resource
      identifier).
    </summary>
    <param name='bytes'>A byte array containing the data to encode in a Data URI.
    </param>
    <param name='mediaType'>A media type to assign to the data.
    </param>
    <returns>A Data URI that encodes the given data and media type.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='bytes'/>
       or
      <paramref name='mediaType'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.DataUris.MakeDataUri(System.String)'>
    <summary>Encodes text as a Data URI (uniform resource identifier).
    </summary>
    <param name='textString'>A text string to encode as a data URI.
    </param>
    <returns>A Data URI that encodes the given text.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='textString'/>
       is null.
    </exception>
  </doc>
  <doc name='T:PeterO.Mail.DataUrls'>
    <summary>Contains methods for parsing and generating Data URIs (uniform resource
      identifiers). Data URIs are described in RFC 2397. Examples for Data URIs
      follow.
      <code>data:, hello%20world</code> <code>data:text/markdown, hello%20world</code> <code>data:application/octet-stream;base64, AAAAAA==</code> .
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.DataUrls.DataUrlBytes(System.String)'>
    <summary>Extracts the data from a Data URI (uniform resource identifier) in the
      form of a byte array.
    </summary>
    <param name='url'>A data URI.
    </param>
    <returns>The data as a byte array. Returns null if
      <paramref name='url'/>
       is null, is syntactically invalid, or is not a data URI.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.DataUrls.DataUrlMediaType(System.String)'>
    <summary>Extracts the media type from a Data URI (uniform resource identifier).
    </summary>
    <param name='url'>A data URI.
    </param>
    <returns>The media type. Returns null if
      <paramref name='url'/>
       is null, is syntactically invalid, or is not a Data URI.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.DataUrls.MakeDataUrl(System.Byte[],PeterO.Mail.MediaType)'>
    <summary>Encodes data with the given media type in a Data URI (uniform resource
      identifier).
    </summary>
    <param name='bytes'>A byte array containing the data to encode in a Data URI.
    </param>
    <param name='mediaType'>A media type to assign to the data.
    </param>
    <returns>A Data URI that encodes the given data and media type.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='bytes'/>
       or
      <paramref name='mediaType'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.DataUrls.MakeDataUrl(System.String)'>
    <summary>Encodes text as a Data URI (uniform resource identifier).
    </summary>
    <param name='textString'>A text string to encode as a data URI.
    </param>
    <returns>A Data URI that encodes the given text.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='textString'/>
       is null.
    </exception>
  </doc>
  <doc name='T:PeterO.Mail.DispositionBuilder'>
    <summary>A mutable data type that allows a content disposition to be built.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.DispositionBuilder'/>
       class.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.#ctor(PeterO.Mail.ContentDisposition)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.DispositionBuilder'/>
       class.
    </summary>
    <param name='mt'>The parameter
      <paramref name='mt'/>
       is a ContentDisposition object.
    </param>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='mt'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.DispositionBuilder'/>
       class.
    </summary>
    <param name='type'>The parameter
      <paramref name='type'/>
       is a text string.
    </param>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='type'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>Type is empty.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.DispositionBuilder.DispositionType'>
    <summary>Gets or sets this value's disposition type, such as "inline" or
      "attachment".
    </summary>
    <value>This value's disposition type, such as "inline" or "attachment" .
    </value>
  </doc>
  <doc name='P:PeterO.Mail.DispositionBuilder.IsMultipart'>
    <summary>Gets a value indicating whether this is a multipart media type.
    </summary>
    <value><c>true</c> If this is a multipart media type; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Mail.DispositionBuilder.IsText'>
    <summary>Gets a value indicating whether this is a text media type.
    </summary>
    <value><c>true</c> If this is a text media type; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.RemoveParameter(System.String)'>
    <summary>Removes a parameter from this content disposition. Does nothing if the
      parameter's name doesn't exist.
    </summary>
    <param name='name'>The parameter to remove. The name is compared using a basic
      case-insensitive comparison. (Two strings are equal in such a comparison,
      if they match after converting the basic upper-case letters A to Z (U+0041
      to U+005A) in both strings to lower case.).
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='name'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.SetDispositionType(System.String)'>
    <summary>Sets the disposition type, such as "inline".
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>Str is empty.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.SetParameter(System.String,System.String)'>
    <summary>Sets a parameter of this content disposition.
    </summary>
    <param name='name'>Name of the parameter to set. If this name already exists (compared using
      a basic case-insensitive comparison), it will be overwritten. (Two strings
      are equal in a basic case-insensitive comparison, if they match after
      converting the basic upper-case letters A to Z (U+0041 to U+005A) in both
      strings to lower case.).
    </param>
    <param name='value'>Value of the parameter to set.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentNullException'>Either
      <paramref name='value'/>
       or
      <paramref name='name'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='name'/>
       is empty, or it isn't a well-formed parameter name.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.ToDisposition'>
    <summary>Converts this object to an immutable ContentDisposition object.
    </summary>
    <returns>A MediaType object.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.ToString'>
    <summary>Converts this object to a text string.
    </summary>
    <returns>A string representation of this object.
    </returns>
  </doc>
  <doc name='T:PeterO.Mail.EncodedWordContext'>
    <summary>Specifies the context where an encoded word under RFC 2047 can appear.
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.EncodedWordContext.Comment'>
    <summary>Contains methods for parsing and matching language tags.
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.EncodedWordContext.Phrase'>
    <summary>In a "word" element within a "phrase" of a structured header field.
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.EncodedWordContext.Unstructured'>
    <summary>In an unstructured header field's value.
    </summary>
  </doc>
  <doc name='T:PeterO.Mail.EnrichedText'>
    <summary>This is an internal API.
    </summary>
  </doc>
  <doc name='T:PeterO.Mail.IdentityEncoder'>
    <summary>This is an internal API.
    </summary>
  </doc>
  <doc name='T:PeterO.Mail.LanguageTags'>
    <summary>Contains methods for parsing and matching language tags.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.GetLanguageList(System.String)'>
    <summary>Parses a language list from a Content-Language header field.
    </summary>
    <param name='str'>A string following the syntax of a Content-Language header field (see RFC
      3282). This is a comma-separated list of language tags. RFC 5322 comments
      (in parentheses) can appear. This parameter can be null.
    </param>
    <returns>A list of language tags. Returns an empty list if
      <paramref name='str'/>
       is null or the empty string, or null if
      <paramref name='str'/>
       syntactically invalid.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.GetRangeListWithQuality(System.String)'>
    <summary>Parses a language range list from an Accept-Language header field.
    </summary>
    <param name='str'>A string following the syntax of an Accept-Language header field (see RFC
      3282). This is a comma-separated list of language ranges, with an optional
      "quality" after the language tag (examples include "en; q=0.5" or
      "de-DE"). RFC 5322 comments (in parentheses) can appear. This parameter
      can be null.
    </param>
    <returns>A list of language ranges with their associated qualities. The list will
      be sorted in descending order by quality; if two or more language ranges
      have the same quality, they will be sorted in the order in which they
      appeared in the given string. Returns null if
      <paramref name='str'/>
       is null or syntactically invalid.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.IsLanguageRange(System.String)'>
    <summary>Returns whether the given string is a basic language range under RFC 4647.
      Examples include "*", "en-us", and "fr".
    </summary>
    <param name='str'>The string to check. Can be null.
    </param>
    <returns><c>true</c> if the given string is a basic language range; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.IsLanguageRange(System.String,System.Boolean)'>
    <summary>Returns whether the given string is a basic or extended language range
      under RFC 4647. Examples of basic (and extended) language ranges include
      "*", "en-us", and "fr". Examples of extended language ranges include
      "*-de" and "it-*".
    </summary>
    <param name='str'>The string to check. Can be null.
    </param>
    <param name='extended'>Check whether the string is a basic language range if "false", or an
      extended language range if "true".
    </param>
    <returns><c>true</c> if the given string is a basic language range (depending on the
      <paramref name='extended'/>
       parameter); otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.IsPotentiallyValidLanguageTag(System.String)'>
    <summary>Returns true if (1) the given string is a well-formed language tag under
      RFC 5646 (that is, the string follows the syntax given in section 2.1 of
      that RFC), and (2) the language tag contains at most one extended language
      subtag, no variant subtags with the same value, and no extension singleton
      subtags with the same value.
    </summary>
    <param name='str'>The string to check.
    </param>
    <returns><c>true</c> , if the string meets the conditions given in the summary,
      <c>false</c> otherwise.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.LanguageTagCase(System.String)'>
    <summary>Sets the given language tag to the case combination recommended by RFC
      5646. For example, "en-us" becomes "en-US", and "zh-hant" becomes
      "zh-Hant".
    </summary>
    <param name='str'>A string of a language tag. Can be null.
    </param>
    <returns>A text string in the recommended case combination, or null if
      <paramref name='str'/>
       is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.LanguageTagFilter(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String})'>
    <summary>Finds the language tags that match a priority list of basic language
      ranges.
    </summary>
    <param name='ranges'>A list of basic language ranges (see documentation for the
      "IsLanguageRange" method), which should be given in order of descending
      preference.
    </param>
    <param name='languages'>A list of language tags, which should be given in order of descending
      preference.
    </param>
    <returns>A list of language tags that match the given range, in descending order of
      preference.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='languages'/>
       or
      <paramref name='ranges'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='ranges'/>
       contains a value that is not a basic language range, or
      <paramref name='languages'/>
       contains a value that is not a potentially valid language tag.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.LanguageTagFilter(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.Boolean,System.Boolean)'>
    <summary>Finds the language tags that match a priority list of language ranges.
    </summary>
    <param name='ranges'>A list of language ranges (see documentation for the "IsLanguageRange"
      method), which should be given in order of descending preference.
    </param>
    <param name='languages'>A list of language tags, which should be given in order of descending
      preference.
    </param>
    <param name='extended'>If true, the ranges in "ranges" are extended language ranges; otherwise,
      they are basic language ranges.
    </param>
    <param name='matchStarAtEnd'>If true, treats any range equaling "*" as appearing at the end of the
      language priority list, no matter where it appears on that list.
    </param>
    <returns>A list of language tags that match the given range, in descending order of
      preference.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='languages'/>
       or
      <paramref name='ranges'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='ranges'/>
       contains a value that is not a basic or extended language range, or
      <paramref name='languages'/>
       contains a value that is not a potentially valid language tag.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.LanguageTagLookup(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.String)'>
    <summary>Does a language tag lookup (under RFC 4647) for a matching language tag.
    </summary>
    <param name='ranges'>A list of basic language ranges (see documentation for the
      "IsLanguageRange" method), which should be given in order of descending
      preference.
    </param>
    <param name='languages'>A list of language tags, which should be given in order of descending
      preference.
    </param>
    <param name='defaultValue'>The value to return if no matching language tag was found.
    </param>
    <returns>The matching language tag, or the parameter
      <paramref name='defaultValue'/>
       if there is no matching language tag.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='languages'/>
       or
      <paramref name='ranges'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='ranges'/>
       contains a value that is not a basic language range, or
      <paramref name='languages'/>
       contains a value that is not a potentially valid language tag.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.LanguageTagLookup(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.String,System.Boolean)'>
    <summary>Does a language tag lookup (under RFC 4647) for a matching language tag.
    </summary>
    <param name='ranges'>A list of language ranges (see documentation for the "IsLanguageRange"
      method), which should be given in order of descending preference.
    </param>
    <param name='languages'>A list of language tags, which should be given in order of descending
      preference.
    </param>
    <param name='defaultValue'>The value to return if no matching language tag was found.
    </param>
    <param name='extended'>If true, the ranges in "ranges" are extended language ranges; otherwise,
      they are basic language ranges.
    </param>
    <returns>The matching language tag, or the parameter
      <paramref name='defaultValue'/>
       if there is no matching language tag.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='languages'/>
       or
      <paramref name='ranges'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='ranges'/>
       contains a value that is not a basic or extended language range, or
      <paramref name='languages'/>
       contains a value that is not a potentially valid language tag.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.LanguageTagLookup(System.String,System.Collections.Generic.IList{System.String},System.String)'>
    <summary>Does a language tag lookup (under RFC 4647) for a matching language tag.
    </summary>
    <param name='range'>A basic language range (see the documentation for "IsLanguageRange").
    </param>
    <param name='languages'>A list of language tags, which should be given in order of descending
      preference.
    </param>
    <param name='defaultValue'>The value to return if no matching language tag was found.
    </param>
    <returns>The matching language tag, or the parameter
      <paramref name='defaultValue'/>
       if there is no matching language tag.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='languages'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='range'/>
       is not a basic language range, or
      <paramref name='languages'/>
       contains a value that is not a potentially valid language tag.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.LanguageTagLookup(System.String,System.Collections.Generic.IList{System.String},System.String,System.Boolean)'>
    <summary>Does a language tag lookup (under RFC 4647) for a matching language tag.
    </summary>
    <param name='range'>A language range (see the documentation for "IsLanguageRange").
    </param>
    <param name='languages'>A list of language tags, which should be given in order of descending
      preference.
    </param>
    <param name='defaultValue'>The value to return if no matching language tag was found.
    </param>
    <param name='extended'>If true, "range" is an extended language range; otherwise, it's a are
      basic language range.
    </param>
    <returns>The matching language tag, or the parameter
      <paramref name='defaultValue'/>
       if there is no matching language tag.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='languages'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='range'/>
       is not a basic or extended language range, or
      <paramref name='languages'/>
       contains a value that is not a potentially valid language tag.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.MatchesLanguageTag(System.String,System.String)'>
    <summary>Determines whether the given language tag matches the given language
      range.
    </summary>
    <param name='range'>A basic language range (see the documentation for "IsLanguageRange").
    </param>
    <param name='tag'>A language tag.
    </param>
    <returns><c>true</c> if the language tag matches the language range by the filtering method
      under RFC 4647; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='range'/>
       is not a basic language range, or
      <paramref name='tag'/>
       is not a potentially valid language tag.
    </exception>
  </doc>
  <doc name='T:PeterO.Mail.MailDateTime'>
    <summary>Contains methods for parsing and generating date-time strings following
      the Internet Message Format (RFC 5322).
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.MailDateTime.GenerateDateString(System.Int32[])'>
    <summary>Generates a date-time string following the Internet Message Format (RFC
      5322) from an 8-element array.
    </summary>
    <param name='dateTime'>The date and time in the form of an 8-element array. See
      <see cref='PeterO.Mail.MailDateTime.ParseDateString(System.String,System.Boolean)'/>
       for information on the format of this parameter.
    </param>
    <returns>A date-time string.
    </returns>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='dateTime'/>
       is null or invalid, including if the year (
      <c>dateTime[0]</c> ) is less than 0.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.MailDateTime.GenerateDateString(System.Int32[],System.Boolean)'>
    <summary>Generates a date-time string following the Internet Message Format (RFC
      5322) from an 8-element array.
    </summary>
    <param name='dateTime'>The date and time in the form of an 8-element array. See
      <see cref='PeterO.Mail.MailDateTime.ParseDateString(System.String,System.Boolean)'/>
       for information on the format of this parameter.
    </param>
    <param name='gmt'>The parameter
      <paramref name='gmt'/>
       is not documented yet.
    </param>
    <returns>A date-time string.
    </returns>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='dateTime'/>
       is null or invalid, including if the year (
      <c>dateTime[0]</c> ) is less than 0.
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='dateTime'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.MailDateTime.ParseDateString(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is not documented yet.
    </param>
    <returns>An array of 32-bit unsigned integers.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MailDateTime.ParseDateString(System.String,System.Boolean)'>
    <summary>Gets the date and time extracted from a date-time string following the
      Internet Message Format (RFC 5322), with an option to allow obsolete time
      zone strings to appear in the date-time string. If an array is returned,
      the elements of that array (starting from 0) are as follows:
      <list>
        <item>0 - The year. For example, the value 2000 means 2000 C.E.
        </item>
        <item>1 - Month of the year, from 1 (January) through 12 (December).
        </item>
        <item>2 - Day of the month, from 1 through 31.
        </item>
        <item>3 - Hour of the day, from 0 through 23.
        </item>
        <item>4 - Minute of the hour, from 0 through 59.
        </item>
        <item>5 - Second of the minute, from 0 through 60 (this value can go up to
          60 to accommodate leap seconds). (Leap seconds are additional seconds
          added to adjust international atomic time, or TAI, to an approximation
          of astronomical time known as coordinated universal time, or UTC.)
        </item>
        <item>6 - Milliseconds of the second, from 0 through 999. Will always be 0.
        </item>
        <item>7 - Number of minutes to subtract from this date and time to get
          global time. This number can be positive or negative.
        </item>
      </list>
    </summary>
    <param name='str'>A date-time string.
    </param>
    <param name='parseObsoleteZones'>If set to
      <c>true</c> , this method allows obsolete time zones (single-letter time zones,
      "GMT", "UT", and certain three-letter combinations) to appear in the
      date-time string.
    </param>
    <returns>An 8-element array containing the date and time, or
      <c>null</c> if
      <paramref name='str'/>
       is null, empty, or syntactically invalid, or if the string's year would
      overflow the range of a 32-bit signed integer.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.MailDateTime.ParseDateStringHttp(System.String)'>
    <summary>Parses a date string in one of the three formats allowed by HTTP/1.1.
    </summary>
    <param name='v'>A date-time string.
    </param>
    <returns>A 64-bit signed integer.
    </returns>
  </doc>
  <doc name='T:PeterO.Mail.MediaType'>
    <summary><para>Specifies what kind of data a message body is.
      </para>
      <para>A media type consists of a top-level type (the general category of the
        data), a subtype (the specific type), and an optional list of
        parameters. For example, the media type
        <c>text/plain;charset=utf-8</c> is a text media type ("text"), namely, a plain text type ("plain"), and
        the parameters say that the data uses UTF-8, a Unicode character
        encoding ("charset = utf-8"). Other top-level types include "audio",
        "video", and "application".
      </para>
      <para>A media type is sometimes known as a "MIME type", for Multipurpose
        Internet Mail Extensions, the standard that introduced media types.
      </para>
      <para>This type is immutable, meaning its values can't be changed once it' s
        created. To create a changeable media type object, use the
        MediaTypeBuilder class.
      </para>
      <para><b>Note:</b> According to RFC 2049, unrecognized subtypes of the top-level type
        <c>multipart</c> must be treated as
        <c>multipart/mixed</c> and unrecognized media types as the media type
        <c>application/octet-stream</c> .
      </para>
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.MediaType.ApplicationOctetStream'>
    <summary>Specifies the media type "application/octet-stream", used for arbitrary
      binary data.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.Equals(System.Object)'>
    <summary>Determines whether this object and another object are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if this object and another object are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.GetCharset'>
    <summary>Gets this media type's "charset" parameter, naming a character encoding
      used to represent text in the data that uses this media type.
    </summary>
    <returns>If the "charset" parameter is present and non-empty, returns the result of
      the Encodings.ResolveAliasForEmail method for that parameter, except that
      result's basic upper-case letters A to Z (U+0041 to U+005A) are converted
      to lower case. If the "charset" parameter is absent or empty, returns the
      default value, if any, for that parameter given the media type (e.g.,
      "us-ascii" if the media type is "text/plain"; see RFC2046), or the empty
      string if there is none.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.GetHashCode'>
    <summary>Calculates the hash code of this object. No application or process IDs are
      used in the hash code calculation.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.GetParameter(System.String)'>
    <summary>Gets the value of a parameter in this media type, such as "charset" or
      "format".
    </summary>
    <param name='name'>Name of the parameter to get. The name is compared using a basic
      case-insensitive comparison. (Two strings are equal in such a comparison,
      if they match after converting the basic upper-case letters A to Z (U+0041
      to U+005A) in both strings to lower case.).
    </param>
    <returns>The value of the parameter as a string, or null if the parameter doesn't
      exist.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='name'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>Name is empty.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.MediaType.IsMultipart'>
    <summary>Gets a value indicating whether this is a multipart media type.
    </summary>
    <value><c>true</c> If this is a multipart media type; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Mail.MediaType.IsText'>
    <summary>Gets a value indicating whether this is a text media type ("text/*").
    </summary>
    <value><c>true</c> If this is a text media type; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='F:PeterO.Mail.MediaType.MessageRfc822'>
    <summary>Specifies the media type "message/rfc822", used for Internet mail
      messages.
    </summary>
  </doc>
  <doc name='P:PeterO.Mail.MediaType.Parameters'>
    <summary>Gets a list of the parameters contained in this media type object.
    </summary>
    <value>A list of the parameters contained in this media type object; the names of
      each parameter appear in an undefined order. NOTE: Previous versions
      erroneously stated that the list will be sorted by name. In fact, the
      names will not be guaranteed to appear in any particular order; this is at
      least the case in version 0.10.0.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.Parse(System.String)'>
    <summary>Parses a media type string and returns a media type object. For further
      information, see the overload taking a MediaType parameter.
    </summary>
    <param name='mediaTypeValue'>A text string representing a media type. This media type can include
      parameters.
    </param>
    <returns>A media type object, or MediaType.TextPlainAscii if
      <paramref name='mediaTypeValue'/>
       is empty or syntactically invalid.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.Parse(System.String,PeterO.Mail.MediaType)'>
    <summary>Parses a media type string and returns a media type object, or the default
      value if the string is invalid. This method checks the syntactic validity
      of the string, but not whether it has all parameters it's required to have
      or whether the parameters themselves are set to valid values for the
      parameter.
      <para>This method assumes the given media type string was directly extracted
        from the Content-Type header field (as defined for email messages) and
        follows the syntax given in RFC 2045. Accordingly, among other things,
        the media type string can contain comments (delimited by parentheses).
      </para>
      <para>RFC 2231 extensions allow each media type parameter to be associated
        with a character encoding and/or language, and support parameter values
        that span two or more key-value pairs. Parameters making use of RFC 2231
        extensions have names with an asterisk ("*"). Such a parameter will be
        ignored if it is ill-formed because of RFC 2231's rules (except for
        illegal percent-decoding or undecodable sequences for the given
        character encoding). Examples of RFC 2231 extensions follow (both
        examples encode the same "filename" parameter):
      </para>
      <para><b>text/example; filename*=utf-8'en'filename.txt</b> </para>
      <para><b>text/example; filename*0*=utf-8'en'file; filename*1*=name%2Etxt</b> </para>
      <para>This implementation ignores keys (in parameter key-value pairs) that
        appear more than once in the media type. Nothing in RFCs 2045, 2183,
        2231, 6266, or 7231 explicitly disallows such keys, or otherwise
        specifies error-handling behavior for such keys.
      </para>
    </summary>
    <param name='str'>A text string representing a media type. This media type can include
      parameters.
    </param>
    <param name='defaultValue'>The media type to return if the string is syntactically invalid. Can be
      null.
    </param>
    <returns>A MediaType object.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='F:PeterO.Mail.MediaType.QuotedStringRule.Http'>
    <summary>Use HTTP rules for quoted strings.
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.MediaType.QuotedStringRule.Rfc5322'>
    <summary>Use Internet Message Format rules for quoted strings.
    </summary>
  </doc>
  <doc name='P:PeterO.Mail.MediaType.SubType'>
    <summary>Gets this media type's subtype (for example, "plain" in "text/plain"). The
      resulting string will be in lowercase letters.
    </summary>
    <value>This media type's subtype.
    </value>
  </doc>
  <doc name='F:PeterO.Mail.MediaType.TextPlainAscii'>
    <summary>Specifies the media type "text/plain" and the "charset" parameter
      "US-ASCII", used for plain text data.
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.MediaType.TextPlainUtf8'>
    <summary>Specifies the media type "text/plain" and the "charset" parameter "utf-8",
      used for plain text data that may contain characters outside the basic
      Latin range (U+0000 to U+007F).
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.ToSingleLineString'>
    <summary>Converts this media type to a text string form suitable for inserting in
      HTTP headers. Notably, the string contains the value of a Content-Type
      header field (without the text necessarily starting with "Content-Type"
      followed by a space), and consists of a single line.
    </summary>
    <returns>A text string form of this media type.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.ToString'>
    <summary>Converts this media type to a text string form suitable for inserting in
      email headers. Notably, the string contains the value of a Content-Type
      header field (without the text necessarily starting with "Content-Type"
      followed by a space), and consists of one or more lines.
    </summary>
    <returns>A text string form of this media type.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.ToUriSafeString'>
    <summary>Converts this media type to a text string form suitable for data URIs.
      Notably, the string contains the value of a Content-Type header field
      (without the text necessarily starting with "Content-Type" followed by a
      space), consists of a single line, and uses percent-encoding as necessary
      or convenient so that the resulting string can validly appear in a URI
      path.
    </summary>
    <returns>A text string form of this media type.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.MediaType.TopLevelType'>
    <summary>Gets the name of this media type's top-level type (such as "text" in
      "text/plain", or "audio" in "audio/basic"). The resulting string will be
      in lowercase letters.
    </summary>
    <value>The name of this media type's top-level type (such as "text" or "audio" .
    </value>
  </doc>
  <doc name='P:PeterO.Mail.MediaType.TypeAndSubType'>
    <summary>Gets the top level type and subtype of this media type, separated by a
      slash; for example, "text/plain". The resulting string will be in
      lowercase letters.
    </summary>
    <value>The top level type and subtype of this media type, separated by a slash;
      for example, "text/plain".
    </value>
  </doc>
  <doc name='T:PeterO.Mail.MediaTypeBuilder'>
    <summary>A mutable media type object.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.MediaTypeBuilder'/>
       class.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.#ctor(PeterO.Mail.MediaType)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.MediaTypeBuilder'/>
       class.
    </summary>
    <param name='mt'>The parameter
      <paramref name='mt'/>
       is a MediaType object.
    </param>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='mt'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.#ctor(System.String,System.String)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.MediaTypeBuilder'/>
       class.
    </summary>
    <param name='type'>The parameter
      <paramref name='type'/>
       is a text string.
    </param>
    <param name='subtype'>The parameter
      <paramref name='subtype'/>
       is a text string.
    </param>
  </doc>
  <doc name='P:PeterO.Mail.MediaTypeBuilder.IsMultipart'>
    <summary>Gets a value indicating whether this is a multipart media type.
    </summary>
    <value><c>true</c> If this is a multipart media type; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Mail.MediaTypeBuilder.IsText'>
    <summary>Gets a value indicating whether this is a text media type.
    </summary>
    <value><c>true</c> If this is a text media type; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.RemoveParameter(System.String)'>
    <summary>Removes a parameter from this builder object. Does nothing if the
      parameter's name doesn't exist.
    </summary>
    <param name='name'>Name of the parameter to remove. The name is compared using a basic
      case-insensitive comparison. (Two strings are equal in such a comparison,
      if they match after converting the basic upper-case letters A to Z (U+0041
      to U+005A) in both strings to lower case.).
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='name'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.SetParameter(System.String,System.String)'>
    <summary>Sets a parameter's name and value for this media type.
    </summary>
    <param name='name'>Name of the parameter to set, such as "charset" . The name is compared
      using a basic case-insensitive comparison. (Two strings are equal in such
      a comparison, if they match after converting the basic upper-case letters
      A to Z (U+0041 to U+005A) in both strings to lower case.).
    </param>
    <param name='value'>A text string giving the parameter's value.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='value'/>
       or
      <paramref name='name'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='name'/>
       is empty or syntactically invalid.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.SetSubType(System.String)'>
    <summary>Sets this media type's subtype, such as "plain" or "xml" .
    </summary>
    <param name='str'>A text string naming a media subtype.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='str'/>
       is empty or syntactically invalid.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.SetTopLevelType(System.String)'>
    <summary>Sets this media type's top-level type.
    </summary>
    <param name='str'>A text string naming a top-level type, such as "text" or "audio" .
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='str'/>
       is syntactically invalid for a top-level type.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.MediaTypeBuilder.SubType'>
    <summary>Gets or sets this value's subtype.
    </summary>
    <value>This value's subtype.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.ToMediaType'>
    <summary>Converts this builder to an immutable media type object.
    </summary>
    <returns>A MediaType object.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.ToString'>
    <summary>Converts this object to a text string of the media type it represents, in
      the same form as
      <c>MediaType.ToString</c> .
    </summary>
    <returns>A string representation of this object.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.MediaTypeBuilder.TopLevelType'>
    <summary>Gets or sets this value's top-level type.
    </summary>
    <value>This value's top-level type.
    </value>
  </doc>
  <doc name='T:PeterO.Mail.Message'>
    <summary><para>Represents an email message, and contains methods and properties for
        accessing and modifying email message data. This class implements the
        Internet Message Format (RFC 5322) and Multipurpose Internet Mail
        Extensions (MIME; RFC 2045-2047, RFC 2049).
      </para>
      <para><b>Thread safety:</b> This class is mutable; its properties can be changed. None of its
        instance methods are designed to be thread safe. Therefore, access to
        objects from this class must be synchronized if multiple threads can
        access them at the same time.
      </para>
      <para>The following lists known deviations from the mail specifications
        (Internet Message Format and MIME):
      </para>
      <list type=''>
        <item>The content-transfer-encodings "quoted-printable" and "base64" are
          treated as 7bit instead if they occur in a message or body part with
          content type "multipart/*" or "message/*" (other than
          "message/global", "message/global-headers",
          "message/global-disposition-notification", or
          "message/global-delivery-status").
        </item>
        <item>If a message has two or more Content-Type header fields, it is treated
          as having a content type of "application/octet-stream", unless one or
          more of the header fields is syntactically invalid.
        </item>
        <item>Illegal UTF-8 byte sequences appearing in header field values are
          replaced with replacement characters. Moreover, UTF-8 is parsed
          everywhere in header field values, even in those parts of some
          structured header fields where this appears not to be allowed. (UTF-8
          is a character encoding for the Unicode character set.)
        </item>
        <item>This implementation can parse a message even if that message is
          without a From header field, without a Date header field, or without
          both.
        </item>
        <item>The To and Cc header fields are allowed to contain only comments and
          whitespace, but these "empty" header fields will be omitted when
          generating.
        </item>
        <item>There is no line length limit imposed when parsing header fields,
          except header field names.
        </item>
        <item>There is no line length limit imposed when parsing quoted-printable or
          base64 encoded bodies.
        </item>
        <item>If the transfer encoding is absent and the content type is
          "message/rfc822", bytes with values greater than 127 (called "8-bit
          bytes" in the rest of this summary) are still allowed, despite the
          default value of "7bit" for "Content-Transfer-Encoding".
        </item>
        <item>In the following cases, if the transfer encoding is absent, declared
          as 7bit, or treated as 7bit, 8-bit bytes are still allowed:
        </item>
        <item>(a) The preamble and epilogue of multipart messages, which will be
          ignored.
        </item>
        <item>(b) If the charset is declared to be
          <c>utf-8</c> .
        </item>
        <item>(c) If the content type is "text/html" and the charset is declared to
          be
          <c>us-ascii</c> , "windows-1252", "windows-1251", or "iso-8859-*" (all single byte
          encodings).
        </item>
        <item>(d) In non-MIME message bodies and in text/plain message bodies. Any
          8-bit bytes are replaced with the substitute character byte (0x1a).
        </item>
        <item>If the message starts with the word "From" (and no other case
          variations of that word) followed by one or more space (U+0020) not
          followed by colon, that text and the rest of the text is skipped up to
          and including a line feed (U+000A). (See also RFC 4155, which
          describes the so-called "mbox" convention with "From" lines of this
          kind.)
        </item>
        <item>The name
          <c>ascii</c> is treated as a synonym for
          <c>us-ascii</c> , despite being a reserved name under RFC 2046. The name
          <c>cp1252</c> and
          <c>utf8</c> are treated as synonyms for
          <c>windows-1252</c> and
          <c>utf-8</c> , respectively, even though they are not IANA registered aliases.
        </item>
        <item>The following deviations involve encoded words under RFC 2047:
        </item>
        <item>(a) If a sequence of encoded words decodes to a string with a CTL
          character (U+007F, or a character less than U+0020 and not TAB) after
          being converted to Unicode, the encoded words are left un-decoded.
        </item>
        <item>(b) This implementation can decode encoded words regardless of the
          character length of the line in which they appear. This implementation
          can generate a header field line with one or more encoded words even
          if that line is more than 76 characters long. (This implementation
          follows the recommendation in RFC 5322 to limit header field lines to
          no more than 78 characters, where possible.)
        </item>
      </list>
      <para>It would be appreciated if users of this library contact the author if
        they find other ways in which this implementation deviates from the mail
        specifications or other applicable specifications.
      </para>
      <para>Note that this class currently doesn't support the "padding" parameter
        for message bodies with the media type "application/octet-stream" or
        treated as that media type (see RFC 2046 sec. 4.5.1).
      </para>
      <para>Note that this implementation can decode an RFC 2047 encoded word that
        uses ISO-2022-JP or ISO-2022-JP-2 (encodings that uses code switching)
        even if the encoded word's payload ends in a different mode from "ASCII
        mode". (Each encoded word still starts in "ASCII mode", though.) This,
        however, is not a deviation to RFC 2047 because the relevant rule only
        concerns bringing the output device back to "ASCII mode" after the
        decoded text is displayed (see last paragraph of sec. 6.2) -- since the
        decoded text is converted to Unicode rather than kept as ISO-2022-JP or
        ISO-2022-JP-2, this is not applicable since there is no such thing as
        "ASCII mode" in the Unicode Standard.
      </para>
      <para>Note that this library (the MailLib library) has no facilities for
        sending and receiving email messages, since that's outside this
        library's scope.
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.Message.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.Message'/>
       class.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.Message.#ctor(System.Byte[])'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.Message'/>
       class.
    </summary>
    <param name='bytes'>A byte array.
    </param>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='bytes'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.#ctor(System.IO.Stream)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.Message'/>
       class.
    </summary>
    <param name='stream'>The parameter
      <paramref name='stream'/>
       is a Stream object.
    </param>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddAttachment(PeterO.Mail.MediaType)'>
    <summary>Adds an attachment with an empty body and with the given media type to
      this message. Before the new attachment is added, if this message isn't
      already a multipart message, it becomes a "multipart/mixed" message with
      the current body converted to an inline body part.
    </summary>
    <param name='mediaType'>A media type to assign to the attachment.
    </param>
    <returns>A Message object for the generated attachment.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddAttachment(System.IO.Stream,PeterO.Mail.MediaType)'>
    <summary>Adds an attachment to this message in the form of data from the given
      readable stream, and with the given media type. Before the new attachment
      is added, if this message isn't already a multipart message, it becomes a
      "multipart/mixed" message with the current body converted to an inline
      body part.
    </summary>
    <param name='inputStream'>A readable data stream.
    </param>
    <param name='mediaType'>A media type to assign to the attachment.
    </param>
    <returns>A Message object for the generated attachment.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='inputStream'/>
       or
      <paramref name='mediaType'/>
       is null.
    </exception>
    <exception cref='PeterO.Mail.MessageDataException'>An I/O error occurred.
    </exception>
    <example>The following example (written in C# for the.NET version) is an extension
      method that adds an attachment from a byte array to a message.
      <code>public static Message AddAttachmentFromBytes(this Message msg, byte[]
        bytes, MediaType mediaType) { using (var fs = new MemoryStream(bytes)) {
        return msg.AddAttachment(fs, mediaType); } }</code> .
    </example>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddAttachment(System.IO.Stream,PeterO.Mail.MediaType,System.String)'>
    <summary>Adds an attachment to this message in the form of data from the given
      readable stream, and with the given media type and file name. Before the
      new attachment is added, if this message isn't already a multipart
      message, it becomes a "multipart/mixed" message with the current body
      converted to an inline body part.
    </summary>
    <param name='inputStream'>A readable data stream.
    </param>
    <param name='mediaType'>A media type to assign to the attachment.
    </param>
    <param name='filename'>A file name to assign to the attachment. Can be null or empty, in which
      case no file name is assigned. Only the file name portion of this
      parameter is used, which in this case means the portion of the string
      after the last "/" or "\", if either character exists, or the entire
      string otherwise.
    </param>
    <returns>A Message object for the generated attachment.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='inputStream'/>
       or
      <paramref name='mediaType'/>
       is null.
    </exception>
    <exception cref='PeterO.Mail.MessageDataException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddAttachment(System.IO.Stream,System.String)'>
    <summary>Adds an attachment to this message in the form of data from the given
      readable stream, and with the given file name. Before the new attachment
      is added, if this message isn't already a multipart message, it becomes a
      "multipart/mixed" message with the current body converted to an inline
      body part.
    </summary>
    <param name='inputStream'>A readable data stream.
    </param>
    <param name='filename'>A file name to assign to the attachment. Can be null or empty, in which
      case no file name is assigned. Only the file name portion of this
      parameter is used, which in this case means the portion of the string
      after the last "/" or "\", if either character exists, or the entire
      string otherwise An appropriate media type (or "application/octet-stream")
      will be assigned to the attachment based on this file name's extension. If
      the file name has an extension .txt, .text, .htm, .html, .shtml, .asc,
      .brf, .pot, .rst, .md, .markdown, or .srt, the media type will have a
      "charset" of "utf-8".
    </param>
    <returns>A Message object for the generated attachment.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='inputStream'/>
       is null.
    </exception>
    <exception cref='PeterO.Mail.MessageDataException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddHeader(System.Collections.Generic.KeyValuePair{System.String,System.String})'>
    <summary>Adds a header field to the end of the message's header.
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='header'>A key/value pair. The key is the name of the header field, such as "From"
      or "Content-ID". The value is the header field's value.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentNullException'>The key or value of
      <paramref name='header'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The header field name is too long or contains an invalid character, or the
      header field's value is syntactically invalid.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddHeader(System.String,System.String)'>
    <summary>Adds a header field to the end of the message's header.
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='name'>Name of a header field, such as "From" or "Content-ID" .
    </param>
    <param name='value'>Value of the header field.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='name'/>
       or
      <paramref name='value'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The header field name is too long or contains an invalid character, or the
      header field's value is syntactically invalid.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddInline(PeterO.Mail.MediaType)'>
    <summary>Adds an inline body part with an empty body and with the given media type
      to this message. Before the new body part is added, if this message isn't
      already a multipart message, it becomes a "multipart/mixed" message with
      the current body converted to an inline body part.
    </summary>
    <param name='mediaType'>A media type to assign to the body part.
    </param>
    <returns>A Message object for the generated body part.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddInline(System.IO.Stream,PeterO.Mail.MediaType)'>
    <summary>Adds an inline body part to this message in the form of data from the
      given readable stream, and with the given media type. Before the new body
      part is added, if this message isn't already a multipart message, it
      becomes a "multipart/mixed" message with the current body converted to an
      inline body part.
    </summary>
    <param name='inputStream'>A readable data stream.
    </param>
    <param name='mediaType'>A media type to assign to the body part.
    </param>
    <returns>A Message object for the generated body part.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='inputStream'/>
       or
      <paramref name='mediaType'/>
       is null.
    </exception>
    <exception cref='PeterO.Mail.MessageDataException'>An I/O error occurred.
    </exception>
    <example>The following example (written in C# for the.NET version) is an extension
      method that adds an inline body part from a byte array to a message.
      <code>public static Message AddInlineFromBytes(this Message msg, byte[] bytes,
        MediaType mediaType) { using (MemoryStream fs = new MemoryStream(bytes))
        { return msg.AddInline(fs, mediaType); } }</code> .
    </example>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddInline(System.IO.Stream,PeterO.Mail.MediaType,System.String)'>
    <summary>Adds an inline body part to this message in the form of data from the
      given readable stream, and with the given media type and file name. Before
      the new body part is added, if this message isn't already a multipart
      message, it becomes a "multipart/mixed" message with the current body
      converted to an inline body part.
    </summary>
    <param name='inputStream'>A readable data stream.
    </param>
    <param name='mediaType'>A media type to assign to the body part.
    </param>
    <param name='filename'>A file name to assign to the body part.
    </param>
    <returns>A Message object for the generated body part.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='inputStream'/>
       or
      <paramref name='mediaType'/>
       is null.
    </exception>
    <exception cref='PeterO.Mail.MessageDataException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddInline(System.IO.Stream,System.String)'>
    <summary>Adds an inline body part to this message in the form of data from the
      given readable stream, and with the given file name. Before the new body
      part is added, if this message isn't already a multipart message, it
      becomes a "multipart/mixed" message with the current body converted to an
      inline body part.
    </summary>
    <param name='inputStream'>A readable data stream.
    </param>
    <param name='filename'>A file name to assign to the inline body part. Can be null or empty, in
      which case no file name is assigned. Only the file name portion of this
      parameter is used, which in this case means the portion of the string
      after the last "/" or "\", if either character exists, or the entire
      string otherwise An appropriate media type (or "application/octet-stream")
      will be assigned to the body part based on this file name's extension. If
      the file name has an extension .txt, .text, .htm, .html, .shtml, .asc,
      .brf, .pot, .rst, .md, .markdown, or .srt, the media type will have a
      "charset" of "utf-8".
    </param>
    <returns>A Message object for the generated body part.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='inputStream'/>
       or "mediaType" is null.
    </exception>
    <exception cref='PeterO.Mail.MessageDataException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.Message.BccAddresses'>
    <summary>Gets a list of addresses found in the BCC header field or fields.
    </summary>
    <value>A list of addresses found in the BCC header field or fields.
    </value>
  </doc>
  <doc name='P:PeterO.Mail.Message.BodyString'>
    <summary>Gets the body of this message as a text string.
    </summary>
    <value>The body of this message as a text string.
    </value>
    <exception cref='System.NotSupportedException'>Either this message is a multipart message, so it doesn't have its own
      body text, or this message has no character encoding declared or assumed
      for it (which is usually the case for non-text messages), or the character
      encoding is not supported.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.Message.CCAddresses'>
    <summary>Gets a list of addresses found in the CC header field or fields.
    </summary>
    <value>A list of addresses found in the CC header field or fields.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Message.ClearHeaders'>
    <summary>Deletes all header fields in this message. Also clears this message's
      content disposition and resets its content type to
      MediaType.TextPlainAscii.
    </summary>
    <returns>This object.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.Message.ContentDisposition'>
    <summary>Gets or sets this message's content disposition. The content disposition
      specifies how a user agent should display or otherwise handle this
      message. Can be set to null. If set to a disposition or to null, updates
      the Content-Disposition header field as appropriate.
    </summary>
    <value>This message's content disposition, or null if none is specified.
    </value>
  </doc>
  <doc name='P:PeterO.Mail.Message.ContentType'>
    <summary>Gets or sets this message's media type. When getting, the media type may
      differ in certain cases from the value of the Content-Type header field,
      if any, and may have a value even if the Content-Type header field is
      absent from this message. If set to a media type, updates the Content-Type
      header field as appropriate. Cannot be set to null.
    </summary>
    <value>This message's media type.
    </value>
    <exception cref='System.ArgumentNullException'>This value is being set and "value" is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.DecodeHeaderValue(System.String,System.String)'>
    <summary>Decodes RFC 2047 encoded words from the given header field value and
      returns a string with those words decoded. For an example of encoded
      words, see the constructor for PeterO.Mail.NamedAddress.
    </summary>
    <param name='name'>Name of the header field. This determines the syntax of the "value"
      parameter and is necessary to help this method interpret encoded words
      properly.
    </param>
    <param name='value'>A header field value that could contain encoded words. For example, if the
      name parameter is "From", this parameter could be "=?utf-8?q?me?=
      &lt;me@example.com&gt;".
    </param>
    <returns>The header field value with valid encoded words decoded.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='name'/>
       is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.Message.FileName'>
    <summary><para>Gets a file name suggested by this message for saving the message's body
        to a file. For more information on the algorithm, see
        ContentDisposition.MakeFilename.
      </para>
      <para>This method generates a file name based on the
        <c>filename</c> parameter of the Content-Disposition header field, if it exists, or on
        the
        <c>name</c> parameter of the Content-Type header field, otherwise.
      </para>
    </summary>
    <value>A suggested name for the file. Returns the empty string if there is no
      filename suggested by the content type or content disposition, or if that
      filename is an empty string.
    </value>
  </doc>
  <doc name='P:PeterO.Mail.Message.FromAddresses'>
    <summary>Gets a list of addresses found in the From header field or fields.
    </summary>
    <value>A list of addresses found in the From header field or fields.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Message.FromMailtoUri(System.String)'>
    <summary>Creates a message object from a MailTo URI (uniform resource identifier).
      The MailTo URI can contain key-value pairs that follow a question-mark, as
      in the following example: "mailto:me@example.com?subject=A%20Subject". In
      this example, "subject" is the subject of the email address. Only certain
      keys are supported, namely, "to", "cc", "bcc", "subject", "in-reply-to",
      "comments", "keywords", and "body". The first seven are header field names
      that will be used to set the returned message's corresponding header
      fields. The last, "body", sets the body of the message to the given text.
      Keys other than these eight will be ignored.
    </summary>
    <param name='uri'>The parameter
      <paramref name='uri'/>
       is a text string.
    </param>
    <returns>A Message object created from the given MailTo URI. Returs null if
      <paramref name='uri'/>
       is null, is syntactically invalid, or is not a MailTo URI.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.FromMailtoUri(System.Uri)'>
    <summary>Not documented yet.
    </summary>
    <param name='uri'>The parameter
      <paramref name='uri'/>
       is not documented yet.
    </param>
    <returns>A Message object.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='uri'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.FromMailtoUrl(System.String)'>
    <summary>Creates a message object from a MailTo URI (uniform resource identifier).
      The MailTo URI can contain key-value pairs that follow a question-mark, as
      in the following example: "mailto:me@example.com?subject=A%20Subject". In
      this example, "subject" is the subject of the email address. Only certain
      keys are supported, namely, "to", "cc", "bcc", "subject", "in-reply-to",
      "comments", "keywords", and "body". The first seven are header field names
      that will be used to set the returned message's corresponding header
      fields. The last, "body", sets the body of the message to the given text.
      Keys other than these eight will be ignored.
    </summary>
    <param name='url'>A MailTo URI.
    </param>
    <returns>A Message object created from the given MailTo URI. Returs null if
      <paramref name='url'/>
       is null, is syntactically invalid, or is not a MailTo URI.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.Generate'>
    <summary>Generates this message's data in text form.
      <para>The generated message will have only Basic Latin code points (U+0000 to
        U+007F), and the transfer encoding will always be 7bit,
        quoted-printable, or base64 (the declared transfer encoding for this
        message will be ignored).
      </para>
      <para>The following applies to the following header fields: From, To, Cc, Bcc,
        Reply-To, Sender, Resent-To, Resent-From, Resent-Cc, Resent-Bcc, and
        Resent-Sender. If the header field exists, but has an invalid syntax,
        has no addresses, or appears more than once, this method will generate a
        synthetic header field with the display-name set to the contents of all
        of the header fields with the same name, and the address set to
        <c>me@[header-name]-address.invalid</c> as the address (a
        <c>.invalid</c> address is a reserved address that can never belong to anyone). (An
        exception is that the Resent-* header fields may appear more than once.)
        The generated message should always have a From header field.
      </para>
      <para>If a Date and/or Message-ID header field doesn't exist, a field with
        that name will be generated (using the current local time for the Date
        field).
      </para>
      <para>When encoding the message's body, if the message has a text content type
        ("text/*"), the line breaks are a CR byte (carriage return, 0x0d)
        followed by an LF byte (line feed, 0x0a), CR alone, or LF alone. If the
        message has any other content type, only CR followed by LF is considered
        a line break.
      </para>
    </summary>
    <returns>The generated message.
    </returns>
    <exception cref='PeterO.Mail.MessageDataException'>The message can't be generated.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.GenerateBytes'>
    <summary>Generates this message's data as a byte array, using the same algorithm as
      the Generate method.
    </summary>
    <returns>The generated message as a byte array.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.GetAddresses(System.String)'>
    <summary>Gets a list of addresses contained in the header fields with the given
      name in this message.
    </summary>
    <param name='headerName'>The name of the header fields to retrieve.
    </param>
    <returns>A list of addresses, in the order in which they appear in this message's
      header fields of the given name.
    </returns>
    <exception cref='System.NotSupportedException'>The parameter
      <paramref name='headerName'/>
       is not supported for this method. Currently, the only header fields
      supported are To, Cc, Bcc, Reply-To, Sender, and From.
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='headerName'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='headerName'/>
       is empty.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.GetBody'>
    <summary>Gets the byte array for this message's body. This method doesn' t make a
      copy of that byte array.
    </summary>
    <returns>A byte array.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.GetBodyMessage'>
    <summary>Returns the mail message contained in this message's body.
    </summary>
    <returns>A message object if this object's content type is "message/rfc822",
      "message/news", or "message/global", or null otherwise.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.GetDate'>
    <summary>Not documented yet.
    </summary>
    <returns>An array of 32-bit unsigned integers.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.GetFormattedBodyString'>
    <summary><para>Gets a Hypertext Markup Language (HTML) rendering of this message's text
        body. This method currently supports text/plain, text/plain with format
        = flowed, text/enriched, and text/markdown (original Markdown).
      </para>
    </summary>
    <returns>An HTML rendering of this message's text.
    </returns>
    <exception cref='System.NotSupportedException'>Either this message is a multipart message, so it doesn't have its own
      body text, or this message has no character encoding declared or assumed
      for it (which is usually the case for non-text messages), or the character
      encoding is not supported.
    </exception>
    <remarks>
      <para>REMARK: The Markdown implementation currently supports all features of
        original Markdown, except that the implementation--
      </para>
      <list>
        <item>does not strictly check the placement of "block-level HTML elements",
        </item>
        <item>does not prevent Markdown content from being interpreted as such
          merely because it's contained in a "block-level HTML element", and
        </item>
        <item>does not deliberately use HTML escapes to obfuscate email addresses
          wrapped in angle-brackets.
        </item>
      </list>
    </remarks>
  </doc>
  <doc name='M:PeterO.Mail.Message.GetHeader(System.Int32)'>
    <summary>Gets the name and value of a header field by index.
    </summary>
    <param name='index'>Zero-based index of the header field to get.
    </param>
    <returns>A key/value pair. The key is the name of the header field, such as "From"
      or "Content-ID". The value is the header field's value.
    </returns>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='index'/>
       is 0 or at least as high as the number of header fields.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.GetHeader(System.String)'>
    <summary>Gets the first instance of the header field with the specified name, using
      a basic case-insensitive comparison. (Two strings are equal in such a
      comparison, if they match after converting the basic upper-case letters A
      to Z (U+0041 to U+005A) in both strings to lower case.).
    </summary>
    <param name='name'>The name of a header field.
    </param>
    <returns>The value of the first header field with that name, or null if there is
      none.
    </returns>
    <exception cref='System.ArgumentNullException'>Name is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.GetHeaderArray(System.String)'>
    <summary>Gets an array with the values of all header fields with the specified
      name, using a basic case-insensitive comparison. (Two strings are equal in
      such a comparison, if they match after converting the basic upper-case
      letters A to Z (U+0041 to U+005A) in both strings to lower case.).
    </summary>
    <param name='name'>The name of a header field.
    </param>
    <returns>An array containing the values of all header fields with the given name,
      in the order they appear in the message. The array will be empty if no
      header field has that name.
    </returns>
    <exception cref='System.ArgumentNullException'>Name is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.Message.HeaderFields'>
    <summary>Gets a snapshot of the header fields of this message, in the order in
      which they appear in the message. For each item in the list, the key is
      the header field's name (where any basic upper-case letters [U+0041 to
      U+005A] are converted to lower case) and the value is the header field's
      value.
    </summary>
    <value>A snapshot of the header fields of this message.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Message.MakeMultilingualMessage(System.Collections.Generic.IList{PeterO.Mail.Message},System.Collections.Generic.IList{System.String})'>
    <summary>Generates a multilingual message (see RFC 8255) from a list of messages
      and a list of language strings.
    </summary>
    <param name='messages'>A list of messages forming the parts of the multilingual message object.
      Each message should have the same content, but be in a different language.
      Each message must have a From header field and use the same email address
      in that field as the other messages. The messages should be ordered in
      descending preference of language.
    </param>
    <param name='languages'>A list of language strings corresponding to the messages given in the
      "messages" parameter. A language string at a given index corresponds to
      the message at the same index. Each language string must follow the syntax
      of the Content-Language header field (see LanguageTags.GetLanguageList).
    </param>
    <returns>A Message object with the content type "multipart/multilingual" . It will
      begin with an explanatory body part and be followed by the messages given
      in the
      <paramref name='messages'/>
       parameter in the order given.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='messages'/>
       or
      <paramref name='languages'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='messages'/>
       or
      <paramref name='languages'/>
       is empty, their lengths don't match, at least one message is "null", each
      message doesn't contain the same email addresses in their From header
      fields,
      <paramref name='languages'/>
       contains a syntactically invalid language tag list,
      <paramref name='languages'/>
       contains the language tag "zzx" not appearing alone or at the end of the
      language tag list, or the first message contains no From header field.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.Message.MessageStackEntry.Boundary'>
    <summary>Gets a value which is used in an internal API.
    </summary>
    <value>This is an internal API.
    </value>
  </doc>
  <doc name='P:PeterO.Mail.Message.MessageStackEntry.Message'>
    <summary>Gets a value which is used in an internal API.
    </summary>
    <value>This is an internal API.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Message.NewBodyPart'>
    <summary>Creates a message object with no header fields.
    </summary>
    <returns>A message object with no header fields.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.Message.Parts'>
    <summary>Gets a list of all the parts of this message. This list is editable. This
      will only be used if the message is a multipart message.
    </summary>
    <value>A list of all the parts of this message. This list is editable. This will
      only be used if the message is a multipart message.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Message.RemoveHeader(System.Int32)'>
    <summary>Removes a header field by index.
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='index'>Zero-based index of the header field to set.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='index'/>
       is 0 or at least as high as the number of header fields.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.RemoveHeader(System.String)'>
    <summary>Removes all instances of the given header field from this message. If this
      is a multipart message, the header field is not removed from its body part
      headers. A basic case-insensitive comparison is used. (Two strings are
      equal in such a comparison, if they match after converting the basic
      upper-case letters A to Z (U+0041 to U+005A) in both strings to lower
      case.).
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='name'>The name of the header field to remove.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='name'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SelectLanguageMessage(System.Collections.Generic.IList{System.String})'>
    <summary>Selects a body part for a multiple-language message (
      <c>multipart/multilingual</c> ) according to the given language priority list.
    </summary>
    <param name='languages'>A list of basic language ranges, sorted in descending order of priority
      (see the LanguageTags.LanguageTagFilter method).
    </param>
    <returns>The best matching body part for the given languages. If the body part has
      no subject, then the top-level subject is used. If this message is not a
      multipart/multilingual message or has fewer than two body parts, returns
      this object. If no body part matches the given languages, returns the last
      body part if its language is "zxx", or the second body part otherwise.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='languages'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SelectLanguageMessage(System.Collections.Generic.IList{System.String},System.Boolean)'>
    <summary>Selects a body part for a multiple-language message (
      <c>multipart/multilingual</c> ) according to the given language priority list and original-language
      preference.
    </summary>
    <param name='languages'>A list of basic language ranges, sorted in descending order of priority
      (see the LanguageTags.LanguageTagFilter method).
    </param>
    <param name='preferOriginals'>If true, a body part marked as the original language version is chosen if
      it matches one of the given language ranges, even if the original language
      has a lower priority than another language with a matching body part.
    </param>
    <returns>The best matching body part for the given languages. If the body part has
      no subject, then the top-level subject is used. If this message is not a
      multipart/multilingual message or has fewer than two body parts, returns
      this object. If no body part matches the given languages, returns the last
      body part if its language is "zxx", or the second body part otherwise.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='languages'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetBody(System.Byte[])'>
    <summary>Sets the body of this message to the given byte array. This method doesn't
      make a copy of that byte array.
    </summary>
    <param name='bytes'>A byte array.
    </param>
    <returns>This object.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='bytes'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetCurrentDate'>
    <summary>Sets this message's Date header field to the current time as its value,
      with an unspecified time zone offset.
      <para>This method can be used when the message is considered complete and
        ready to be generated, for example, using the "Generate()" method.
      </para>
    </summary>
    <returns>This object.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetDate(System.Int32[])'>
    <summary>Sets this message's Date header field to the given date and time.
    </summary>
    <param name='dateTime'>An array containing eight elements. Each element of the array (starting
      from 0) is as follows:
      <list>
        <item>0 - The year. For example, the value 2000 means 2000 C.E.
        </item>
        <item>1 - Month of the year, from 1 (January) through 12 (December).
        </item>
        <item>2 - Day of the month, from 1 through 31.
        </item>
        <item>3 - Hour of the day, from 0 through 23.
        </item>
        <item>4 - Minute of the hour, from 0 through 59.
        </item>
        <item>5 - Second of the minute, from 0 through 60 (this value can go up to
          60 to accommodate leap seconds). (Leap seconds are additional seconds
          added to adjust international atomic time, or TAI, to an approximation
          of astronomical time known as coordinated universal time, or UTC.)
        </item>
        <item>6 - Milliseconds of the second, from 0 through 999. This value is not
          used to generate the date string, but must still be valid.
        </item>
        <item>7 - Number of minutes to subtract from this date and time to get
          global time. This number can be positive or negative.
        </item>
      </list>
       .
    </param>
    <returns>This object.
    </returns>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='dateTime'/>
       contains fewer than eight elements, contains invalid values, or contains
      a year less than 0.
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='dateTime'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetHeader(System.Int32,System.Collections.Generic.KeyValuePair{System.String,System.String})'>
    <summary>Sets the name and value of a header field by index.
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='index'>Zero-based index of the header field to set.
    </param>
    <param name='header'>A key/value pair. The key is the name of the header field, such as "From"
      or "Content-ID". The value is the header field's value.
    </param>
    <returns>A Message object.
    </returns>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='index'/>
       is 0 or at least as high as the number of header fields; or, the header
      field name is too long or contains an invalid character, or the header
      field's value is syntactically invalid.
    </exception>
    <exception cref='System.ArgumentNullException'>The key or value of
      <paramref name='header'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetHeader(System.Int32,System.String)'>
    <summary>Sets the value of a header field by index without changing its name.
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='index'>Zero-based index of the header field to set.
    </param>
    <param name='value'>Value of the header field.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='index'/>
       is 0 or at least as high as the number of header fields; or, the header
      field name is too long or contains an invalid character, or the header
      field's value is syntactically invalid.
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='value'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetHeader(System.Int32,System.String,System.String)'>
    <summary>Sets the name and value of a header field by index.
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='index'>Zero-based index of the header field to set.
    </param>
    <param name='name'>Name of a header field, such as "From" or "Content-ID" .
    </param>
    <param name='value'>Value of the header field.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='index'/>
       is 0 or at least as high as the number of header fields; or, the header
      field name is too long or contains an invalid character, or the header
      field's value is syntactically invalid.
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='name'/>
       or
      <paramref name='value'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetHeader(System.String,System.String)'>
    <summary>Sets the value of this message's header field. If a header field with the
      same name exists, its value is replaced. If the header field's name occurs
      more than once, only the first instance of the header field is replaced.
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='name'>The name of a header field, such as "from" or "subject" .
    </param>
    <param name='value'>The header field's value.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentException'>The header field name is too long or contains an invalid character, or the
      header field's value is syntactically invalid.
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='name'/>
       or
      <paramref name='value'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetHtmlBody(System.String)'>
    <summary>Sets the body of this message to the specified string in Hypertext Markup
      Language (HTML) format. The character sequences CR (carriage return, "\r",
      U+000D), LF (line feed, "\n", U+000A), and CR/LF will be converted to
      CR/LF line breaks. Unpaired surrogate code points will be replaced with
      replacement characters.
    </summary>
    <param name='str'>A string consisting of the message in HTML format.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetTextAndHtml(System.String,System.String)'>
    <summary>Sets the body of this message to a multipart body with plain text and
      Hypertext Markup Language (HTML) versions of the same message. The
      character sequences CR (carriage return, "\r", U+000D), LF (line feed,
      "\n", U+000A), and CR/LF will be converted to CR/LF line breaks. Unpaired
      surrogate code points will be replaced with replacement characters.
    </summary>
    <param name='text'>A string consisting of the plain text version of the message.
    </param>
    <param name='html'>A string consisting of the HTML version of the message.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='text'/>
       or
      <paramref name='html'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetTextAndMarkdown(System.String,System.String)'>
    <summary>Sets the body of this message to a multipart body with plain text,
      Markdown, and Hypertext Markup Language (HTML) versions of the same
      message. The character sequences CR (carriage return, "\r", U+000D), LF
      (line feed, "\n", U+000A), and CR/LF will be converted to CR/LF line
      breaks. Unpaired surrogate code points will be replaced with replacement
      characters.
    </summary>
    <param name='text'>A string consisting of the plain text version of the message. Can be null,
      in which case the value of the "markdown" parameter is used as the plain
      text version.
    </param>
    <param name='markdown'>A string consisting of the Markdown version of the message. For
      interoperability, this Markdown version will be converted to HTML.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='markdown'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetTextBody(System.String)'>
    <summary>Sets the body of this message to the specified plain text string. The
      character sequences CR (carriage return, "\r", U+000D), LF (line feed,
      "\n", U+000A), and CR/LF will be converted to CR/LF line breaks. Unpaired
      surrogate code points will be replaced with replacement characters. This
      method changes this message's media type to plain text.
    </summary>
    <param name='str'>A string consisting of the message in plain text format.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.Message.Subject'>
    <summary>Gets or sets this message's subject.
    </summary>
    <value>This message's subject.
    </value>
  </doc>
  <doc name='P:PeterO.Mail.Message.ToAddresses'>
    <summary>Gets a list of addresses found in the To header field or fields.
    </summary>
    <value>A list of addresses found in the To header field or fields.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Message.ToMailtoUri'>
    <summary>Generates a MailTo URI (uniform resource identifier) corresponding to this
      message. The following header fields, and only these, are used to generate
      the URI: To, Cc, Bcc, In-Reply-To, Subject, Keywords, Comments. The
      message body is included in the URI only if this message has a text media
      type and uses a supported character encoding ("charset" parameter). The To
      header field is included in the URI only if it has display names or group
      syntax.
    </summary>
    <returns>A MailTo URI corresponding to this message.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.ToMailtoUrl'>
    <summary>Generates a MailTo URI (uniform resource identifier) corresponding to this
      message. The following header fields, and only these, are used to generate
      the URI: To, Cc, Bcc, In-Reply-To, Subject, Keywords, Comments. The
      message body is included in the URI only if this message has a text media
      type and uses a supported character encoding ("charset" parameter). The To
      header field is included in the URI only if it has display names or group
      syntax.
    </summary>
    <returns>A MailTo URI corresponding to this message.
    </returns>
  </doc>
  <doc name='T:PeterO.Mail.MessageDataException'>
    <summary>Exception thrown when a message has invalid syntax.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.MessageDataException.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.MessageDataException'/>
       class.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.MessageDataException.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.MessageDataException'/>
       class.
    </summary>
    <param name='message'>The parameter
      <paramref name='message'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.Mail.MessageDataException.#ctor(System.String,System.Exception)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.MessageDataException'/>
       class.
    </summary>
    <param name='message'>The parameter
      <paramref name='message'/>
       is a text string.
    </param>
    <param name='innerException'>The parameter
      <paramref name='innerException'/>
       is an Exception object.
    </param>
  </doc>
  <doc name='T:PeterO.Mail.NamedAddress'>
    <summary>Represents an email address and a name for that address. Can represent a
      group of email addresses instead.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.NamedAddress'/>
       class.
    </summary>
    <param name='address'>The parameter
      <paramref name='address'/>
       is a text string.
    </param>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='address'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>Address has an invalid syntax.; Address has an invalid syntax.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.#ctor(System.String,PeterO.Mail.Address)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.NamedAddress'/>
       class.
    </summary>
    <param name='displayName'>The parameter
      <paramref name='displayName'/>
       is a text string.
    </param>
    <param name='address'>The parameter
      <paramref name='address'/>
       is an Address object.
    </param>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='address'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.#ctor(System.String,System.Collections.Generic.IList{PeterO.Mail.NamedAddress})'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.NamedAddress'/>
       class.
    </summary>
    <param name='groupName'>The parameter
      <paramref name='groupName'/>
       is a text string.
    </param>
    <param name='mailboxes'>The parameter
      <paramref name='mailboxes'/>
       is an IList object.
    </param>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='groupName'/>
       or
      <paramref name='mailboxes'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>GroupName is empty.; A mailbox in the list is a group.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.#ctor(System.String,System.String)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.NamedAddress'/>
       class.
    </summary>
    <param name='displayName'>The parameter
      <paramref name='displayName'/>
       is a text string.
    </param>
    <param name='address'>The parameter
      <paramref name='address'/>
       is a text string.
    </param>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='address'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.#ctor(System.String,System.String,System.String)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.NamedAddress'/>
       class.
    </summary>
    <param name='displayName'>The parameter
      <paramref name='displayName'/>
       is a text string.
    </param>
    <param name='localPart'>The parameter
      <paramref name='localPart'/>
       is a text string.
    </param>
    <param name='domain'>The parameter
      <paramref name='domain'/>
       is a text string.
    </param>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='localPart'/>
       or
      <paramref name='domain'/>
       is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.NamedAddress.Address'>
    <summary>Gets the email address associated with this object.
    </summary>
    <value>The email address associated with this object. This value is null if this
      object represents a group of addresses instead.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.AddressesEqual(PeterO.Mail.NamedAddress)'>
    <summary>Not documented yet.
    </summary>
    <param name='na'>A named address object to compare with this one. Can be null.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.NamedAddress.DisplayName'>
    <summary>Gets the display name for this email address. Returns null if the display
      name is absent.
    </summary>
    <value>The display name for this email address.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.Equals(System.Object)'>
    <summary>Determines whether this object and another object are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if this object and another object are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.GetHashCode'>
    <summary>Calculates the hash code of this object. No application or process IDs are
      used in the hash code calculation.
    </summary>
    <returns>A 32-bit hash code.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.NamedAddress.GroupAddresses'>
    <summary>Gets a read-only list of addresses that make up the group, if this object
      represents a group, or an empty list otherwise.
    </summary>
    <value>A list of addresses that make up the group, if this object represents a
      group, or an empty list otherwise.
    </value>
  </doc>
  <doc name='P:PeterO.Mail.NamedAddress.IsGroup'>
    <summary>Gets a value indicating whether this represents a group of addresses
      rather than a single address.
    </summary>
    <value><c>true</c> If this represents a group of addresses; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Mail.NamedAddress.Name'>
    <summary>Gets the display name for this email address, or the email address's value
      if the display name is null. Returns an empty string if the address and
      display name are null.
    </summary>
    <value>The name for this email address.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.ParseAddresses(System.String)'>
    <summary>Generates a list of NamedAddress objects from a comma-separated list of
      addresses. Each address must follow the syntax accepted by the
      one-argument constructor of NamedAddress.
    </summary>
    <param name='addressValue'>A comma-separate list of addresses in the form of a text string.
    </param>
    <returns>A list of addresses generated from the
      <paramref name='addressValue'/>
       parameter.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='addressValue'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.ToString'>
    <summary>Converts this object to a text string. This will generally be the form of
      this NamedAddress object as it could appear in a "To" header field.
    </summary>
    <returns>A string representation of this object.
    </returns>
  </doc>
  <doc name='T:PeterO.Mail.QuotedPrintableEncoder'>
    <summary>Encodes binary data into Quoted Printable.
    </summary>
  </doc>
  <doc name='T:PeterO.Mail.StringAndQuality'>
    <summary>Stores an arbitrary string and a "quality value" for that string. For
      instance, the string can be a language tag, and the "quality value" can be
      the degree of preference for that language.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.StringAndQuality.#ctor(System.String,System.Int32)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Mail.StringAndQuality'/>
       class.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
    <param name='quality'>The parameter
      <paramref name='quality'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='P:PeterO.Mail.StringAndQuality.Quality'>
    <summary>Gets the quality value stored by this object.
    </summary>
    <value>The quality value stored by this object.
    </value>
  </doc>
  <doc name='P:PeterO.Mail.StringAndQuality.Value'>
    <summary>Gets the arbitrary string stored by this object.
    </summary>
    <value>The arbitrary string stored by this object.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Tokener.Compare(System.Int32[],System.Int32[])'>
    <summary>Compares one integer array with another.
    </summary>
    <param name='x'>An integer array.
    </param>
    <param name='y'>An integer array.
    </param>
    <returns>Zero if both values are equal; a negative number if
      <paramref name='x'/>
       is less than
      <paramref name='y'/>
       , or a positive number if
      <paramref name='x'/>
       is greater than
      <paramref name='y'/>
       .
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='x'/>
       or
      <paramref name='y'/>
       is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.Transforms.BoundaryCheckerTransform.HasNewBodyPart'>
    <summary>Gets a value indicating whether a new body part was detected.
    </summary>
    <value><c>true</c> If a new body part was detected; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='T:PeterO.Mail.URIUtility'>
    <summary>Contains utility methods for processing Uniform Resource Identifiers
      (URIs) and Internationalized Resource Identifiers (IRIs) under RFC3986 and
      RFC3987, respectively. In the following documentation, URIs and IRIs
      include URI references and IRI references, for convenience.
    </summary>
  </doc>
  <doc name='T:PeterO.Mail.URIUtility.ParseMode'>
    <summary>Specifies whether certain characters are allowed when parsing IRIs and
      URIs.
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.URIUtility.ParseMode.IRILenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Even with this mode, strings with unpaired surrogate code points are
      considered invalid.
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.URIUtility.ParseMode.IRIStrict'>
    <summary>The rules follow the syntax for parsing IRIs. In particular, many code
      points outside the Basic Latin range (U+0000 to U+007F) are allowed.
      Strings with unpaired surrogate code points are considered invalid.
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.URIUtility.ParseMode.IRISurrogateLenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Unpaired surrogate code points are treated as though they were replacement
      characters instead for the purposes of these rules, so that strings with
      those code points are not considered invalid strings.
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.URIUtility.ParseMode.URILenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Code points outside the Basic Latin range (U+0000 to U+007F) are not
      allowed.
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.URIUtility.ParseMode.URIStrict'>
    <summary>The rules follow the syntax for parsing IRIs, except that code points
      outside the Basic Latin range (U+0000 to U+007F) are not allowed.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.URIUtility.PercentDecode(System.String)'>
    <summary>Decodes percent-encoding (of the form "%XX" where X is a hexadecimal
      digit) in the given string. Successive percent-encoded bytes are assumed
      to form characters in UTF-8.
    </summary>
    <param name='str'>A string that may contain percent encoding. May be null.
    </param>
    <returns>The string in which percent-encoding was decoded.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.URIUtility.PercentDecode(System.String,System.Int32,System.Int32)'>
    <summary>Decodes percent-encoding (of the form "%XX" where X is a hexadecimal
      digit) in the given portion of a string. Successive percent-encoded bytes
      are assumed to form characters in UTF-8.
    </summary>
    <param name='str'>A string a portion of which may contain percent encoding. May be null.
    </param>
    <param name='index'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='endIndex'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       ends. The character before this index is the last character.
    </param>
    <returns>The portion of the given string in which percent-encoding was decoded.
      Returns null if
      <paramref name='str'/>
       is ull.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.URIUtility.escapeURI(System.String,System.Int32)'>
    <summary>Escapes characters that can't appear in URIs or IRIs. The function is
      idempotent; that is, calling the function again on the result with the
      same mode doesn't change the result.
    </summary>
    <param name='s'>A string to escape.
    </param>
    <param name='mode'>The parameter
      <paramref name='mode'/>
       is a 32-bit signed integer.
    </param>
    <returns>A string possibly containing escaped characters, or null if s is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.URIUtility.hasScheme(System.String)'>
    <summary>Determines whether the string is a valid IRI with a scheme component. This
      can be used to check for relative IRI references.
      <para>The following cases return true:
      </para>
      <code>xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid IRI with a scheme component; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.URIUtility.hasSchemeForURI(System.String)'>
    <summary>Determines whether the string is a valid URI with a scheme component. This
      can be used to check for relative URI references. The following cases
      return true:
      <code>http://example/z xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid URI with a scheme component; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)'>
    <summary>Determines whether the substring is a valid CURIE reference under RDFA
      1.1. (The CURIE reference is the part after the colon.).
    </summary>
    <param name='s'>A string containing a CURIE reference. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The number of elements in the desired portion of "s" (but not more than
      "s" 's length).
    </param>
    <returns><c>true</c> if the substring is a valid CURIE reference under RDFA 1; otherwise,
      <c>false</c> . Returns false if
      <paramref name='s'/>
       is null.
    </returns>
    <exception cref='System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.URIUtility.relativeResolve(System.String,System.String)'>
    <summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue. Example:
      <c>http://example.com/my/path/dir/file.txt</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.URIUtility.relativeResolve(System.String,System.String,PeterO.Mail.URIUtility.ParseMode)'>
    <summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> . Can be null.
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.URIUtility.splitIRI(System.String)'>
    <summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI reference is syntactically valid, splits the string
      into its components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. The
      scheme, authority, query, and fragment components, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.URIUtility.splitIRI(System.String,PeterO.Mail.URIUtility.ParseMode)'>
    <summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI is syntactically valid, splits the string into its
      components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string representing an IRI. Can be null.
    </param>
    <param name='parseMode'>The parameter
      <paramref name='parseMode'/>
       is a ParseMode object.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. The
      scheme, authority, query, and fragment components, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.URIUtility.splitIRI(System.String,System.Int32,System.Int32,PeterO.Mail.URIUtility.ParseMode)'>
    <summary>Parses a substring that represents an Internationalized Resource
      Identifier (IRI) under RFC3987. If the IRI is syntactically valid, splits
      the string into its components and returns an array containing the indices
      into the components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The length of the desired portion of "s" (but not more than "s" 's
      length).
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>If the string is a valid IRI, returns an array of 10 integers. Each of the
      five pairs corresponds to the start and end index of the IRI's scheme,
      authority, path, query, or fragment component, respectively. The scheme,
      authority, query, and fragment components, if present, will each be given
      without the ending colon, the starting "//", the starting "?", and the
      starting "#", respectively. If a component is absent, both indices in that
      pair will be -1 (an index won't be less than 0 in any other case). If the
      string is null or is not a valid IRI, returns null.
    </returns>
    <exception cref='System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
  </doc>
  <doc name='T:PeterO.Rdf.URIUtility'>
    <summary>Contains utility methods for processing Uniform Resource Identifiers
      (URIs) and Internationalized Resource Identifiers (IRIs) under RFC3986 and
      RFC3987, respectively. In the following documentation, URIs and IRIs
      include URI references and IRI references, for convenience.
    </summary>
  </doc>
  <doc name='T:PeterO.Rdf.URIUtility.ParseMode'>
    <summary>Specifies whether certain characters are allowed when parsing IRIs and
      URIs.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.URIUtility.ParseMode.IRILenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Even with this mode, strings with unpaired surrogate code points are
      considered invalid.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.URIUtility.ParseMode.IRIStrict'>
    <summary>The rules follow the syntax for parsing IRIs. In particular, many code
      points outside the Basic Latin range (U+0000 to U+007F) are allowed.
      Strings with unpaired surrogate code points are considered invalid.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.URIUtility.ParseMode.IRISurrogateLenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Unpaired surrogate code points are treated as though they were replacement
      characters instead for the purposes of these rules, so that strings with
      those code points are not considered invalid strings.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.URIUtility.ParseMode.URILenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Code points outside the Basic Latin range (U+0000 to U+007F) are not
      allowed.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.URIUtility.ParseMode.URIStrict'>
    <summary>The rules follow the syntax for parsing IRIs, except that code points
      outside the Basic Latin range (U+0000 to U+007F) are not allowed.
    </summary>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.escapeURI(System.String,System.Int32)'>
    <returns>A string possibly containing escaped characters, or null if s is null.
    </returns>
    <summary>Escapes characters that cannot appear in URIs or IRIs. The function is
      idempotent; that is, calling the function again on the result with the
      same mode doesn't change the result.
    </summary>
    <param name='s'>A string to escape.
    </param>
    <param name='mode'>The parameter
      <paramref name='mode'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.hasScheme(System.String)'>
    <summary>Determines whether the string is a valid IRI with a scheme component. This
      can be used to check for relative IRI references.
      <para>The following cases return true:
      </para>
      <code>xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid IRI with a scheme component; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.hasSchemeForURI(System.String)'>
    <summary>Determines whether the string is a valid URI with a scheme component. This
      can be used to check for relative URI references. The following cases
      return true:
      <code>http://example/z xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid URI with a scheme component; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)'>
    <summary>Determines whether the substring is a valid CURIE reference under RDFA
      1.1. (The CURIE reference is the part after the colon.).
    </summary>
    <param name='s'>A string containing a CURIE reference. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The number of elements in the desired portion of "s" (but not more than
      "s" 's length).
    </param>
    <returns><c>true</c> if the substring is a valid CURIE reference under RDFA 1; otherwise,
      <c>false</c> . Returns false if
      <paramref name='s'/>
       is null.
    </returns>
    <exception cref='System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       's length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.relativeResolve(System.String,System.String)'>
    <summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If base is null or is not a valid IRI,
      returns refValue. Example: http://example.com/my/path/dir/file.txt.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.relativeResolve(System.String,System.String,PeterO.Rdf.URIUtility.ParseMode)'>
    <summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If base is null or is not a valid IRI,
      returns refValue.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.splitIRI(System.String)'>
    <summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI reference is syntactically valid, splits the string
      into its components and returns an array containing the indices into the
      components.
      <returns>If the string is a valid IRI reference, returns an array of 10 integers.
        Each of the five pairs corresponds to the start and end index of the
        IRI's scheme, authority, path, query, or fragment component,
        respectively. If a component is absent, both indices in that pair will
        be -1. If the string is null or is not a valid IRI, returns null.
      </returns>
    </summary>
    <param name='s'>A string that contains an IRI.
    </param>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.splitIRI(System.String,PeterO.Rdf.URIUtility.ParseMode)'>
    <summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI is syntactically valid, splits the string into its
      components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string representing an IRI. Can be null.
    </param>
    <param name='parseMode'>The parameter
      <paramref name='parseMode'/>
       is a ParseMode object.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. If a
      component is absent, both indices in that pair will be -1. If the string
      is null or is not a valid IRI, returns null.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.splitIRI(System.String,System.Int32,System.Int32,PeterO.Rdf.URIUtility.ParseMode)'>
    <summary>Parses a substring that represents an Internationalized Resource
      Identifier (IRI) under RFC3987. If the IRI is syntactically valid, splits
      the string into its components and returns an array containing the indices
      into the components.
    </summary>
    <param name='s'>A string that contains an IRI.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The length of the desired portion of "s" (but not more than "s" 's
      length).
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>If the string is a valid IRI, returns an array of 10 integers. Each of the
      five pairs corresponds to the start and end index of the IRI's scheme,
      authority, path, query, or fragment component, respectively. If a
      component is absent, both indices in that pair will be -1 (an index won't
      be less than 0 in any other case). If the string is null or is not a valid
      IRI, returns null.
    </returns>
    <exception cref='System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       's length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.ByteData.DecompressLz4(System.Byte[])'>
    <summary>Decompresses a byte array compressed using the LZ4 format (see "LZ4 Format
      Description" by Y Collet for more information).
    </summary>
    <param name='input'>Input byte array.
    </param>
    <returns>Decompressed output byte array.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter "output" is null.
    </exception>
    <exception cref='System.ArgumentException'>Invalid LZ4.
    </exception>
  </doc>
  <doc name='T:PeterO.Text.DomainUtility'>
    <summary>Utility methods for domain names.
    </summary>
  </doc>
  <doc name='M:PeterO.Text.DomainUtility.PunycodeLength(System.String,System.Int32,System.Int32)'>
    <summary>Gets the Punycode length of a string (Punycode is defined in RFC 3492).
    </summary>
    <param name='str'>A string containing the desired portion to get the length for.
    </param>
    <param name='index'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='endIndex'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       ends. The character before this index is the last character.
    </param>
    <returns>The Punycode length of the encoded string. If the string contains code
      points outside the Basic Latin range (U+0000 to U+007F), returns the
      Punycode length plus 4 (the length of the prefix "xn--", which usually
      indicates an internationalized domain name). If there are only Basic Latin
      code points, returns the length of the string. Returns -1 if an overflow
      error occurs.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <exception cref='System.ArgumentNullException'>Either
      <paramref name='index'/>
       or
      <paramref name='endIndex'/>
       is less than 0 or greater than
      <paramref name='str'/>
       's length, or
      <paramref name='index'/>
       is greater than
      <paramref name='endIndex'/>
       .
    </exception>
  </doc>
  <doc name='T:PeterO.Text.Idna'>
    <summary><para>Contains methods that implement Internationalized Domain Names in
        Applications (IDNA). IDNA enables using a wider range of letters,
        numbers, and certain other characters in domain names. This class
        implements the 2008 revision of IDNA, also known as IDNA2008.
      </para>
      <para>The following summarizes the rules for domain names in IDNA2008; see
        RFC5890 for more information and additional terminology.
      </para>
      <para>A domain name is divided into one or more strings separated by dots
        ("."), called
        <b>labels</b> . For IDNA2008's purposes, a valid label can be an
        <b>NR-LDH label</b> , an
        <b>A-label</b> , or a
        <b>U-label</b> .
      </para>
      <para>An LDH label contains only basic letters, basic digits, and/or "-", and
        neither begins nor ends with "-". For example, "exa-mple" and "1example"
        are LDH labels, but not "-example".
      </para>
      <para>An NR-LDH label is an LDH label whose third and fourth characters are
        not both "-". For example, "ex--ample" is not an NR-LDH label.
      </para>
      <para>A U-label contains one or more characters outside the Basic Latin range
        (U+0000 to U+007F) and meets IDNA2008 requirements for labels with such
        characters. An example is "e".
      </para>
      <para>An A-label is an LDH label beginning with "xn--" in any combination of
        case, and is convertible to a U-label. An example is "xn--e-ufa".
      </para>
      <para>An XN-label is an LDH label beginning with "xn--" in any combination of
        case.
      </para>
      <para>NOTICE: While this class's source code is in the public domain, the
        class uses two internal classes, called
        <c>NormalizationData</c> and
        <c>IdnaData</c> , that include data derived from the Unicode Character Database. See
        the documentation for the NormalizerInput class for the permission
        notice for the Unicode Character Database.
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Text.Idna.DecodeDomainName(System.String)'>
    <summary>Tries to encode each XN-label of the given domain name into Unicode. This
      method does not check the syntactic validity of the domain name before
      proceeding.
    </summary>
    <param name='value'>A domain name.
    </param>
    <returns>The domain name where each XN-label is encoded into Unicode. Labels where
      this is not possible remain unchanged.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='value'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.Idna.DecodeDomainName(System.String,System.Boolean)'>
    <summary>Tries to encode each XN-label of the given domain name into Unicode. This
      method does not check the syntactic validity of the domain name before
      proceeding.
    </summary>
    <param name='value'>A domain name.
    </param>
    <returns>The domain name where each XN-label is encoded into Unicode. Labels where
      this is not possible remain unchanged.
    </returns>
    <exception cref='System.ArgumentNullException'>value" is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.Idna.EncodeDomainName(System.String)'>
    <summary>Tries to encode each label of a domain name with code points outside the
      Basic Latin range (U+0000 to U+007F) into an XN-label. This method does
      not check the syntactic validity of the domain name before proceeding.
    </summary>
    <param name='value'>A domain name.
    </param>
    <returns>The domain name where each label with code points outside the Basic Latin
      range (U+0000 to U+007F) is encoded into an XN-label. Labels where this is
      not possible remain unchanged.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='value'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.Idna.IsValidDomainName(System.String,System.Boolean)'>
    <summary>Determines whether the given string is a domain name containing only
      U-labels, A-labels, NR-LDH labels, or any combination of these, separated
      by dots (".").
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='lookupRules'>If true, uses rules to apply when looking up the string as a domain name.
      If false, uses rules to apply when registering the string as a domain
      name.
    </param>
    <returns><c>true</c> if the given string is a syntactically valid domain name; otherwise;
      false.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='T:PeterO.Text.Normalization'>
    <summary>Represents a Unicode normalization form.
    </summary>
  </doc>
  <doc name='F:PeterO.Text.Normalization.NFC'>
    <summary>Normalization form C: canonical decomposition followed by canonical
      composition.
    </summary>
  </doc>
  <doc name='F:PeterO.Text.Normalization.NFD'>
    <summary>Normalization form D: canonical decomposition.
    </summary>
  </doc>
  <doc name='F:PeterO.Text.Normalization.NFKC'>
    <summary>Normalization form KC: compatibility decomposition followed by canonical
      composition.
    </summary>
  </doc>
  <doc name='F:PeterO.Text.Normalization.NFKD'>
    <summary>Normalization form KD: compatibility decomposition.
    </summary>
  </doc>
  <doc name='T:PeterO.Text.Normalizer'>
    <summary><para>Implements the Unicode normalization algorithm and contains methods and
        functionality to test and convert Unicode strings for Unicode
        normalization.
      </para>
      <para>NOTICE: While this class's source code is in the public domain, the
        class uses an internal class, called NormalizationData, that includes
        data derived from the Unicode Character Database. See the documentation
        for the NormalizerInput class for the permission notice for the Unicode
        Character Database.
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Text.Normalizer.#ctor(System.String,PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Text.Normalizer'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.Normalizer.IsNormalized(System.String,PeterO.Text.Normalization)'>
    <summary>Returns whether this string is normalized.
    </summary>
    <param name='str'>The string to check.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
    <returns><c>true</c> if this string is normalized; otherwise,
      <c>false</c> . Returns
      <c>false</c> if the string contains an unpaired surrogate code point.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Normalizer.Normalize(System.String,PeterO.Text.Normalization)'>
    <summary>Converts a string to the given Unicode normalization form.
    </summary>
    <param name='str'>An arbitrary string.
    </param>
    <param name='form'>The Unicode normalization form to convert to.
    </param>
    <returns>The parameter
      <paramref name='str'/>
       converted to the given normalization form.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.Normalizer.Read(System.Int32[],System.Int32,System.Int32)'>
    <summary>Reads a sequence of Unicode code points from a data source.
    </summary>
    <param name='chars'>Output buffer.
    </param>
    <param name='index'>Index in the output buffer to start writing to.
    </param>
    <param name='length'>Maximum number of code points to write.
    </param>
    <returns>The number of Unicode code points read, or 0 if the end of the source is
      reached.
    </returns>
    <exception cref='System.ArgumentException'>Either
      <paramref name='index'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='chars'/>
       's length, or
      <paramref name='chars'/>
       ' s length minus
      <paramref name='index'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='chars'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>Either "index" or "length" is less than 0 or greater than "chars"'s
      length, or "chars"'s length minus "index" is less than "length".
    </exception>
  </doc>
  <doc name='M:PeterO.Text.Normalizer.ReadChar'>
    <summary>Reads a Unicode character from a data source.
    </summary>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
  </doc>
  <doc name='T:PeterO.Text.NormalizerInput'>
    <summary><para>A character input class that implements the Unicode normalization
        algorithm and contains methods and functionality to test and convert
        text strings for normalization. This is similar to the deprecated
        Normalizer class, except it implements the ICharacterInput interface.
      </para>
      <para>The Unicode Standard includes characters, such as an acute accent, that
        can be combined with other characters to make new characters. For
        example, the letter E combines with an acute accent to make E-acute ().
        In some cases, the combined form (E-acute) should be treated as
        equivalent to the uncombined form (E plus acute). For this reason, the
        standard defines four
        <i>
           normalization forms
        </i>
         that convert strings to a single equivalent form:
      </para>
      <list>
        <item><b>NFD</b> (Normalization Form D) decomposes combined forms to their constituent
          characters (E plus acute, for example), then reorders combining marks
          to a standardized order. This is called canonical decomposition.
        </item>
        <item><b>NFC</b> does canonical decomposition, then combines certain constituent
          characters to their composites (E-acute, for example). This is called
          canonical composition.
        </item>
        <item>Two normalization forms,
          <b>NFKC</b> and
          <b>NFKD</b> , are similar to NFC and NFD, except they also "decompose" certain
          characters, such as ligatures, font or positional variants, and
          subscripts, whose visual distinction can matter in some contexts. This
          is called compatibility decomposition.
        </item>
      </list>
      <para>For more information, see Standard Annex 15 at
        <c>http://www.unicode.org/reports/tr15/</c> .
      </para>
      <para><b>Thread safety:</b> This class is mutable; its properties can be changed. None of its
        instance methods are designed to be thread safe. Therefore, access to
        objects from this class must be synchronized if multiple threads can
        access them at the same time.
      </para>
      <para>NOTICE: While this class's source code is in the public domain, the
        class uses an internal class, called NormalizationData, that includes
        data derived from the Unicode Character Database. In case doing so is
        required, the permission notice for the Unicode Character Database is
        given here:
      </para>
      <para>COPYRIGHT AND PERMISSION NOTICE
      </para>
      <para>Copyright (c) 1991-2014 Unicode, Inc. All rights reserved. Distributed
        under the Terms of Use in http://www.unicode.org/copyright.html.
      </para>
      <para>Permission is hereby granted, free of charge, to any person obtaining a
        copy of the Unicode data files and any associated documentation (the
        "Data Files") or Unicode software and any associated documentation (the
        "Software") to deal in the Data Files or Software without restriction,
        including without limitation the rights to use, copy, modify, merge,
        publish, distribute, and/or sell copies of the Data Files or Software,
        and to permit persons to whom the Data Files or Software are furnished
        to do so, provided that (a) this copyright and permission notice appear
        with all copies of the Data Files or Software, (b) this copyright and
        permission notice appear in associated documentation, and (c) there is
        clear notice in each modified Data File or in the Software as well as in
        the documentation associated with the Data File(s) or Software that the
        data or software has been modified.
      </para>
      <para>THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
        ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT
        HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR
        ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER
        RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
        CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
        CONNECTION WITH THE USE OR PERFORMANCE OF THE DATA FILES OR SOFTWARE.
      </para>
      <para>Except as contained in this notice, the name of a copyright holder shall
        not be used in advertising or otherwise to promote the sale, use or
        other dealings in these Data Files or Software without prior written
        authorization of the copyright holder.
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.#ctor(PeterO.Text.ICharacterInput)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizerInput'/>
       class.
    </summary>
    <param name='input'>The parameter
      <paramref name='input'/>
       is an ICharacterInput object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.#ctor(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizerInput'/>
       class.
    </summary>
    <param name='stream'>The parameter
      <paramref name='stream'/>
       is an ICharacterInput object.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizerInput'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.#ctor(System.String,PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizerInput'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.#ctor(System.String,System.Int32,System.Int32,PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizerInput'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <param name='length'>The parameter
      <paramref name='length'/>
       is a 32-bit signed integer.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.IsNormalized(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)'>
    <summary>Determines whether the text provided by a character input is normalized.
    </summary>
    <param name='chars'>A object that implements a streamable character input.
    </param>
    <param name='form'>Specifies the normalization form to check.
    </param>
    <returns><c>true</c> if the text is normalized; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='chars'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.IsNormalized(System.String,PeterO.Text.Normalization)'>
    <summary>Determines whether the given string is in the given Unicode normalization
      form.
    </summary>
    <param name='str'>An arbitrary string.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns><c>true</c> if the given string is in the given Unicode normalization form;
      otherwise,
      <c>false</c> . Returns
      <c>false</c> if the string contains an unpaired surrogate code point.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.Normalize(System.String,PeterO.Text.Normalization)'>
    <summary>Converts a string to the given Unicode normalization form.
    </summary>
    <param name='str'>An arbitrary string.
    </param>
    <param name='form'>The Unicode normalization form to convert to.
    </param>
    <returns>The parameter
      <paramref name='str'/>
       converted to the given normalization form.
    </returns>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='str'/>
       contains an unpaired surrogate code point.
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.Read(System.Int32[],System.Int32,System.Int32)'>
    <summary>Reads a sequence of Unicode code points from a data source.
    </summary>
    <param name='chars'>Output buffer.
    </param>
    <param name='index'>A zero-based index showing where the desired portion of
      <paramref name='chars'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='chars'/>
       (but not more than
      <paramref name='chars'/>
       's length).
    </param>
    <returns>The number of Unicode code points read, or 0 if the end of the source is
      reached.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='chars'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>Either
      <paramref name='index'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='chars'/>
       's length, or
      <paramref name='chars'/>
       ' s length minus
      <paramref name='index'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='System.ArgumentException'>Either "index" or "length" is less than 0 or greater than "chars"'s
      length, or "chars"'s length minus "index" is less than "length".
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.ReadChar'>
    <summary>Reads a Unicode character from a data source.
    </summary>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
  </doc>
  <doc name='T:PeterO.Text.NormalizingCharacterInput'>
    <summary><para>A character input class that implements the Unicode normalization
        algorithm and contains methods and functionality to test and convert
        text strings for normalization. This is similar to the deprecated
        Normalizer class, except it implements the ICharacterInput interface.
      </para>
      <list>
        <item><b>NFD</b> (Normalization Form D) decomposes combined forms to their constituent
          characters (E plus acute, for example), then reorders combining marks
          to a standardized order. This is called canonical decomposition.
        </item>
        <item><b>NFC</b> does canonical decomposition, then combines certain constituent
          characters to their composites (E-acute, for example). This is called
          canonical composition.
        </item>
        <item>Two normalization forms,
          <b>NFKC</b> and
          <b>NFKD</b> , are similar to NFC and NFD, except they also "decompose" certain
          characters, such as ligatures, font or positional variants, and
          subscripts, whose visual distinction can matter in some contexts. This
          is called compatibility decomposition.
        </item>
      </list>
      <para>For more information, see Standard Annex 15 at
        <c>http://www.unicode.org/reports/tr15/</c> .
      </para>
      <para><b>Thread safety:</b> This class is mutable; its properties can be changed. None of its
        instance methods are designed to be thread safe. Therefore, access to
        objects from this class must be synchronized if multiple threads can
        access them at the same time.
      </para>
      <para>NOTICE: While this class's source code is in the public domain, the
        class uses an internal class, called NormalizationData, that includes
        data derived from the Unicode Character Database. In case doing so is
        required, the permission notice for the Unicode Character Database is
        given here:
      </para>
      <para>COPYRIGHT AND PERMISSION NOTICE
      </para>
      <para>Copyright (c) 1991-2014 Unicode, Inc. All rights reserved. Distributed
        under the Terms of Use in http://www.unicode.org/copyright.html.
      </para>
      <para>Permission is hereby granted, free of charge, to any person obtaining a
        copy of the Unicode data files and any associated documentation (the
        "Data Files") or Unicode software and any associated documentation (the
        "Software") to deal in the Data Files or Software without restriction,
        including without limitation the rights to use, copy, modify, merge,
        publish, distribute, and/or sell copies of the Data Files or Software,
        and to permit persons to whom the Data Files or Software are furnished
        to do so, provided that (a) this copyright and permission notice appear
        with all copies of the Data Files or Software, (b) this copyright and
        permission notice appear in associated documentation, and (c) there is
        clear notice in each modified Data File or in the Software as well as in
        the documentation associated with the Data File(s) or Software that the
        data or software has been modified.
      </para>
      <para>THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
        ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT
        HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR
        ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER
        RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
        CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
        CONNECTION WITH THE USE OR PERFORMANCE OF THE DATA FILES OR SOFTWARE.
      </para>
      <para>Except as contained in this notice, the name of a copyright holder shall
        not be used in advertising or otherwise to promote the sale, use or
        other dealings in these Data Files or Software without prior written
        authorization of the copyright holder.
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.#ctor(PeterO.Text.ICharacterInput)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='input'>The parameter
      <paramref name='input'/>
       is an ICharacterInput object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.#ctor(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='stream'>The parameter
      <paramref name='stream'/>
       is an ICharacterInput object.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.#ctor(System.Collections.Generic.IList{System.Int32})'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='characterList'>The parameter
      <paramref name='characterList'/>
       is an IList object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.#ctor(System.Collections.Generic.IList{System.Int32},PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='characterList'>The parameter
      <paramref name='characterList'/>
       is an IList object.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.#ctor(System.String,PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.#ctor(System.String,System.Int32,System.Int32,PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <param name='length'>The parameter
      <paramref name='length'/>
       is a 32-bit signed integer.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.GetChars(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)'>
    <summary>Gets a list of normalized code points after reading from a character
      stream.
    </summary>
    <param name='chars'>An object that implements a stream of Unicode characters.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns>A list of the normalized Unicode characters.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='chars'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.GetChars(System.String,PeterO.Text.Normalization)'>
    <summary>Gets a list of normalized code points after reading from a string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns>A list of the normalized Unicode characters.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.IsNormalized(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)'>
    <summary>Determines whether the text provided by a character input is normalized.
    </summary>
    <param name='chars'>A object that implements a streamable character input.
    </param>
    <param name='form'>Specifies the normalization form to check.
    </param>
    <returns><c>true</c> if the text is normalized; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='chars'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.IsNormalized(System.Collections.Generic.IList{System.Int32},PeterO.Text.Normalization)'>
    <summary>Determines whether the given list of characters is in the given Unicode
      normalization form.
    </summary>
    <param name='charList'>A list of Unicode code points.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns><c>true</c> if the given list of characters is in the given Unicode normalization
      form; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='charList'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.IsNormalized(System.Int32[],PeterO.Text.Normalization)'>
    <summary>Determines whether the given array of characters is in the given Unicode
      normalization form.
    </summary>
    <param name='charArray'>An array of Unicode code points.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns><c>true</c> if the given list of characters is in the given Unicode normalization
      form; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter "charList" is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.IsNormalized(System.String,PeterO.Text.Normalization)'>
    <summary>Determines whether the given string is in the given Unicode normalization
      form.
    </summary>
    <param name='str'>An arbitrary string.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns><c>true</c> if the given string is in the given Unicode normalization form;
      otherwise,
      <c>false</c> . Returns
      <c>false</c> if the string contains an unpaired surrogate code point.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.Normalize(System.String,PeterO.Text.Normalization)'>
    <summary>Converts a string to the given Unicode normalization form.
    </summary>
    <param name='str'>An arbitrary string.
    </param>
    <param name='form'>The Unicode normalization form to convert to.
    </param>
    <returns>The parameter
      <paramref name='str'/>
       converted to the given normalization form.
    </returns>
    <exception cref='System.ArgumentException'>The parameter
      <paramref name='str'/>
       contains an unpaired surrogate code point.
    </exception>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.Read(System.Int32[],System.Int32,System.Int32)'>
    <summary>Reads a sequence of Unicode code points from a data source.
    </summary>
    <param name='chars'>Output buffer.
    </param>
    <param name='index'>A zero-based index showing where the desired portion of
      <paramref name='chars'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='chars'/>
       (but not more than
      <paramref name='chars'/>
       's length).
    </param>
    <returns>The number of Unicode code points read, or 0 if the end of the source is
      reached.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='chars'/>
       is null.
    </exception>
    <exception cref='System.ArgumentException'>Either
      <paramref name='index'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='chars'/>
       's length, or
      <paramref name='chars'/>
       ' s length minus
      <paramref name='index'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='System.ArgumentException'>Either "index" or "length" is less than 0 or greater than "chars"'s
      length, or "chars"'s length minus "index" is less than "length".
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.ReadChar'>
    <summary>Reads a Unicode character from a data source.
    </summary>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
  </doc>
  <doc name='T:PeterO.Text.ProtocolStrings'>
    <summary><para>Contains methods for preparing user-facing protocol strings (such as
        user identifiers) for equality comparison and validity checking. Such
        strings can be _internationalized_, that is, contain characters beyond
        the Basic Latin block (U+0000 to U+007F) of the Unicode Standard. See
        RFC 8264. Currently there are four profiles for internationalized
        strings: two for strings serving as user identifiers, one for arbitrary
        single-line strings (such as passwords), and one for display names.
      </para>
    </summary>
    <remarks>
      <list>
        <item>Other user-facing internationalized strings not expressly handled by
          this class include file and directory names, domain names, profile
          data voluntarily entered by users, and the text of article, post, and
          message bodies. The preparation and comparison of such strings is
          currently outside the scope of this class.
        </item>
        <item>The methods in this class are not well suited for
          <i>
             collation
          </i>
           , or lexicographic ordering, which is a comparison of text strings
          that is usually language-dependent and goes beyond equality
          comparison. Further discussion on collation can be found in Unicode
          Technical Standard 10 (UTS 10), "Unicode Collation Algorithm".
        </item>
        <item>As explained in UTS 10 sec. 1.6, collation serves the purposes of
          searching and selection (e.g., searches by name or by title). However,
          this class is directed more to equality comparisons for authentication
          or authorization purposes, or to avoid creating multiple items that
          use the same string, rather than, say, to comparisons of names or
          parts of names for the purpose of showing matching records.
        </item>
      </list>
    </remarks>
  </doc>
  <doc name='M:PeterO.Text.ProtocolStrings.IsInFreeformClass(System.String)'>
    <summary>Determines whether the given string belongs in RFC 8264's FreeformClass.
      In general, the FreeformClass contains most letters, digits, spaces,
      punctuation, and symbols in the Unicode standard, as well as all basic
      printable characters (U+0021 to U+007E), but excludes control characters
      and separators.
    </summary>
    <param name='str'>A string to check.
    </param>
    <returns><c>true</c> if the given string is empty or contains only characters allowed in RFC
      8264's FreeformClass (in the contexts required); otherwise,
      <c>false</c> . Returns
      <c>false</c> if
      <paramref name='str'/>
       is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.ProtocolStrings.IsInIdentifierClass(System.String)'>
    <summary>Determines whether the given string belongs in RFC 8264's IdentifierClass.
      In general, the IdentifierClass contains all code points in the Freeform
      class, except certain uncommon letters and digits, spaces, as well as
      punctuation and symbols outside the Basic Latin range (U+0000 to U+007F).
    </summary>
    <param name='str'>A string to check.
    </param>
    <returns><c>true</c> if the given string is empty or contains only characters allowed in RFC
      8264's IdentifierClass (in the contexts required); otherwise,
      <c>false</c> . Returns
      <c>false</c> if
      <paramref name='str'/>
       is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.ProtocolStrings.NicknameEnforce(System.String)'>
    <summary>Checks the validity of a string serving as a "memorable, human-friendly
      name" for something (see RFC 8266), as opposed to that thing's identity
      for authentication or authorization purposes (see sec. 6.1 of that RFC).
      This checking is done using the Nickname profile in RFC 8266.
    </summary>
    <param name='str'>A string serving as a nickname for something.
    </param>
    <returns>A nickname prepared for enforcement under the Nickname profile in RFC
      8266. Returns null if that string is invalid under that profile (including
      if
      <paramref name='str'/>
       is null or empty). Return values of this method should not be used for
      comparison purposes (see RFC 8266, sec. 2.3); for such purposes, use the
      NicknameForComparison method instead.
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.ProtocolStrings.NicknameForComparison(System.String)'>
    <summary>Prepares for comparison a string serving as a "memorable, human-friendly
      name" for something (see RFC 8266), as opposed to that thing's identity
      for authentication or authorization purposes (see sec. 6.1 of that RFC).
      This operation is done using the Nickname profile in RFC 8266.
    </summary>
    <param name='str'>A string serving as a nickname for something.
    </param>
    <returns>A nickname prepared for comparison under the Nickname profile in RFC 8266.
      Returns null if that string is invalid under that profile (including if
      <paramref name='str'/>
       is null or empty). For comparison purposes, return values of this method
      should be compared code point by code point (see RFC 8266, sec. 2.4).
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.ProtocolStrings.OpaqueStringEnforce(System.String)'>
    <summary>Checks the validity of a string serving as an arbitrary single-line
      sequence of characters, such as a passphrase. This checking is done using
      the OpaqueString profile in RFC 8265. (REMARK: Specifying a string as this
      method does is not ideal if the string represents a password or other
      sensitive data, since strings are immutable in.NET and Java, so that its
      contents cannot be cleared when done. An application concerned about
      security may want to reimplement this method by passing a clearable array
      of characters rather than a text string.).
    </summary>
    <param name='str'>A string to prepare that represents an arbitrary single-line sequence of
      characters entered by a user.
    </param>
    <returns>A string prepared under the OpaqueString profile in RFC 8265. Returns null
      if that string is invalid under that profile (including if
      <paramref name='str'/>
       is null or empty). For comparison purposes, return values of this method
      should be compared code point by code point (see RFC 8265, sec. 4.2.3).
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.ProtocolStrings.UsernameEnforce(System.String)'>
    <summary>Checks the validity of a string that can serve to identify a user or
      account (a "username"), where the string is made of one or more parts
      called "userparts" separated by spaces (U+0020) and where the case of
      letters in the string is mapped to lowercase. This checking is done using
      the UsernameCaseMapped profile in RFC 8265.
    </summary>
    <param name='str'>A string to prepare that represents a user or account identifier.
    </param>
    <returns>A username where each of its parts is prepared under the
      UsernameCaseMapped profile in RFC 8265 (among other things, the string
      will be converted to lowercase). Returns null if any of those parts is
      invalid under that profile (including if
      <paramref name='str'/>
       is null or empty). Note that there will be as many spaces of separation
      between parts of the return value as between parts of the input; this
      method will not collapse multiple spaces (U+0020) into a single space. If
      such space collapsing on a string (or rejection of strings with multiple
      consecutive spaces) is desired, it should be done before that string is
      passed to this method. For comparison purposes, return values of this
      method should be compared code point by code point (see RFC 8265, sec.
      3.3.4).
    </returns>
  </doc>
  <doc name='M:PeterO.Text.ProtocolStrings.UsernameEnforce(System.String,System.Boolean)'>
    <summary>Checks the validity of a string that can serve to identify a user or
      account (a "username"), where the string is made of one or more parts
      called "userparts" separated by spaces (U+0020) and where the case of
      letters in the string is either mapped to lowercase or preserved. This
      checking is done using the UsernameCaseMapped or UsernameCasePreserved
      profile in RFC 8265.
    </summary>
    <param name='str'>A string to prepare that represents a user or account identifier.
    </param>
    <param name='preserveCase'>If true, use the UsernameCasePreserved profile to prepare each part of the
      string. If false, use the UsernameCaseMapped profile.
    </param>
    <returns>A username where each of its parts is prepared under the
      UsernameCaseMapped or UsernameCasePreserved profile in RFC 8265. Returns
      null if any of those parts is invalid under that profile (including if
      <paramref name='str'/>
       is null or empty). Note that there will be as many spaces of separation
      between parts of the return value as between parts of the input; this
      method will not collapse multiple spaces (U+0020) into a single space. If
      such space collapsing on a string (or rejection of strings with multiple
      consecutive spaces) is desired, it should be done before that string is
      passed to this method. For comparison purposes, return values of this
      method (with the same value for
      <paramref name='preserveCase'/>
       ) should be compared code point by code point (see RFC 8265, secs. 3.3.4
      and 3.4.4).
    </returns>
  </doc>
  <doc name='M:PeterO.Text.ProtocolStrings.UserpartEnforce(System.String)'>
    <summary>Checks the validity of a string without spaces that can serve to identify
      a user or account (a "userpart"), where the case of letters in the string
      is mapped to lowercase. This checking is done using the UsernameCaseMapped
      profile in RFC 8265.
    </summary>
    <param name='str'>A string to prepare that represents a user or account identifier.
    </param>
    <returns>A userpart prepared under the UsernameCaseMapped profile in RFC 8265
      (among other things, the string will be converted to lowercase). Returns
      null if
      <paramref name='str'/>
       is invalid under that profile (including if
      <paramref name='str'/>
       is null or empty). For comparison purposes, return values of this method
      should be compared code point by code point (see RFC 8265, sec. 3.3.4).
    </returns>
  </doc>
  <doc name='M:PeterO.Text.ProtocolStrings.UserpartEnforce(System.String,System.Boolean)'>
    <summary>Checks the validity of a string without spaces that can serve to identify
      a user or account (a "userpart"), where the case of letters in the string
      is either mapped to lowercase or preserved. This checking is done using
      the UsernameCaseMapped or UsernameCasePreserved profile in RFC 8265.
    </summary>
    <param name='str'>A string to prepare that represents a user or account identifier.
    </param>
    <param name='preserveCase'>If true, use the UsernameCasePreserved profile to prepare the string. If
      false, use the UsernameCaseMapped profile.
    </param>
    <returns>A userpart prepared under the UsernameCaseMapped or UsernameCasePreserved
      profile in RFC 8265. Returns null if
      <paramref name='str'/>
       is invalid under that profile (including if
      <paramref name='str'/>
       is null or empty). For comparison purposes, return values of this method
      (with the same value for
      <paramref name='preserveCase'/>
       ) should be compared code point by code point (see RFC 8265, secs. 3.3.4
      and 3.4.4).
    </returns>
    <exception cref='System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
</docs>
